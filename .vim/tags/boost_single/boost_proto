!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	2	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
a0	/usr/include/boost/proto/make_expr.hpp	/^                A0 &a0;$/;"	m	struct:boost::proto::detail::implicit_expr_1	access:public
a0	/usr/include/boost/proto/transform/call.hpp	/^                typedef typename when<_, A0>::template impl<Expr, State, Data>::result_type a0;$/;"	t	struct:boost::proto::call::impl2	access:public
a1	/usr/include/boost/proto/transform/call.hpp	/^                typedef typename when<_, A1>::template impl<Expr, State, Data>::result_type a1;$/;"	t	struct:boost::proto::call::impl2	access:public
a2	/usr/include/boost/proto/transform/call.hpp	/^                typedef typename when<_, A2>::template impl<Expr, State, Data>::result_type a2;$/;"	t	struct:boost::proto::call::impl2	access:public
actual_terminal_type	/usr/include/boost/proto/deep_copy.hpp	/^                actual_terminal_type;$/;"	t	struct:boost::proto::detail::deep_copy_impl	access:public
address_of	/usr/include/boost/proto/tags.hpp	/^    struct address_of {};$/;"	s	namespace:boost::proto::tag
address_of_hack	/usr/include/boost/proto/expr.hpp	/^            struct address_of_hack$/;"	s	namespace:boost::proto::detail
address_of_hack	/usr/include/boost/proto/expr.hpp	/^            struct address_of_hack<proto::tag::address_of, Expr &>$/;"	s	namespace:boost::proto::detail
advance_impl	/usr/include/boost/proto/fusion.hpp	/^        struct advance_impl<proto::tag::proto_expr_iterator>$/;"	s	namespace:boost::fusion::extension
and_	/usr/include/boost/proto/matches.hpp	/^            struct and_ : transform<and_<BOOST_PP_ENUM_PARAMS(BOOST_PROTO_MAX_LOGICAL_ARITY, G)> >$/;"	s	namespace:boost::proto::control	inherits:transform
any	/usr/include/boost/proto/detail/decltype.hpp	/^                any(...);$/;"	p	struct:boost::proto::detail::anyns::any	access:public	signature:(....)
any	/usr/include/boost/proto/detail/decltype.hpp	/^            struct any$/;"	s	namespace:boost::proto::detail::anyns
anyns	/usr/include/boost/proto/detail/decltype.hpp	/^        namespace anyns$/;"	n	namespace:boost::proto::detail
apply	/usr/include/boost/proto/detail/reverse.hpp	/^            struct apply$/;"	s	struct:boost::fusion::meta::begin_impl	access:public
apply	/usr/include/boost/proto/detail/reverse.hpp	/^            struct apply$/;"	s	struct:boost::fusion::meta::deref_impl	access:public
apply	/usr/include/boost/proto/detail/reverse.hpp	/^            struct apply$/;"	s	struct:boost::fusion::meta::end_impl	access:public
apply	/usr/include/boost/proto/detail/reverse.hpp	/^            struct apply$/;"	s	struct:boost::fusion::meta::next_impl	access:public
apply	/usr/include/boost/proto/detail/reverse.hpp	/^            struct apply$/;"	s	struct:boost::fusion::meta::prior_impl	access:public
apply	/usr/include/boost/proto/detail/reverse.hpp	/^            struct apply$/;"	s	struct:boost::fusion::meta::value_impl	access:public
apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::advance_impl	access:public
apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::at_impl	access:public
apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::begin_impl	access:public
apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::begin_impl	inherits:fusion::segmented_begin	access:public
apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::category_of_impl	access:public
apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::deref_impl	access:public
apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::distance_impl	inherits:mpl::long_	access:public
apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::end_impl	access:public
apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::end_impl	inherits:fusion::segmented_end	access:public
apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::is_segmented_impl	inherits:mpl::true_	access:public
apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::is_view_impl	inherits:mpl::false_	access:public
apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::is_view_impl	inherits:mpl::true_	access:public
apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::next_impl	inherits:advance_impl::,apply	access:public
apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::prior_impl	inherits:advance_impl::,apply	access:public
apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::segments_impl	access:public
apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::size_impl	inherits:fusion::segmented_size	access:public
apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::size_impl	inherits:mpl::long_	access:public
apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::value_at_impl	access:public
apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::value_of_impl	access:public
apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply<Iterator, 0>$/;"	s	struct:boost::fusion::extension::deref_impl	access:public
apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply<Iterator, 0>$/;"	s	struct:boost::fusion::extension::value_of_impl	access:public
apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply<Sequence, Index, 0>$/;"	s	struct:boost::fusion::extension::at_impl	access:public
apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply<Sequence, Index, 0>$/;"	s	struct:boost::fusion::extension::value_at_impl	access:public
apply_transform	/usr/include/boost/proto/transform/impl.hpp	/^        struct apply_transform<PrimitiveTransform(Expr)>$/;"	s	namespace:boost::proto::detail	inherits:PrimitiveTransform::,impl
apply_transform	/usr/include/boost/proto/transform/impl.hpp	/^        struct apply_transform<PrimitiveTransform(Expr, State)>$/;"	s	namespace:boost::proto::detail	inherits:PrimitiveTransform::,impl
apply_transform	/usr/include/boost/proto/transform/impl.hpp	/^        struct apply_transform<PrimitiveTransform(Expr, State, Data)>$/;"	s	namespace:boost::proto::detail	inherits:PrimitiveTransform::,impl
arg	/usr/include/boost/proto/detail/poly_function.hpp	/^            arg(type t)$/;"	f	struct:boost::proto::detail::arg	access:public	signature:(type t)
arg	/usr/include/boost/proto/detail/poly_function.hpp	/^        struct arg$/;"	s	namespace:boost::proto::detail
arg	/usr/include/boost/proto/detail/poly_function.hpp	/^        struct arg<T &>$/;"	s	namespace:boost::proto::detail
arg0_	/usr/include/boost/proto/traits.hpp	/^                arg0_;$/;"	t	struct:boost::proto::result_of::as_expr	access:public
args	/usr/include/boost/proto/generate.hpp	/^                typedef Args args;$/;"	t	struct:boost::proto::detail::expr_params	access:public
argsns_	/usr/include/boost/proto/args.hpp	/^        namespace argsns_$/;"	n	namespace:boost::proto
argsns_	/usr/include/boost/proto/proto_fwd.hpp	/^    namespace argsns_$/;"	n	namespace:boost::proto
arg_weight	/usr/include/boost/proto/operators.hpp	/^        struct arg_weight$/;"	s	namespace:boost::proto::detail
arg_weight	/usr/include/boost/proto/operators.hpp	/^        struct arg_weight<Arg, Trait, typename Arg::proto_is_expr_>$/;"	s	namespace:boost::proto::detail
arity_of	/usr/include/boost/proto/traits.hpp	/^            struct arity_of$/;"	s	namespace:boost::proto::result_of	inherits:Expr::proto_arity
arity_of	/usr/include/boost/proto/traits.hpp	/^            struct arity_of<Expr &>$/;"	s	namespace:boost::proto::result_of	inherits:Expr::proto_arity
array_matches	/usr/include/boost/proto/matches.hpp	/^            struct array_matches$/;"	s	namespace:boost::proto::detail	inherits:mpl::false_
array_matches	/usr/include/boost/proto/matches.hpp	/^            struct array_matches<T[M], T *>$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
array_matches	/usr/include/boost/proto/matches.hpp	/^            struct array_matches<T[M], T const *>$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
array_matches	/usr/include/boost/proto/matches.hpp	/^            struct array_matches<T[M], T[proto::N]>$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
assign	/usr/include/boost/proto/tags.hpp	/^    struct assign {};$/;"	s	namespace:boost::proto::tag
as_callable	/usr/include/boost/proto/transform/fold.hpp	/^                as_callable(Data d)$/;"	f	struct:boost::proto::detail::as_callable	access:public	signature:(Data d)
as_callable	/usr/include/boost/proto/transform/fold.hpp	/^            struct as_callable$/;"	s	namespace:boost::proto::detail
as_child	/usr/include/boost/proto/traits.hpp	/^            struct as_child$/;"	s	namespace:boost::proto::functional
as_child	/usr/include/boost/proto/traits.hpp	/^            struct as_child$/;"	s	namespace:boost::proto::result_of
as_child	/usr/include/boost/proto/traits.hpp	/^            struct as_child<$/;"	s	namespace:boost::proto::result_of
as_child	/usr/include/boost/proto/traits.hpp	/^        as_child(T const &t)$/;"	f	namespace:boost::proto	signature:(T const &t)
as_element	/usr/include/boost/proto/fusion.hpp	/^        struct as_element$/;"	s	namespace:boost::proto::detail
as_expr	/usr/include/boost/proto/traits.hpp	/^            struct as_expr$/;"	s	namespace:boost::proto::functional
as_expr	/usr/include/boost/proto/traits.hpp	/^            struct as_expr$/;"	s	namespace:boost::proto::result_of
as_expr	/usr/include/boost/proto/traits.hpp	/^            struct as_expr<$/;"	s	namespace:boost::proto::result_of
as_expr	/usr/include/boost/proto/traits.hpp	/^        as_expr(T const &t)$/;"	f	namespace:boost::proto	signature:(T const &t)
as_expr_if	/usr/include/boost/proto/operators.hpp	/^        struct as_expr_if$/;"	s	namespace:boost::proto::detail	inherits:as_expr_if2
as_expr_if	/usr/include/boost/proto/operators.hpp	/^        struct as_expr_if<Tag, Left, Right, typename Left::proto_is_expr_, typename Right::proto_is_expr_>$/;"	s	namespace:boost::proto::detail	inherits:generate_if
as_expr_if2	/usr/include/boost/proto/operators.hpp	/^        struct as_expr_if2$/;"	s	namespace:boost::proto::detail
as_expr_if2	/usr/include/boost/proto/operators.hpp	/^        struct as_expr_if2<Tag, Left, Right, typename Left::proto_is_expr_, void>$/;"	s	namespace:boost::proto::detail	inherits:generate_if_left
as_expr_if2	/usr/include/boost/proto/operators.hpp	/^        struct as_expr_if2<Tag, Left, Right, void, typename Right::proto_is_expr_>$/;"	s	namespace:boost::proto::detail	inherits:generate_if_right
as_lvalue	/usr/include/boost/proto/detail/as_lvalue.hpp	/^        T &as_lvalue(T &t)$/;"	f	namespace:boost::proto::detail	signature:(T &t)
as_lvalue	/usr/include/boost/proto/detail/as_lvalue.hpp	/^        T const &as_lvalue(T const &t)$/;"	f	namespace:boost::proto::detail	signature:(T const &t)
as_mutable	/usr/include/boost/proto/detail/decltype.hpp	/^        struct as_mutable$/;"	s	namespace:boost::proto::detail
as_mutable	/usr/include/boost/proto/detail/decltype.hpp	/^        struct as_mutable<T &>$/;"	s	namespace:boost::proto::detail
as_mutable	/usr/include/boost/proto/detail/decltype.hpp	/^        struct as_mutable<T const &>$/;"	s	namespace:boost::proto::detail
as_subscriptable	/usr/include/boost/proto/detail/decltype.hpp	/^        struct as_subscriptable$/;"	s	namespace:boost::proto::detail
as_subscriptable	/usr/include/boost/proto/detail/decltype.hpp	/^        struct as_subscriptable<T &>$/;"	s	namespace:boost::proto::detail
as_subscriptable	/usr/include/boost/proto/detail/decltype.hpp	/^        struct as_subscriptable<T const &>$/;"	s	namespace:boost::proto::detail
as_subscriptable	/usr/include/boost/proto/detail/decltype.hpp	/^        struct as_subscriptable<T const>$/;"	s	namespace:boost::proto::detail
at_impl	/usr/include/boost/proto/fusion.hpp	/^        struct at_impl<proto::tag::proto_expr>$/;"	s	namespace:boost::fusion::extension
back_	/usr/include/boost/proto/args.hpp	/^                typedef Arg0 back_;$/;"	t	struct:boost::proto::argsns_::term	access:public
base_type	/usr/include/boost/proto/literal.hpp	/^            typedef extends<terminal_type, literal<T, Domain>, Domain> base_type;$/;"	t	struct:boost::proto::utility::literal	access:private
begin_impl	/usr/include/boost/proto/detail/reverse.hpp	/^        struct begin_impl<reverse_view_tag>$/;"	s	namespace:boost::fusion::meta
begin_impl	/usr/include/boost/proto/fusion.hpp	/^        struct begin_impl<proto::tag::proto_expr>$/;"	s	namespace:boost::fusion::extension
begin_impl	/usr/include/boost/proto/fusion.hpp	/^        struct begin_impl<proto::tag::proto_flat_view>$/;"	s	namespace:boost::fusion::extension
binary_expr	/usr/include/boost/proto/traits.hpp	/^            struct binary_expr$/;"	s	namespace:boost::proto::op	inherits:proto::transform
bitwise_and	/usr/include/boost/proto/tags.hpp	/^    struct bitwise_and {};$/;"	s	namespace:boost::proto::tag
bitwise_and_assign	/usr/include/boost/proto/tags.hpp	/^    struct bitwise_and_assign {};$/;"	s	namespace:boost::proto::tag
bitwise_or	/usr/include/boost/proto/tags.hpp	/^    struct bitwise_or {};$/;"	s	namespace:boost::proto::tag
bitwise_or_assign	/usr/include/boost/proto/tags.hpp	/^    struct bitwise_or_assign {};$/;"	s	namespace:boost::proto::tag
bitwise_xor	/usr/include/boost/proto/tags.hpp	/^    struct bitwise_xor {};$/;"	s	namespace:boost::proto::tag
bitwise_xor_assign	/usr/include/boost/proto/tags.hpp	/^    struct bitwise_xor_assign {};$/;"	s	namespace:boost::proto::tag
boost	/usr/include/boost/proto/args.hpp	/^    namespace boost { namespace proto$/;"	n
boost	/usr/include/boost/proto/context/callable.hpp	/^    namespace boost { namespace proto$/;"	n
boost	/usr/include/boost/proto/context/default.hpp	/^    namespace boost { namespace proto$/;"	n
boost	/usr/include/boost/proto/context/null.hpp	/^    namespace boost { namespace proto { namespace context$/;"	n
boost	/usr/include/boost/proto/debug.hpp	/^namespace boost { namespace proto$/;"	n
boost	/usr/include/boost/proto/deep_copy.hpp	/^    namespace boost { namespace proto$/;"	n
boost	/usr/include/boost/proto/detail/as_lvalue.hpp	/^namespace boost { namespace proto$/;"	n
boost	/usr/include/boost/proto/detail/decltype.hpp	/^namespace boost { namespace proto$/;"	n
boost	/usr/include/boost/proto/detail/dont_care.hpp	/^namespace boost { namespace proto$/;"	n
boost	/usr/include/boost/proto/detail/ignore_unused.hpp	/^namespace boost { namespace proto$/;"	n
boost	/usr/include/boost/proto/detail/poly_function.hpp	/^    namespace boost { namespace proto { namespace detail$/;"	n
boost	/usr/include/boost/proto/detail/pop_front.hpp	/^namespace boost { namespace fusion$/;"	n
boost	/usr/include/boost/proto/detail/reverse.hpp	/^namespace boost { namespace fusion$/;"	n
boost	/usr/include/boost/proto/domain.hpp	/^namespace boost { namespace proto$/;"	n
boost	/usr/include/boost/proto/eval.hpp	/^namespace boost { namespace proto$/;"	n
boost	/usr/include/boost/proto/expr.hpp	/^    namespace boost { namespace proto$/;"	n
boost	/usr/include/boost/proto/extends.hpp	/^namespace boost { namespace proto$/;"	n
boost	/usr/include/boost/proto/fusion.hpp	/^namespace boost { namespace fusion$/;"	n
boost	/usr/include/boost/proto/fusion.hpp	/^namespace boost { namespace mpl$/;"	n
boost	/usr/include/boost/proto/fusion.hpp	/^namespace boost { namespace proto$/;"	n
boost	/usr/include/boost/proto/generate.hpp	/^    namespace boost { namespace proto$/;"	n
boost	/usr/include/boost/proto/generate.hpp	/^    namespace boost$/;"	n
boost	/usr/include/boost/proto/literal.hpp	/^namespace boost { namespace proto$/;"	n
boost	/usr/include/boost/proto/make_expr.hpp	/^    namespace boost { namespace proto$/;"	n
boost	/usr/include/boost/proto/make_expr.hpp	/^    namespace boost$/;"	n
boost	/usr/include/boost/proto/matches.hpp	/^    namespace boost { namespace proto$/;"	n
boost	/usr/include/boost/proto/operators.hpp	/^namespace boost { namespace proto$/;"	n
boost	/usr/include/boost/proto/proto_fwd.hpp	/^namespace boost { namespace proto$/;"	n
boost	/usr/include/boost/proto/tags.hpp	/^namespace boost { namespace proto { namespace tag$/;"	n
boost	/usr/include/boost/proto/traits.hpp	/^    namespace boost { namespace proto$/;"	n
boost	/usr/include/boost/proto/transform/arg.hpp	/^namespace boost { namespace proto$/;"	n
boost	/usr/include/boost/proto/transform/call.hpp	/^    namespace boost { namespace proto$/;"	n
boost	/usr/include/boost/proto/transform/default.hpp	/^    namespace boost { namespace proto$/;"	n
boost	/usr/include/boost/proto/transform/fold.hpp	/^    namespace boost { namespace proto$/;"	n
boost	/usr/include/boost/proto/transform/fold_tree.hpp	/^namespace boost { namespace proto$/;"	n
boost	/usr/include/boost/proto/transform/impl.hpp	/^namespace boost { namespace proto$/;"	n
boost	/usr/include/boost/proto/transform/lazy.hpp	/^    namespace boost { namespace proto$/;"	n
boost	/usr/include/boost/proto/transform/make.hpp	/^    namespace boost { namespace proto$/;"	n
boost	/usr/include/boost/proto/transform/pass_through.hpp	/^    namespace boost { namespace proto$/;"	n
boost	/usr/include/boost/proto/transform/when.hpp	/^    namespace boost { namespace proto$/;"	n
boost::fusion	/usr/include/boost/proto/detail/pop_front.hpp	/^namespace boost { namespace fusion$/;"	n	namespace:boost
boost::fusion	/usr/include/boost/proto/detail/reverse.hpp	/^namespace boost { namespace fusion$/;"	n	namespace:boost
boost::fusion	/usr/include/boost/proto/fusion.hpp	/^namespace boost { namespace fusion$/;"	n	namespace:boost
boost::fusion	/usr/include/boost/proto/make_expr.hpp	/^        namespace fusion$/;"	n	namespace:boost
boost::fusion::extension	/usr/include/boost/proto/fusion.hpp	/^    namespace extension$/;"	n	namespace:boost::fusion
boost::fusion::extension::advance_impl	/usr/include/boost/proto/fusion.hpp	/^        struct advance_impl<proto::tag::proto_expr_iterator>$/;"	s	namespace:boost::fusion::extension
boost::fusion::extension::advance_impl::apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::advance_impl	access:public
boost::fusion::extension::advance_impl::apply::call	/usr/include/boost/proto/fusion.hpp	/^                static type call(Iterator const &iter)$/;"	f	struct:boost::fusion::extension::advance_impl::apply	access:public	signature:(Iterator const &iter)
boost::fusion::extension::advance_impl::apply::type	/usr/include/boost/proto/fusion.hpp	/^                type;$/;"	t	struct:boost::fusion::extension::advance_impl::apply	access:public
boost::fusion::extension::at_impl	/usr/include/boost/proto/fusion.hpp	/^        struct at_impl<proto::tag::proto_expr>$/;"	s	namespace:boost::fusion::extension
boost::fusion::extension::at_impl::apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::at_impl	access:public
boost::fusion::extension::at_impl::apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply<Sequence, Index, 0>$/;"	s	struct:boost::fusion::extension::at_impl	access:public
boost::fusion::extension::at_impl::apply::call	/usr/include/boost/proto/fusion.hpp	/^                static type call(Sequence &seq)$/;"	f	struct:boost::fusion::extension::at_impl::apply	access:public	signature:(Sequence &seq)
boost::fusion::extension::at_impl::apply::type	/usr/include/boost/proto/fusion.hpp	/^                type;$/;"	t	struct:boost::fusion::extension::at_impl::apply	access:public
boost::fusion::extension::begin_impl	/usr/include/boost/proto/fusion.hpp	/^        struct begin_impl<proto::tag::proto_expr>$/;"	s	namespace:boost::fusion::extension
boost::fusion::extension::begin_impl	/usr/include/boost/proto/fusion.hpp	/^        struct begin_impl<proto::tag::proto_flat_view>$/;"	s	namespace:boost::fusion::extension
boost::fusion::extension::begin_impl::apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::begin_impl	access:public
boost::fusion::extension::begin_impl::apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::begin_impl	inherits:fusion::segmented_begin	access:public
boost::fusion::extension::begin_impl::apply::call	/usr/include/boost/proto/fusion.hpp	/^                static type call(Sequence const &seq)$/;"	f	struct:boost::fusion::extension::begin_impl::apply	access:public	signature:(Sequence const &seq)
boost::fusion::extension::begin_impl::apply::type	/usr/include/boost/proto/fusion.hpp	/^                typedef proto::detail::expr_iterator<Sequence, 0> type;$/;"	t	struct:boost::fusion::extension::begin_impl::apply	access:public
boost::fusion::extension::category_of_impl	/usr/include/boost/proto/fusion.hpp	/^        struct category_of_impl<proto::tag::proto_expr>$/;"	s	namespace:boost::fusion::extension
boost::fusion::extension::category_of_impl	/usr/include/boost/proto/fusion.hpp	/^        struct category_of_impl<proto::tag::proto_flat_view>$/;"	s	namespace:boost::fusion::extension
boost::fusion::extension::category_of_impl::apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::category_of_impl	access:public
boost::fusion::extension::category_of_impl::apply::type	/usr/include/boost/proto/fusion.hpp	/^                typedef forward_traversal_tag type;$/;"	t	struct:boost::fusion::extension::category_of_impl::apply	access:public
boost::fusion::extension::category_of_impl::apply::type	/usr/include/boost/proto/fusion.hpp	/^                typedef random_access_traversal_tag type;$/;"	t	struct:boost::fusion::extension::category_of_impl::apply	access:public
boost::fusion::extension::deref_impl	/usr/include/boost/proto/fusion.hpp	/^        struct deref_impl<proto::tag::proto_expr_iterator>$/;"	s	namespace:boost::fusion::extension
boost::fusion::extension::deref_impl::apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::deref_impl	access:public
boost::fusion::extension::deref_impl::apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply<Iterator, 0>$/;"	s	struct:boost::fusion::extension::deref_impl	access:public
boost::fusion::extension::deref_impl::apply::call	/usr/include/boost/proto/fusion.hpp	/^                static type call(Iterator const &iter)$/;"	f	struct:boost::fusion::extension::deref_impl::apply	access:public	signature:(Iterator const &iter)
boost::fusion::extension::deref_impl::apply::type	/usr/include/boost/proto/fusion.hpp	/^                type;$/;"	t	struct:boost::fusion::extension::deref_impl::apply	access:public
boost::fusion::extension::distance_impl	/usr/include/boost/proto/fusion.hpp	/^        struct distance_impl<proto::tag::proto_expr_iterator>$/;"	s	namespace:boost::fusion::extension
boost::fusion::extension::distance_impl::apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::distance_impl	inherits:mpl::long_	access:public
boost::fusion::extension::end_impl	/usr/include/boost/proto/fusion.hpp	/^        struct end_impl<proto::tag::proto_expr>$/;"	s	namespace:boost::fusion::extension
boost::fusion::extension::end_impl	/usr/include/boost/proto/fusion.hpp	/^        struct end_impl<proto::tag::proto_flat_view>$/;"	s	namespace:boost::fusion::extension
boost::fusion::extension::end_impl::apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::end_impl	access:public
boost::fusion::extension::end_impl::apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::end_impl	inherits:fusion::segmented_end	access:public
boost::fusion::extension::end_impl::apply::call	/usr/include/boost/proto/fusion.hpp	/^                static type call(Sequence const &seq)$/;"	f	struct:boost::fusion::extension::end_impl::apply	access:public	signature:(Sequence const &seq)
boost::fusion::extension::end_impl::apply::type	/usr/include/boost/proto/fusion.hpp	/^                type;$/;"	t	struct:boost::fusion::extension::end_impl::apply	access:public
boost::fusion::extension::is_segmented_impl	/usr/include/boost/proto/fusion.hpp	/^        struct is_segmented_impl<proto::tag::proto_flat_view>$/;"	s	namespace:boost::fusion::extension
boost::fusion::extension::is_segmented_impl::apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::is_segmented_impl	inherits:mpl::true_	access:public
boost::fusion::extension::is_view_impl	/usr/include/boost/proto/fusion.hpp	/^        struct is_view_impl<proto::tag::proto_expr>$/;"	s	namespace:boost::fusion::extension
boost::fusion::extension::is_view_impl	/usr/include/boost/proto/fusion.hpp	/^        struct is_view_impl<proto::tag::proto_flat_view>$/;"	s	namespace:boost::fusion::extension
boost::fusion::extension::is_view_impl::apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::is_view_impl	inherits:mpl::false_	access:public
boost::fusion::extension::is_view_impl::apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::is_view_impl	inherits:mpl::true_	access:public
boost::fusion::extension::next_impl	/usr/include/boost/proto/fusion.hpp	/^        struct next_impl<proto::tag::proto_expr_iterator>$/;"	s	namespace:boost::fusion::extension
boost::fusion::extension::next_impl::apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::next_impl	inherits:advance_impl::,apply	access:public
boost::fusion::extension::prior_impl	/usr/include/boost/proto/fusion.hpp	/^        struct prior_impl<proto::tag::proto_expr_iterator>$/;"	s	namespace:boost::fusion::extension
boost::fusion::extension::prior_impl::apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::prior_impl	inherits:advance_impl::,apply	access:public
boost::fusion::extension::segments_impl	/usr/include/boost/proto/fusion.hpp	/^        struct segments_impl<proto::tag::proto_flat_view>$/;"	s	namespace:boost::fusion::extension
boost::fusion::extension::segments_impl::apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::segments_impl	access:public
boost::fusion::extension::segments_impl::apply::call	/usr/include/boost/proto/fusion.hpp	/^                static type call(Sequence &sequence)$/;"	f	struct:boost::fusion::extension::segments_impl::apply	access:public	signature:(Sequence &sequence)
boost::fusion::extension::segments_impl::apply::proto_tag	/usr/include/boost/proto/fusion.hpp	/^                typedef typename Sequence::proto_tag proto_tag;$/;"	t	struct:boost::fusion::extension::segments_impl::apply	access:public
boost::fusion::extension::segments_impl::apply::type	/usr/include/boost/proto/fusion.hpp	/^                > type;$/;"	t	struct:boost::fusion::extension::segments_impl::apply	access:public
boost::fusion::extension::size_impl	/usr/include/boost/proto/fusion.hpp	/^        struct size_impl<proto::tag::proto_expr>$/;"	s	namespace:boost::fusion::extension
boost::fusion::extension::size_impl	/usr/include/boost/proto/fusion.hpp	/^        struct size_impl<proto::tag::proto_flat_view>$/;"	s	namespace:boost::fusion::extension
boost::fusion::extension::size_impl::apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::size_impl	inherits:fusion::segmented_size	access:public
boost::fusion::extension::size_impl::apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::size_impl	inherits:mpl::long_	access:public
boost::fusion::extension::value_at_impl	/usr/include/boost/proto/fusion.hpp	/^        struct value_at_impl<proto::tag::proto_expr>$/;"	s	namespace:boost::fusion::extension
boost::fusion::extension::value_at_impl::apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::value_at_impl	access:public
boost::fusion::extension::value_at_impl::apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply<Sequence, Index, 0>$/;"	s	struct:boost::fusion::extension::value_at_impl	access:public
boost::fusion::extension::value_at_impl::apply::type	/usr/include/boost/proto/fusion.hpp	/^                type;$/;"	t	struct:boost::fusion::extension::value_at_impl::apply	access:public
boost::fusion::extension::value_of_impl	/usr/include/boost/proto/fusion.hpp	/^        struct value_of_impl<proto::tag::proto_expr_iterator>$/;"	s	namespace:boost::fusion::extension
boost::fusion::extension::value_of_impl::apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply$/;"	s	struct:boost::fusion::extension::value_of_impl	access:public
boost::fusion::extension::value_of_impl::apply	/usr/include/boost/proto/fusion.hpp	/^            struct apply<Iterator, 0>$/;"	s	struct:boost::fusion::extension::value_of_impl	access:public
boost::fusion::extension::value_of_impl::apply::type	/usr/include/boost/proto/fusion.hpp	/^                type;$/;"	t	struct:boost::fusion::extension::value_of_impl::apply	access:public
boost::fusion::meta	/usr/include/boost/proto/detail/pop_front.hpp	/^    namespace meta$/;"	n	namespace:boost::fusion
boost::fusion::meta	/usr/include/boost/proto/detail/reverse.hpp	/^    namespace meta$/;"	n	namespace:boost::fusion
boost::fusion::meta::begin_impl	/usr/include/boost/proto/detail/reverse.hpp	/^        struct begin_impl<reverse_view_tag>$/;"	s	namespace:boost::fusion::meta
boost::fusion::meta::begin_impl::apply	/usr/include/boost/proto/detail/reverse.hpp	/^            struct apply$/;"	s	struct:boost::fusion::meta::begin_impl	access:public
boost::fusion::meta::begin_impl::apply::call	/usr/include/boost/proto/detail/reverse.hpp	/^                call(Sequence const& s)$/;"	f	struct:boost::fusion::meta::begin_impl::apply	access:public	signature:(Sequence const& s)
boost::fusion::meta::begin_impl::apply::type	/usr/include/boost/proto/detail/reverse.hpp	/^                typedef reverse_view_iterator<typename Sequence::last_type> type;$/;"	t	struct:boost::fusion::meta::begin_impl::apply	access:public
boost::fusion::meta::deref_impl	/usr/include/boost/proto/detail/reverse.hpp	/^        struct deref_impl<reverse_view_iterator_tag>$/;"	s	namespace:boost::fusion::meta
boost::fusion::meta::deref_impl::apply	/usr/include/boost/proto/detail/reverse.hpp	/^            struct apply$/;"	s	struct:boost::fusion::meta::deref_impl	access:public
boost::fusion::meta::deref_impl::apply::call	/usr/include/boost/proto/detail/reverse.hpp	/^                call(Iterator const& i)$/;"	f	struct:boost::fusion::meta::deref_impl::apply	access:public	signature:(Iterator const& i)
boost::fusion::meta::deref_impl::apply::type	/usr/include/boost/proto/detail/reverse.hpp	/^                type;$/;"	t	struct:boost::fusion::meta::deref_impl::apply	access:public
boost::fusion::meta::end_impl	/usr/include/boost/proto/detail/reverse.hpp	/^        struct end_impl<reverse_view_tag>$/;"	s	namespace:boost::fusion::meta
boost::fusion::meta::end_impl::apply	/usr/include/boost/proto/detail/reverse.hpp	/^            struct apply$/;"	s	struct:boost::fusion::meta::end_impl	access:public
boost::fusion::meta::end_impl::apply::call	/usr/include/boost/proto/detail/reverse.hpp	/^                call(Sequence const& s)$/;"	f	struct:boost::fusion::meta::end_impl::apply	access:public	signature:(Sequence const& s)
boost::fusion::meta::end_impl::apply::type	/usr/include/boost/proto/detail/reverse.hpp	/^                typedef reverse_view_iterator<typename Sequence::first_type> type;$/;"	t	struct:boost::fusion::meta::end_impl::apply	access:public
boost::fusion::meta::next_impl	/usr/include/boost/proto/detail/reverse.hpp	/^        struct next_impl<reverse_view_iterator_tag>$/;"	s	namespace:boost::fusion::meta
boost::fusion::meta::next_impl::apply	/usr/include/boost/proto/detail/reverse.hpp	/^            struct apply$/;"	s	struct:boost::fusion::meta::next_impl	access:public
boost::fusion::meta::next_impl::apply::call	/usr/include/boost/proto/detail/reverse.hpp	/^                call(Iterator const& i)$/;"	f	struct:boost::fusion::meta::next_impl::apply	access:public	signature:(Iterator const& i)
boost::fusion::meta::next_impl::apply::first_type	/usr/include/boost/proto/detail/reverse.hpp	/^                typedef typename Iterator::first_type first_type;$/;"	t	struct:boost::fusion::meta::next_impl::apply	access:public
boost::fusion::meta::next_impl::apply::type	/usr/include/boost/proto/detail/reverse.hpp	/^                typedef reverse_view_iterator<typename wrapped::type> type;$/;"	t	struct:boost::fusion::meta::next_impl::apply	access:public
boost::fusion::meta::next_impl::apply::wrapped	/usr/include/boost/proto/detail/reverse.hpp	/^                wrapped;$/;"	t	struct:boost::fusion::meta::next_impl::apply	access:public
boost::fusion::meta::pop_front	/usr/include/boost/proto/detail/pop_front.hpp	/^        struct pop_front$/;"	s	namespace:boost::fusion::meta
boost::fusion::meta::pop_front::type	/usr/include/boost/proto/detail/pop_front.hpp	/^            type;$/;"	t	struct:boost::fusion::meta::pop_front	access:public
boost::fusion::meta::prior_impl	/usr/include/boost/proto/detail/reverse.hpp	/^        struct prior_impl<reverse_view_iterator_tag>$/;"	s	namespace:boost::fusion::meta
boost::fusion::meta::prior_impl::apply	/usr/include/boost/proto/detail/reverse.hpp	/^            struct apply$/;"	s	struct:boost::fusion::meta::prior_impl	access:public
boost::fusion::meta::prior_impl::apply::call	/usr/include/boost/proto/detail/reverse.hpp	/^                call(Iterator const& i)$/;"	f	struct:boost::fusion::meta::prior_impl::apply	access:public	signature:(Iterator const& i)
boost::fusion::meta::prior_impl::apply::first_type	/usr/include/boost/proto/detail/reverse.hpp	/^                typedef typename Iterator::first_type first_type;$/;"	t	struct:boost::fusion::meta::prior_impl::apply	access:public
boost::fusion::meta::prior_impl::apply::type	/usr/include/boost/proto/detail/reverse.hpp	/^                typedef reverse_view_iterator<typename wrapped::type> type;$/;"	t	struct:boost::fusion::meta::prior_impl::apply	access:public
boost::fusion::meta::prior_impl::apply::wrapped	/usr/include/boost/proto/detail/reverse.hpp	/^                wrapped;$/;"	t	struct:boost::fusion::meta::prior_impl::apply	access:public
boost::fusion::meta::reverse	/usr/include/boost/proto/detail/reverse.hpp	/^        struct reverse$/;"	s	namespace:boost::fusion::meta
boost::fusion::meta::reverse::type	/usr/include/boost/proto/detail/reverse.hpp	/^            typedef reverse_view<Sequence> type;$/;"	t	struct:boost::fusion::meta::reverse	access:public
boost::fusion::meta::value_impl	/usr/include/boost/proto/detail/reverse.hpp	/^        struct value_impl<reverse_view_iterator_tag>$/;"	s	namespace:boost::fusion::meta
boost::fusion::meta::value_impl::apply	/usr/include/boost/proto/detail/reverse.hpp	/^            struct apply$/;"	s	struct:boost::fusion::meta::value_impl	access:public
boost::fusion::meta::value_impl::apply::type	/usr/include/boost/proto/detail/reverse.hpp	/^                type;$/;"	t	struct:boost::fusion::meta::value_impl::apply	access:public
boost::fusion::pop_front	/usr/include/boost/proto/detail/pop_front.hpp	/^    pop_front(Sequence const& seq)$/;"	f	namespace:boost::fusion	signature:(Sequence const& seq)
boost::fusion::reverse	/usr/include/boost/proto/detail/reverse.hpp	/^    reverse(Sequence const& view)$/;"	f	namespace:boost::fusion	signature:(Sequence const& view)
boost::fusion::reverse_view	/usr/include/boost/proto/detail/reverse.hpp	/^    struct reverse_view : sequence_base<reverse_view<Sequence> >$/;"	s	namespace:boost::fusion	inherits:sequence_base
boost::fusion::reverse_view::first	/usr/include/boost/proto/detail/reverse.hpp	/^        first_type first;$/;"	m	struct:boost::fusion::reverse_view	access:public
boost::fusion::reverse_view::first_type	/usr/include/boost/proto/detail/reverse.hpp	/^        typedef typename meta::begin<seq>::type first_type;$/;"	t	struct:boost::fusion::reverse_view	access:public
boost::fusion::reverse_view::last	/usr/include/boost/proto/detail/reverse.hpp	/^        last_type last;$/;"	m	struct:boost::fusion::reverse_view	access:public
boost::fusion::reverse_view::last_type	/usr/include/boost/proto/detail/reverse.hpp	/^        typedef typename meta::end<seq>::type last_type;$/;"	t	struct:boost::fusion::reverse_view	access:public
boost::fusion::reverse_view::reverse_view	/usr/include/boost/proto/detail/reverse.hpp	/^        reverse_view(Sequence& seq)$/;"	f	struct:boost::fusion::reverse_view	access:public	signature:(Sequence& seq)
boost::fusion::reverse_view::seq	/usr/include/boost/proto/detail/reverse.hpp	/^        typedef typename seq_converter::type seq;$/;"	t	struct:boost::fusion::reverse_view	access:public
boost::fusion::reverse_view::seq_converter	/usr/include/boost/proto/detail/reverse.hpp	/^        typedef as_fusion_sequence<Sequence> seq_converter;$/;"	t	struct:boost::fusion::reverse_view	access:public
boost::fusion::reverse_view::tag	/usr/include/boost/proto/detail/reverse.hpp	/^        typedef reverse_view_tag tag;$/;"	t	struct:boost::fusion::reverse_view	access:public
boost::fusion::reverse_view_iterator	/usr/include/boost/proto/detail/reverse.hpp	/^    struct reverse_view_iterator$/;"	s	namespace:boost::fusion	inherits:iterator_base
boost::fusion::reverse_view_iterator::converter	/usr/include/boost/proto/detail/reverse.hpp	/^        typedef as_fusion_iterator<First> converter;$/;"	t	struct:boost::fusion::reverse_view_iterator	access:public
boost::fusion::reverse_view_iterator::first	/usr/include/boost/proto/detail/reverse.hpp	/^        first_type first;$/;"	m	struct:boost::fusion::reverse_view_iterator	access:public
boost::fusion::reverse_view_iterator::first_type	/usr/include/boost/proto/detail/reverse.hpp	/^        typedef typename converter::type first_type;$/;"	t	struct:boost::fusion::reverse_view_iterator	access:public
boost::fusion::reverse_view_iterator::reverse_view_iterator	/usr/include/boost/proto/detail/reverse.hpp	/^        reverse_view_iterator(First const& first)$/;"	f	struct:boost::fusion::reverse_view_iterator	access:public	signature:(First const& first)
boost::fusion::reverse_view_iterator::tag	/usr/include/boost/proto/detail/reverse.hpp	/^        typedef reverse_view_iterator_tag tag;$/;"	t	struct:boost::fusion::reverse_view_iterator	access:public
boost::mpl	/usr/include/boost/proto/fusion.hpp	/^namespace boost { namespace mpl$/;"	n	namespace:boost
boost::mpl::sequence_tag	/usr/include/boost/proto/fusion.hpp	/^    struct sequence_tag< proto::expr<Tag, Args, Arity> >$/;"	s	namespace:boost::mpl
boost::mpl::sequence_tag::type	/usr/include/boost/proto/fusion.hpp	/^        typedef fusion::fusion_sequence_tag type;$/;"	t	struct:boost::mpl::sequence_tag	access:public
boost::proto	/usr/include/boost/proto/args.hpp	/^    namespace boost { namespace proto$/;"	n	namespace:boost
boost::proto	/usr/include/boost/proto/context/callable.hpp	/^    namespace boost { namespace proto$/;"	n	namespace:boost
boost::proto	/usr/include/boost/proto/context/default.hpp	/^    namespace boost { namespace proto$/;"	n	namespace:boost
boost::proto	/usr/include/boost/proto/context/null.hpp	/^    namespace boost { namespace proto { namespace context$/;"	n	namespace:boost
boost::proto	/usr/include/boost/proto/debug.hpp	/^namespace boost { namespace proto$/;"	n	namespace:boost
boost::proto	/usr/include/boost/proto/deep_copy.hpp	/^    namespace boost { namespace proto$/;"	n	namespace:boost
boost::proto	/usr/include/boost/proto/detail/as_lvalue.hpp	/^namespace boost { namespace proto$/;"	n	namespace:boost
boost::proto	/usr/include/boost/proto/detail/decltype.hpp	/^namespace boost { namespace proto$/;"	n	namespace:boost
boost::proto	/usr/include/boost/proto/detail/dont_care.hpp	/^namespace boost { namespace proto$/;"	n	namespace:boost
boost::proto	/usr/include/boost/proto/detail/ignore_unused.hpp	/^namespace boost { namespace proto$/;"	n	namespace:boost
boost::proto	/usr/include/boost/proto/detail/poly_function.hpp	/^    namespace boost { namespace proto { namespace detail$/;"	n	namespace:boost
boost::proto	/usr/include/boost/proto/domain.hpp	/^namespace boost { namespace proto$/;"	n	namespace:boost
boost::proto	/usr/include/boost/proto/eval.hpp	/^namespace boost { namespace proto$/;"	n	namespace:boost
boost::proto	/usr/include/boost/proto/expr.hpp	/^    namespace boost { namespace proto$/;"	n	namespace:boost
boost::proto	/usr/include/boost/proto/extends.hpp	/^namespace boost { namespace proto$/;"	n	namespace:boost
boost::proto	/usr/include/boost/proto/fusion.hpp	/^namespace boost { namespace proto$/;"	n	namespace:boost
boost::proto	/usr/include/boost/proto/generate.hpp	/^    namespace boost { namespace proto$/;"	n	namespace:boost
boost::proto	/usr/include/boost/proto/literal.hpp	/^namespace boost { namespace proto$/;"	n	namespace:boost
boost::proto	/usr/include/boost/proto/make_expr.hpp	/^    namespace boost { namespace proto$/;"	n	namespace:boost
boost::proto	/usr/include/boost/proto/matches.hpp	/^    namespace boost { namespace proto$/;"	n	namespace:boost
boost::proto	/usr/include/boost/proto/operators.hpp	/^namespace boost { namespace proto$/;"	n	namespace:boost
boost::proto	/usr/include/boost/proto/proto_fwd.hpp	/^namespace boost { namespace proto$/;"	n	namespace:boost
boost::proto	/usr/include/boost/proto/tags.hpp	/^namespace boost { namespace proto { namespace tag$/;"	n	namespace:boost
boost::proto	/usr/include/boost/proto/traits.hpp	/^    namespace boost { namespace proto$/;"	n	namespace:boost
boost::proto	/usr/include/boost/proto/transform/arg.hpp	/^namespace boost { namespace proto$/;"	n	namespace:boost
boost::proto	/usr/include/boost/proto/transform/call.hpp	/^    namespace boost { namespace proto$/;"	n	namespace:boost
boost::proto	/usr/include/boost/proto/transform/default.hpp	/^    namespace boost { namespace proto$/;"	n	namespace:boost
boost::proto	/usr/include/boost/proto/transform/fold.hpp	/^    namespace boost { namespace proto$/;"	n	namespace:boost
boost::proto	/usr/include/boost/proto/transform/fold_tree.hpp	/^namespace boost { namespace proto$/;"	n	namespace:boost
boost::proto	/usr/include/boost/proto/transform/impl.hpp	/^namespace boost { namespace proto$/;"	n	namespace:boost
boost::proto	/usr/include/boost/proto/transform/lazy.hpp	/^    namespace boost { namespace proto$/;"	n	namespace:boost
boost::proto	/usr/include/boost/proto/transform/make.hpp	/^    namespace boost { namespace proto$/;"	n	namespace:boost
boost::proto	/usr/include/boost/proto/transform/pass_through.hpp	/^    namespace boost { namespace proto$/;"	n	namespace:boost
boost::proto	/usr/include/boost/proto/transform/when.hpp	/^    namespace boost { namespace proto$/;"	n	namespace:boost
boost::proto::argsns_	/usr/include/boost/proto/args.hpp	/^        namespace argsns_$/;"	n	namespace:boost::proto
boost::proto::argsns_	/usr/include/boost/proto/proto_fwd.hpp	/^    namespace argsns_$/;"	n	namespace:boost::proto
boost::proto::argsns_::term	/usr/include/boost/proto/args.hpp	/^            struct term$/;"	s	namespace:boost::proto::argsns_
boost::proto::argsns_::term::back_	/usr/include/boost/proto/args.hpp	/^                typedef Arg0 back_;$/;"	t	struct:boost::proto::argsns_::term	access:public
boost::proto::argsns_::term::BOOST_STATIC_CONSTANT	/usr/include/boost/proto/args.hpp	/^                BOOST_STATIC_CONSTANT(long, arity = 0);$/;"	p	struct:boost::proto::argsns_::term	access:public	signature:(long, arity = 0)
boost::proto::argsns_::term::child0	/usr/include/boost/proto/args.hpp	/^                typedef Arg0 child0;$/;"	t	struct:boost::proto::argsns_::term	access:public
boost::proto::as_child	/usr/include/boost/proto/traits.hpp	/^        as_child(T const &t)$/;"	f	namespace:boost::proto	signature:(T const &t)
boost::proto::as_expr	/usr/include/boost/proto/traits.hpp	/^        as_expr(T const &t)$/;"	f	namespace:boost::proto	signature:(T const &t)
boost::proto::BOOST_PROTO_DISABLE_IF_IS_CONST	/usr/include/boost/proto/traits.hpp	/^        child(Expr &e BOOST_PROTO_DISABLE_IF_IS_CONST(Expr))$/;"	f	namespace:boost::proto	signature:(Expr)
boost::proto::BOOST_PROTO_DISABLE_IF_IS_CONST	/usr/include/boost/proto/traits.hpp	/^        child(Expr2 &expr2 BOOST_PROTO_DISABLE_IF_IS_CONST(Expr2))$/;"	f	namespace:boost::proto	signature:(Expr2)
boost::proto::BOOST_PROTO_DISABLE_IF_IS_CONST	/usr/include/boost/proto/traits.hpp	/^        child_c(Expr &e BOOST_PROTO_DISABLE_IF_IS_CONST(Expr))$/;"	f	namespace:boost::proto	signature:(Expr)
boost::proto::BOOST_PROTO_DISABLE_IF_IS_CONST	/usr/include/boost/proto/traits.hpp	/^        left(Expr &e BOOST_PROTO_DISABLE_IF_IS_CONST(Expr))$/;"	f	namespace:boost::proto	signature:(Expr)
boost::proto::BOOST_PROTO_DISABLE_IF_IS_CONST	/usr/include/boost/proto/traits.hpp	/^        right(Expr &e BOOST_PROTO_DISABLE_IF_IS_CONST(Expr))$/;"	f	namespace:boost::proto	signature:(Expr)
boost::proto::BOOST_PROTO_DISABLE_IF_IS_CONST	/usr/include/boost/proto/traits.hpp	/^        value(Expr &e BOOST_PROTO_DISABLE_IF_IS_CONST(Expr))$/;"	f	namespace:boost::proto	signature:(Expr)
boost::proto::BOOST_PROTO_DISABLE_IF_IS_FUNCTION	/usr/include/boost/proto/traits.hpp	/^        as_child(T &t BOOST_PROTO_DISABLE_IF_IS_CONST(T) BOOST_PROTO_DISABLE_IF_IS_FUNCTION(T))$/;"	f	namespace:boost::proto	signature:(T)
boost::proto::BOOST_PROTO_DISABLE_IF_IS_FUNCTION	/usr/include/boost/proto/traits.hpp	/^        as_expr(T &t BOOST_PROTO_DISABLE_IF_IS_CONST(T) BOOST_PROTO_DISABLE_IF_IS_FUNCTION(T))$/;"	f	namespace:boost::proto	signature:(T)
boost::proto::call	/usr/include/boost/proto/transform/call.hpp	/^        struct call$/;"	s	namespace:boost::proto	inherits:PrimitiveTransform
boost::proto::call	/usr/include/boost/proto/transform/call.hpp	/^        struct call<Fun()> : transform<call<Fun()> >$/;"	s	namespace:boost::proto	inherits:transform
boost::proto::call	/usr/include/boost/proto/transform/call.hpp	/^        struct call<Fun(A0)> : transform<call<Fun(A0)> >$/;"	s	namespace:boost::proto	inherits:transform
boost::proto::call	/usr/include/boost/proto/transform/call.hpp	/^        struct call<Fun(A0, A1)> : transform<call<Fun(A0, A1)> >$/;"	s	namespace:boost::proto	inherits:transform
boost::proto::call	/usr/include/boost/proto/transform/call.hpp	/^        struct call<Fun(A0, A1, A2)> : transform<call<Fun(A0, A1, A2)> >$/;"	s	namespace:boost::proto	inherits:transform
boost::proto::call::impl	/usr/include/boost/proto/transform/call.hpp	/^            struct impl$/;"	s	struct:boost::proto::call	inherits:impl2	access:public
boost::proto::call::impl2	/usr/include/boost/proto/transform/call.hpp	/^            struct impl2$/;"	s	struct:boost::proto::call	inherits:transform_impl	access:public
boost::proto::call::impl2	/usr/include/boost/proto/transform/call.hpp	/^            struct impl2<Expr, State, Data, true>$/;"	s	struct:boost::proto::call	inherits:Fun::,impl	access:public
boost::proto::call::impl2	/usr/include/boost/proto/transform/call.hpp	/^            struct impl2<Expr, State, Data, true>$/;"	s	struct:boost::proto::call	inherits:transform_impl	access:public
boost::proto::call::impl2::a0	/usr/include/boost/proto/transform/call.hpp	/^                typedef typename when<_, A0>::template impl<Expr, State, Data>::result_type a0;$/;"	t	struct:boost::proto::call::impl2	access:public
boost::proto::call::impl2::a1	/usr/include/boost/proto/transform/call.hpp	/^                typedef typename when<_, A1>::template impl<Expr, State, Data>::result_type a1;$/;"	t	struct:boost::proto::call::impl2	access:public
boost::proto::call::impl2::a2	/usr/include/boost/proto/transform/call.hpp	/^                typedef typename when<_, A2>::template impl<Expr, State, Data>::result_type a2;$/;"	t	struct:boost::proto::call::impl2	access:public
boost::proto::call::impl2::operator ()	/usr/include/boost/proto/transform/call.hpp	/^                result_type operator ()($/;"	f	struct:boost::proto::call::impl2	access:public	signature:( typename impl2::expr_param e , typename impl2::state_param s , typename impl2::data_param d ) const
boost::proto::call::impl2::operator ()	/usr/include/boost/proto/transform/call.hpp	/^                result_type operator()($/;"	f	struct:boost::proto::call::impl2	access:public	signature:( typename impl2::expr_param , typename impl2::state_param , typename impl2::data_param ) const
boost::proto::call::impl2::result_type	/usr/include/boost/proto/transform/call.hpp	/^                typedef typename boost::result_of<Fun()>::type result_type;$/;"	t	struct:boost::proto::call::impl2	access:public
boost::proto::call::impl2::result_type	/usr/include/boost/proto/transform/call.hpp	/^                typedef typename detail::poly_function_traits<Fun, Fun(a0)>::result_type result_type;$/;"	t	struct:boost::proto::call::impl2	access:public
boost::proto::call::impl2::result_type	/usr/include/boost/proto/transform/call.hpp	/^                typedef typename detail::poly_function_traits<Fun, Fun(a0, a1)>::result_type result_type;$/;"	t	struct:boost::proto::call::impl2	access:public
boost::proto::call::impl2::result_type	/usr/include/boost/proto/transform/call.hpp	/^                typedef typename detail::poly_function_traits<Fun, Fun(a0, a1, a2)>::result_type result_type;$/;"	t	struct:boost::proto::call::impl2	access:public
boost::proto::call::impl2::result_type	/usr/include/boost/proto/transform/call.hpp	/^                typedef typename Fun::template impl<a0, a1, a2>::result_type result_type;$/;"	t	struct:boost::proto::call::impl2	access:public
boost::proto::call::impl2::result_type	/usr/include/boost/proto/transform/call.hpp	/^                typedef typename Fun::template impl<a0, a1, Data>::result_type result_type;$/;"	t	struct:boost::proto::call::impl2	access:public
boost::proto::call::impl2::result_type	/usr/include/boost/proto/transform/call.hpp	/^                typedef typename Fun::template impl<a0, State, Data>::result_type result_type;$/;"	t	struct:boost::proto::call::impl2	access:public
boost::proto::callable	/usr/include/boost/proto/proto_fwd.hpp	/^    struct callable$/;"	s	namespace:boost::proto
boost::proto::child	/usr/include/boost/proto/traits.hpp	/^        child(Expr const &e)$/;"	f	namespace:boost::proto	signature:(Expr const &e)
boost::proto::child	/usr/include/boost/proto/traits.hpp	/^        child(Expr2 const &expr2)$/;"	f	namespace:boost::proto	signature:(Expr2 const &expr2)
boost::proto::child_c	/usr/include/boost/proto/traits.hpp	/^        child_c(Expr const &e)$/;"	f	namespace:boost::proto	signature:(Expr const &e)
boost::proto::context	/usr/include/boost/proto/context/callable.hpp	/^        namespace context$/;"	n	namespace:boost::proto
boost::proto::context	/usr/include/boost/proto/context/default.hpp	/^        namespace context$/;"	n	namespace:boost::proto
boost::proto::context	/usr/include/boost/proto/context/null.hpp	/^    namespace boost { namespace proto { namespace context$/;"	n	namespace:boost::proto
boost::proto::context	/usr/include/boost/proto/proto_fwd.hpp	/^    namespace context$/;"	n	namespace:boost::proto
boost::proto::context::callable_context	/usr/include/boost/proto/context/callable.hpp	/^            struct callable_context$/;"	s	namespace:boost::proto::context
boost::proto::context::callable_context::eval	/usr/include/boost/proto/context/callable.hpp	/^                struct eval$/;"	s	struct:boost::proto::context::callable_context	inherits:mpl::if_c::type	access:public
boost::proto::context::callable_eval	/usr/include/boost/proto/context/callable.hpp	/^            struct callable_eval$/;"	s	namespace:boost::proto::context
boost::proto::context::callable_eval	/usr/include/boost/proto/context/callable.hpp	/^            struct callable_eval<Expr, Context, 0>$/;"	s	namespace:boost::proto::context
boost::proto::context::callable_eval::operator ()	/usr/include/boost/proto/context/callable.hpp	/^                result_type operator ()(Expr &expr, Context &context) const$/;"	f	struct:boost::proto::context::callable_eval	access:public	signature:(Expr &expr, Context &context) const
boost::proto::context::callable_eval::result_type	/usr/include/boost/proto/context/callable.hpp	/^                result_type;$/;"	t	struct:boost::proto::context::callable_eval	access:public
boost::proto::context::callable_eval::value_type	/usr/include/boost/proto/context/callable.hpp	/^                typedef typename proto::result_of::value<Expr const &>::type value_type;$/;"	t	struct:boost::proto::context::callable_eval	access:public
boost::proto::context::default_context	/usr/include/boost/proto/context/default.hpp	/^            struct default_context$/;"	s	namespace:boost::proto::context
boost::proto::context::default_context::eval	/usr/include/boost/proto/context/default.hpp	/^                struct eval$/;"	s	struct:boost::proto::context::default_context	inherits:default_eval	access:public
boost::proto::context::default_eval	/usr/include/boost/proto/context/default.hpp	/^            struct default_eval$/;"	s	namespace:boost::proto::context
boost::proto::context::default_eval	/usr/include/boost/proto/context/default.hpp	/^            struct default_eval<Expr, Context, proto::tag::comma, 2>$/;"	s	namespace:boost::proto::context
boost::proto::context::default_eval	/usr/include/boost/proto/context/default.hpp	/^            struct default_eval<Expr, Context, proto::tag::function, 1>$/;"	s	namespace:boost::proto::context
boost::proto::context::default_eval	/usr/include/boost/proto/context/default.hpp	/^            struct default_eval<Expr, Context, proto::tag::function, 2>$/;"	s	namespace:boost::proto::context
boost::proto::context::default_eval	/usr/include/boost/proto/context/default.hpp	/^            struct default_eval<Expr, Context, proto::tag::if_else_, 3>$/;"	s	namespace:boost::proto::context
boost::proto::context::default_eval	/usr/include/boost/proto/context/default.hpp	/^            struct default_eval<Expr, Context, proto::tag::post_dec, 1>$/;"	s	namespace:boost::proto::context
boost::proto::context::default_eval	/usr/include/boost/proto/context/default.hpp	/^            struct default_eval<Expr, Context, proto::tag::post_inc, 1>$/;"	s	namespace:boost::proto::context
boost::proto::context::default_eval	/usr/include/boost/proto/context/default.hpp	/^            struct default_eval<Expr, Context, proto::tag::subscript, 2>$/;"	s	namespace:boost::proto::context
boost::proto::context::default_eval	/usr/include/boost/proto/context/default.hpp	/^            struct default_eval<Expr, Context, Tag, 0>$/;"	s	namespace:boost::proto::context
boost::proto::context::default_eval	/usr/include/boost/proto/context/default.hpp	/^            struct default_eval<Expr, Context, tag::mem_ptr, 2>$/;"	s	namespace:boost::proto::context	inherits:memfun_eval
boost::proto::context::default_eval::e0	/usr/include/boost/proto/context/default.hpp	/^                typedef typename proto::result_of::child_c<Expr, 0>::type e0;$/;"	t	struct:boost::proto::context::default_eval	access:private
boost::proto::context::default_eval::e1	/usr/include/boost/proto/context/default.hpp	/^                typedef typename proto::result_of::child_c<Expr, 1>::type e1;$/;"	t	struct:boost::proto::context::default_eval	access:private
boost::proto::context::default_eval::e2	/usr/include/boost/proto/context/default.hpp	/^                typedef typename proto::result_of::child_c<Expr, 2>::type e2;$/;"	t	struct:boost::proto::context::default_eval	access:private
boost::proto::context::default_eval::function_type	/usr/include/boost/proto/context/default.hpp	/^                function_type;$/;"	t	struct:boost::proto::context::default_eval	access:public
boost::proto::context::default_eval::invoke	/usr/include/boost/proto/context/default.hpp	/^                result_type invoke(Expr &expr, Context &context, mpl::false_, mpl::false_) const$/;"	f	struct:boost::proto::context::default_eval	access:private	signature:(Expr &expr, Context &context, mpl::false_, mpl::false_) const
boost::proto::context::default_eval::invoke	/usr/include/boost/proto/context/default.hpp	/^                result_type invoke(Expr &expr, Context &context, mpl::false_, mpl::true_) const$/;"	f	struct:boost::proto::context::default_eval	access:private	signature:(Expr &expr, Context &context, mpl::false_, mpl::true_) const
boost::proto::context::default_eval::invoke	/usr/include/boost/proto/context/default.hpp	/^                result_type invoke(Expr &expr, Context &context, mpl::true_, mpl::false_) const$/;"	f	struct:boost::proto::context::default_eval	access:private	signature:(Expr &expr, Context &context, mpl::true_, mpl::false_) const
boost::proto::context::default_eval::operator ()	/usr/include/boost/proto/context/default.hpp	/^                result_type operator ()(Expr &expr, Context &) const$/;"	f	struct:boost::proto::context::default_eval	access:public	signature:(Expr &expr, Context &) const
boost::proto::context::default_eval::operator ()	/usr/include/boost/proto/context/default.hpp	/^                result_type operator ()(Expr &expr, Context &context) const$/;"	f	struct:boost::proto::context::default_eval	access:public	signature:(Expr &expr, Context &context) const
boost::proto::context::default_eval::operator ()	/usr/include/boost/proto/context/default.hpp	/^                result_type operator ()(Expr &expr, Context &ctx) const$/;"	f	struct:boost::proto::context::default_eval	access:public	signature:(Expr &expr, Context &ctx) const
boost::proto::context::default_eval::r0	/usr/include/boost/proto/context/default.hpp	/^                typedef typename proto::result_of::eval<UNREF(e0), Context>::type r0;$/;"	t	struct:boost::proto::context::default_eval	access:private
boost::proto::context::default_eval::r1	/usr/include/boost/proto/context/default.hpp	/^                typedef typename proto::result_of::eval<UNREF(e1), Context>::type r1;$/;"	t	struct:boost::proto::context::default_eval	access:private
boost::proto::context::default_eval::r2	/usr/include/boost/proto/context/default.hpp	/^                typedef typename proto::result_of::eval<UNREF(e2), Context>::type r2;$/;"	t	struct:boost::proto::context::default_eval	access:private
boost::proto::context::default_eval::result_type	/usr/include/boost/proto/context/default.hpp	/^                result_type;$/;"	t	struct:boost::proto::context::default_eval	access:public
boost::proto::context::default_eval::result_type	/usr/include/boost/proto/context/default.hpp	/^                typedef typename proto::detail::comma_result<r0, r1>::type result_type;$/;"	t	struct:boost::proto::context::default_eval	access:public
boost::proto::context::is_member_function_eval	/usr/include/boost/proto/context/default.hpp	/^            struct is_member_function_eval$/;"	s	namespace:boost::proto::context	inherits:is_member_function_pointer
boost::proto::context::memfun_eval	/usr/include/boost/proto/context/default.hpp	/^            struct memfun_eval$/;"	s	namespace:boost::proto::context
boost::proto::context::memfun_eval	/usr/include/boost/proto/context/default.hpp	/^            struct memfun_eval<Expr, Context, true>$/;"	s	namespace:boost::proto::context
boost::proto::context::memfun_eval::e0	/usr/include/boost/proto/context/default.hpp	/^                typedef typename result_of::child_c<Expr, 0>::type e0;$/;"	t	struct:boost::proto::context::memfun_eval	access:private
boost::proto::context::memfun_eval::e1	/usr/include/boost/proto/context/default.hpp	/^                typedef typename result_of::child_c<Expr, 1>::type e1;$/;"	t	struct:boost::proto::context::memfun_eval	access:private
boost::proto::context::memfun_eval::operator ()	/usr/include/boost/proto/context/default.hpp	/^                result_type const operator ()(Expr &expr, Context &ctx) const$/;"	f	struct:boost::proto::context::memfun_eval	access:public	signature:(Expr &expr, Context &ctx) const
boost::proto::context::memfun_eval::operator ()	/usr/include/boost/proto/context/default.hpp	/^                result_type operator ()(Expr &expr, Context &ctx) const$/;"	f	struct:boost::proto::context::memfun_eval	access:public	signature:(Expr &expr, Context &ctx) const
boost::proto::context::memfun_eval::r0	/usr/include/boost/proto/context/default.hpp	/^                typedef typename proto::result_of::eval<UNREF(e0), Context>::type r0;$/;"	t	struct:boost::proto::context::memfun_eval	access:private
boost::proto::context::memfun_eval::r1	/usr/include/boost/proto/context/default.hpp	/^                typedef typename proto::result_of::eval<UNREF(e1), Context>::type r1;$/;"	t	struct:boost::proto::context::memfun_eval	access:private
boost::proto::context::memfun_eval::result_type	/usr/include/boost/proto/context/default.hpp	/^                typedef detail::memfun<r0, r1> result_type;$/;"	t	struct:boost::proto::context::memfun_eval	access:public
boost::proto::context::memfun_eval::result_type	/usr/include/boost/proto/context/default.hpp	/^                typedef typename detail::mem_ptr_fun<r0, r1>::result_type result_type;$/;"	t	struct:boost::proto::context::memfun_eval	access:public
boost::proto::context::null_context	/usr/include/boost/proto/context/null.hpp	/^        struct null_context$/;"	s	namespace:boost::proto::context
boost::proto::context::null_context::eval	/usr/include/boost/proto/context/null.hpp	/^            struct eval$/;"	s	struct:boost::proto::context::null_context	inherits:null_eval	access:public
boost::proto::context::null_eval	/usr/include/boost/proto/context/null.hpp	/^        struct null_eval$/;"	s	namespace:boost::proto::context
boost::proto::context::null_eval	/usr/include/boost/proto/context/null.hpp	/^        struct null_eval<Expr, Context, 0>$/;"	s	namespace:boost::proto::context
boost::proto::context::null_eval::operator ()	/usr/include/boost/proto/context/null.hpp	/^            void operator()(Expr &, Context &) const$/;"	f	struct:boost::proto::context::null_eval	access:public	signature:(Expr &, Context &) const
boost::proto::context::null_eval::result_type	/usr/include/boost/proto/context/null.hpp	/^            typedef void result_type;$/;"	t	struct:boost::proto::context::null_eval	access:public
boost::proto::control	/usr/include/boost/proto/matches.hpp	/^        namespace control$/;"	n	namespace:boost::proto
boost::proto::control	/usr/include/boost/proto/proto_fwd.hpp	/^    namespace control$/;"	n	namespace:boost::proto
boost::proto::control::and_	/usr/include/boost/proto/matches.hpp	/^            struct and_ : transform<and_<BOOST_PP_ENUM_PARAMS(BOOST_PROTO_MAX_LOGICAL_ARITY, G)> >$/;"	s	namespace:boost::proto::control	inherits:transform
boost::proto::control::and_::impl	/usr/include/boost/proto/matches.hpp	/^                struct impl$/;"	s	struct:boost::proto::control::and_	inherits:detail::last::type::,impl	access:public
boost::proto::control::and_::proto_base_expr	/usr/include/boost/proto/matches.hpp	/^                typedef and_ proto_base_expr;$/;"	t	struct:boost::proto::control::and_	access:public
boost::proto::control::convertible_to	/usr/include/boost/proto/matches.hpp	/^            struct convertible_to$/;"	s	namespace:boost::proto::control
boost::proto::control::exact	/usr/include/boost/proto/matches.hpp	/^            struct exact$/;"	s	namespace:boost::proto::control
boost::proto::control::if_	/usr/include/boost/proto/matches.hpp	/^            struct if_ : transform<if_<If, Then, Else> >$/;"	s	namespace:boost::proto::control	inherits:transform
boost::proto::control::if_::impl	/usr/include/boost/proto/matches.hpp	/^                struct impl : transform_impl<Expr, State, Data>$/;"	s	struct:boost::proto::control::if_	inherits:transform_impl	access:public
boost::proto::control::if_::impl::condition	/usr/include/boost/proto/matches.hpp	/^                    condition;$/;"	t	struct:boost::proto::control::if_::impl	access:public
boost::proto::control::if_::impl::operator ()	/usr/include/boost/proto/matches.hpp	/^                    result_type operator ()($/;"	f	struct:boost::proto::control::if_::impl	access:public	signature:( typename impl::expr_param e , typename impl::state_param s , typename impl::data_param d ) const
boost::proto::control::if_::impl::result_type	/usr/include/boost/proto/matches.hpp	/^                    typedef typename which::template impl<Expr, State, Data>::result_type result_type;$/;"	t	struct:boost::proto::control::if_::impl	access:public
boost::proto::control::if_::impl::which	/usr/include/boost/proto/matches.hpp	/^                    which;$/;"	t	struct:boost::proto::control::if_::impl	access:public
boost::proto::control::if_::proto_base_expr	/usr/include/boost/proto/matches.hpp	/^                typedef if_ proto_base_expr;$/;"	t	struct:boost::proto::control::if_	access:public
boost::proto::control::N	/usr/include/boost/proto/proto_fwd.hpp	/^        int const N = INT_MAX;$/;"	m	namespace:boost::proto::control
boost::proto::control::not_	/usr/include/boost/proto/matches.hpp	/^            struct not_ : transform<not_<Grammar> >$/;"	s	namespace:boost::proto::control	inherits:transform
boost::proto::control::not_::impl	/usr/include/boost/proto/matches.hpp	/^                struct impl : transform_impl<Expr, State, Data>$/;"	s	struct:boost::proto::control::not_	inherits:transform_impl	access:public
boost::proto::control::not_::impl::operator ()	/usr/include/boost/proto/matches.hpp	/^                    operator()($/;"	f	struct:boost::proto::control::not_::impl	access:public	signature:( typename impl::expr_param e , typename impl::state_param , typename impl::data_param ) const
boost::proto::control::not_::impl::result_type	/usr/include/boost/proto/matches.hpp	/^                    typedef Expr result_type;$/;"	t	struct:boost::proto::control::not_::impl	access:public
boost::proto::control::not_::proto_base_expr	/usr/include/boost/proto/matches.hpp	/^                typedef not_ proto_base_expr;$/;"	t	struct:boost::proto::control::not_	access:public
boost::proto::control::or_	/usr/include/boost/proto/matches.hpp	/^            struct or_ : transform<or_<BOOST_PP_ENUM_PARAMS(BOOST_PROTO_MAX_LOGICAL_ARITY, G)> >$/;"	s	namespace:boost::proto::control	inherits:transform
boost::proto::control::or_::impl	/usr/include/boost/proto/matches.hpp	/^                struct impl$/;"	s	struct:boost::proto::control::or_	inherits:detail::matches_::which::,impl	access:public
boost::proto::control::or_::impl	/usr/include/boost/proto/matches.hpp	/^                struct impl<Expr &, State, Data>$/;"	s	struct:boost::proto::control::or_	inherits:detail::matches_::which::,impl	access:public
boost::proto::control::or_::proto_base_expr	/usr/include/boost/proto/matches.hpp	/^                typedef or_ proto_base_expr;$/;"	t	struct:boost::proto::control::or_	access:public
boost::proto::control::switch_	/usr/include/boost/proto/matches.hpp	/^            struct switch_ : transform<switch_<Cases> >$/;"	s	namespace:boost::proto::control	inherits:transform
boost::proto::control::switch_::impl	/usr/include/boost/proto/matches.hpp	/^                struct impl$/;"	s	struct:boost::proto::control::switch_	inherits:Cases::,case_::,impl	access:public
boost::proto::control::switch_::impl	/usr/include/boost/proto/matches.hpp	/^                struct impl<Expr &, State, Data>$/;"	s	struct:boost::proto::control::switch_	inherits:Cases::,case_::,impl	access:public
boost::proto::control::switch_::proto_base_expr	/usr/include/boost/proto/matches.hpp	/^                typedef switch_ proto_base_expr;$/;"	t	struct:boost::proto::control::switch_	access:public
boost::proto::control::vararg	/usr/include/boost/proto/matches.hpp	/^            struct vararg$/;"	s	namespace:boost::proto::control	inherits:Grammar
boost::proto::control::vararg::proto_is_vararg_	/usr/include/boost/proto/matches.hpp	/^                typedef void proto_is_vararg_;$/;"	t	struct:boost::proto::control::vararg	access:public
boost::proto::deep_copy	/usr/include/boost/proto/deep_copy.hpp	/^        deep_copy(Expr const &e)$/;"	f	namespace:boost::proto	signature:(Expr const &e)
boost::proto::detail	/usr/include/boost/proto/args.hpp	/^        namespace detail$/;"	n	namespace:boost::proto
boost::proto::detail	/usr/include/boost/proto/context/callable.hpp	/^        namespace detail$/;"	n	namespace:boost::proto
boost::proto::detail	/usr/include/boost/proto/deep_copy.hpp	/^        namespace detail$/;"	n	namespace:boost::proto
boost::proto::detail	/usr/include/boost/proto/detail/as_lvalue.hpp	/^    namespace detail$/;"	n	namespace:boost::proto
boost::proto::detail	/usr/include/boost/proto/detail/decltype.hpp	/^    namespace detail$/;"	n	namespace:boost::proto
boost::proto::detail	/usr/include/boost/proto/detail/dont_care.hpp	/^    namespace detail$/;"	n	namespace:boost::proto
boost::proto::detail	/usr/include/boost/proto/detail/ignore_unused.hpp	/^    namespace detail$/;"	n	namespace:boost::proto
boost::proto::detail	/usr/include/boost/proto/detail/poly_function.hpp	/^    namespace boost { namespace proto { namespace detail$/;"	n	namespace:boost::proto
boost::proto::detail	/usr/include/boost/proto/domain.hpp	/^    namespace detail$/;"	n	namespace:boost::proto
boost::proto::detail	/usr/include/boost/proto/expr.hpp	/^        namespace detail$/;"	n	namespace:boost::proto
boost::proto::detail	/usr/include/boost/proto/fusion.hpp	/^    namespace detail$/;"	n	namespace:boost::proto
boost::proto::detail	/usr/include/boost/proto/generate.hpp	/^        namespace detail$/;"	n	namespace:boost::proto
boost::proto::detail	/usr/include/boost/proto/make_expr.hpp	/^        namespace detail$/;"	n	namespace:boost::proto
boost::proto::detail	/usr/include/boost/proto/matches.hpp	/^        namespace detail$/;"	n	namespace:boost::proto
boost::proto::detail	/usr/include/boost/proto/operators.hpp	/^    namespace detail$/;"	n	namespace:boost::proto
boost::proto::detail	/usr/include/boost/proto/proto_fwd.hpp	/^    namespace detail$/;"	n	namespace:boost::proto
boost::proto::detail	/usr/include/boost/proto/traits.hpp	/^        namespace detail$/;"	n	namespace:boost::proto
boost::proto::detail	/usr/include/boost/proto/transform/default.hpp	/^        namespace detail$/;"	n	namespace:boost::proto
boost::proto::detail	/usr/include/boost/proto/transform/fold.hpp	/^        namespace detail$/;"	n	namespace:boost::proto
boost::proto::detail	/usr/include/boost/proto/transform/fold_tree.hpp	/^    namespace detail$/;"	n	namespace:boost::proto
boost::proto::detail	/usr/include/boost/proto/transform/impl.hpp	/^    namespace detail$/;"	n	namespace:boost::proto
boost::proto::detail	/usr/include/boost/proto/transform/make.hpp	/^        namespace detail$/;"	n	namespace:boost::proto
boost::proto::detail	/usr/include/boost/proto/transform/pass_through.hpp	/^        namespace detail$/;"	n	namespace:boost::proto
boost::proto::detail::address_of_hack	/usr/include/boost/proto/expr.hpp	/^            struct address_of_hack$/;"	s	namespace:boost::proto::detail
boost::proto::detail::address_of_hack	/usr/include/boost/proto/expr.hpp	/^            struct address_of_hack<proto::tag::address_of, Expr &>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::address_of_hack::type	/usr/include/boost/proto/expr.hpp	/^                typedef Expr *type;$/;"	t	struct:boost::proto::detail::address_of_hack	access:public
boost::proto::detail::address_of_hack::type	/usr/include/boost/proto/expr.hpp	/^                typedef not_a_valid_type type;$/;"	t	struct:boost::proto::detail::address_of_hack	access:public
boost::proto::detail::anyns	/usr/include/boost/proto/detail/decltype.hpp	/^        namespace anyns$/;"	n	namespace:boost::proto::detail
boost::proto::detail::anyns::any	/usr/include/boost/proto/detail/decltype.hpp	/^            struct any$/;"	s	namespace:boost::proto::detail::anyns
boost::proto::detail::anyns::any::any	/usr/include/boost/proto/detail/decltype.hpp	/^                any(...);$/;"	p	struct:boost::proto::detail::anyns::any	access:public	signature:(....)
boost::proto::detail::anyns::any::operator !	/usr/include/boost/proto/detail/decltype.hpp	/^                any operator!();$/;"	p	struct:boost::proto::detail::anyns::any	access:public	signature:()
boost::proto::detail::anyns::any::operator !=	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator!=(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
boost::proto::detail::anyns::any::operator %	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator%(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
boost::proto::detail::anyns::any::operator %=	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator%=(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
boost::proto::detail::anyns::any::operator &	/usr/include/boost/proto/detail/decltype.hpp	/^                any operator&();$/;"	p	struct:boost::proto::detail::anyns::any	access:public	signature:()
boost::proto::detail::anyns::any::operator &	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator&(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
boost::proto::detail::anyns::any::operator &&	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator&&(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
boost::proto::detail::anyns::any::operator &=	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator&=(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
boost::proto::detail::anyns::any::operator *	/usr/include/boost/proto/detail/decltype.hpp	/^                any operator*();$/;"	p	struct:boost::proto::detail::anyns::any	access:public	signature:()
boost::proto::detail::anyns::any::operator *	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator*(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
boost::proto::detail::anyns::any::operator *=	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator*=(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
boost::proto::detail::anyns::any::operator +	/usr/include/boost/proto/detail/decltype.hpp	/^                any operator+();$/;"	p	struct:boost::proto::detail::anyns::any	access:public	signature:()
boost::proto::detail::anyns::any::operator +	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator+(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
boost::proto::detail::anyns::any::operator ++	/usr/include/boost/proto/detail/decltype.hpp	/^                any operator++();$/;"	p	struct:boost::proto::detail::anyns::any	access:public	signature:()
boost::proto::detail::anyns::any::operator ++	/usr/include/boost/proto/detail/decltype.hpp	/^                any operator++(int);$/;"	p	struct:boost::proto::detail::anyns::any	access:public	signature:(int)
boost::proto::detail::anyns::any::operator +=	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator+=(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
boost::proto::detail::anyns::any::operator ,	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator,(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
boost::proto::detail::anyns::any::operator -	/usr/include/boost/proto/detail/decltype.hpp	/^                any operator-();$/;"	p	struct:boost::proto::detail::anyns::any	access:public	signature:()
boost::proto::detail::anyns::any::operator -	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator-(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
boost::proto::detail::anyns::any::operator --	/usr/include/boost/proto/detail/decltype.hpp	/^                any operator--();$/;"	p	struct:boost::proto::detail::anyns::any	access:public	signature:()
boost::proto::detail::anyns::any::operator --	/usr/include/boost/proto/detail/decltype.hpp	/^                any operator--(int);$/;"	p	struct:boost::proto::detail::anyns::any	access:public	signature:(int)
boost::proto::detail::anyns::any::operator -=	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator-=(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
boost::proto::detail::anyns::any::operator ->*	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator->*(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
boost::proto::detail::anyns::any::operator /	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator\/(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
boost::proto::detail::anyns::any::operator /=	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator\/=(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
boost::proto::detail::anyns::any::operator <	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator<(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
boost::proto::detail::anyns::any::operator <<	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator<<(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
boost::proto::detail::anyns::any::operator <<=	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator<<=(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
boost::proto::detail::anyns::any::operator <=	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator<=(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
boost::proto::detail::anyns::any::operator =	/usr/include/boost/proto/detail/decltype.hpp	/^                any operator=(any);$/;"	p	struct:boost::proto::detail::anyns::any	access:public	signature:(any)
boost::proto::detail::anyns::any::operator ==	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator==(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
boost::proto::detail::anyns::any::operator >	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator>(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
boost::proto::detail::anyns::any::operator >=	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator>=(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
boost::proto::detail::anyns::any::operator >>	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator>>(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
boost::proto::detail::anyns::any::operator >>=	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator>>=(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
boost::proto::detail::anyns::any::operator T &	/usr/include/boost/proto/detail/decltype.hpp	/^                operator T &() const volatile;$/;"	p	struct:boost::proto::detail::anyns::any	access:public	signature:() const volatile
boost::proto::detail::anyns::any::operator []	/usr/include/boost/proto/detail/decltype.hpp	/^                any operator[](any);$/;"	p	struct:boost::proto::detail::anyns::any	access:public	signature:(any)
boost::proto::detail::anyns::any::operator ^	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator^(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
boost::proto::detail::anyns::any::operator ^=	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator^=(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
boost::proto::detail::anyns::any::operator |	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator|(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
boost::proto::detail::anyns::any::operator |=	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator|=(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
boost::proto::detail::anyns::any::operator ||	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator||(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
boost::proto::detail::anyns::any::operator ~	/usr/include/boost/proto/detail/decltype.hpp	/^                any operator~();$/;"	p	struct:boost::proto::detail::anyns::any	access:public	signature:()
boost::proto::detail::apply_transform	/usr/include/boost/proto/transform/impl.hpp	/^        struct apply_transform<PrimitiveTransform(Expr)>$/;"	s	namespace:boost::proto::detail	inherits:PrimitiveTransform::,impl
boost::proto::detail::apply_transform	/usr/include/boost/proto/transform/impl.hpp	/^        struct apply_transform<PrimitiveTransform(Expr, State)>$/;"	s	namespace:boost::proto::detail	inherits:PrimitiveTransform::,impl
boost::proto::detail::apply_transform	/usr/include/boost/proto/transform/impl.hpp	/^        struct apply_transform<PrimitiveTransform(Expr, State, Data)>$/;"	s	namespace:boost::proto::detail	inherits:PrimitiveTransform::,impl
boost::proto::detail::arg	/usr/include/boost/proto/detail/poly_function.hpp	/^        struct arg$/;"	s	namespace:boost::proto::detail
boost::proto::detail::arg	/usr/include/boost/proto/detail/poly_function.hpp	/^        struct arg<T &>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::arg::arg	/usr/include/boost/proto/detail/poly_function.hpp	/^            arg(type t)$/;"	f	struct:boost::proto::detail::arg	access:public	signature:(type t)
boost::proto::detail::arg::operator ()	/usr/include/boost/proto/detail/poly_function.hpp	/^            type operator()() const$/;"	f	struct:boost::proto::detail::arg	access:public	signature:() const
boost::proto::detail::arg::operator =	/usr/include/boost/proto/detail/poly_function.hpp	/^            arg &operator =(arg const &);$/;"	p	struct:boost::proto::detail::arg	access:private	signature:(arg const &)
boost::proto::detail::arg::operator type	/usr/include/boost/proto/detail/poly_function.hpp	/^            operator type() const$/;"	f	struct:boost::proto::detail::arg	access:public	signature:() const
boost::proto::detail::arg::type	/usr/include/boost/proto/detail/poly_function.hpp	/^            typedef T &type;$/;"	t	struct:boost::proto::detail::arg	access:public
boost::proto::detail::arg::type	/usr/include/boost/proto/detail/poly_function.hpp	/^            typedef T const &type;$/;"	t	struct:boost::proto::detail::arg	access:public
boost::proto::detail::arg::value	/usr/include/boost/proto/detail/poly_function.hpp	/^            type value;$/;"	m	struct:boost::proto::detail::arg	access:private
boost::proto::detail::arg_weight	/usr/include/boost/proto/operators.hpp	/^        struct arg_weight$/;"	s	namespace:boost::proto::detail
boost::proto::detail::arg_weight	/usr/include/boost/proto/operators.hpp	/^        struct arg_weight<Arg, Trait, typename Arg::proto_is_expr_>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::arg_weight::BOOST_STATIC_CONSTANT	/usr/include/boost/proto/operators.hpp	/^            BOOST_STATIC_CONSTANT(int, value = 0);$/;"	p	struct:boost::proto::detail::arg_weight	access:public	signature:(int, value = 0)
boost::proto::detail::arg_weight::BOOST_STATIC_CONSTANT	/usr/include/boost/proto/operators.hpp	/^            BOOST_STATIC_CONSTANT(int, value = 1 + Trait::value);$/;"	p	struct:boost::proto::detail::arg_weight	access:public	signature:(int, value = 1 + Trait::value)
boost::proto::detail::array_matches	/usr/include/boost/proto/matches.hpp	/^            struct array_matches$/;"	s	namespace:boost::proto::detail	inherits:mpl::false_
boost::proto::detail::array_matches	/usr/include/boost/proto/matches.hpp	/^            struct array_matches<T[M], T *>$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
boost::proto::detail::array_matches	/usr/include/boost/proto/matches.hpp	/^            struct array_matches<T[M], T const *>$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
boost::proto::detail::array_matches	/usr/include/boost/proto/matches.hpp	/^            struct array_matches<T[M], T[proto::N]>$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
boost::proto::detail::as_callable	/usr/include/boost/proto/transform/fold.hpp	/^            struct as_callable$/;"	s	namespace:boost::proto::detail
boost::proto::detail::as_callable::as_callable	/usr/include/boost/proto/transform/fold.hpp	/^                as_callable(Data d)$/;"	f	struct:boost::proto::detail::as_callable	access:public	signature:(Data d)
boost::proto::detail::as_callable::d_	/usr/include/boost/proto/transform/fold.hpp	/^                Data d_;$/;"	m	struct:boost::proto::detail::as_callable	access:private
boost::proto::detail::as_callable::operator ()	/usr/include/boost/proto/transform/fold.hpp	/^                operator ()(Expr &e, State const &s) const$/;"	f	struct:boost::proto::detail::as_callable	access:public	signature:(Expr &e, State const &s) const
boost::proto::detail::as_callable::operator ()	/usr/include/boost/proto/transform/fold.hpp	/^                operator ()(State const &s, Expr &e) const$/;"	f	struct:boost::proto::detail::as_callable	access:public	signature:(State const &s, Expr &e) const
boost::proto::detail::as_callable::result	/usr/include/boost/proto/transform/fold.hpp	/^                struct result<This(Expr, State)>$/;"	s	struct:boost::proto::detail::as_callable	access:public
boost::proto::detail::as_callable::result	/usr/include/boost/proto/transform/fold.hpp	/^                struct result<This(State, Expr)>$/;"	s	struct:boost::proto::detail::as_callable	access:public
boost::proto::detail::as_callable::result::type	/usr/include/boost/proto/transform/fold.hpp	/^                    type;$/;"	t	struct:boost::proto::detail::as_callable::result	access:public
boost::proto::detail::as_element	/usr/include/boost/proto/fusion.hpp	/^        struct as_element$/;"	s	namespace:boost::proto::detail
boost::proto::detail::as_element::result	/usr/include/boost/proto/fusion.hpp	/^            struct result<This(Expr &)>$/;"	s	struct:boost::proto::detail::as_element	inherits:mpl::if_c	access:public
boost::proto::detail::as_element::result	/usr/include/boost/proto/fusion.hpp	/^            struct result<This(Expr)>$/;"	s	struct:boost::proto::detail::as_element	inherits:result	access:public
boost::proto::detail::as_element::result::operator ()	/usr/include/boost/proto/fusion.hpp	/^            operator ()(Expr &e) const$/;"	f	class:boost::proto::detail::as_element::result	access:public	signature:(Expr &e) const
boost::proto::detail::as_element::result::operator ()	/usr/include/boost/proto/fusion.hpp	/^            operator ()(Expr const &e) const$/;"	f	class:boost::proto::detail::as_element::result	access:public	signature:(Expr const &e) const
boost::proto::detail::as_expr_if	/usr/include/boost/proto/operators.hpp	/^        struct as_expr_if$/;"	s	namespace:boost::proto::detail	inherits:as_expr_if2
boost::proto::detail::as_expr_if	/usr/include/boost/proto/operators.hpp	/^        struct as_expr_if<Tag, Left, Right, typename Left::proto_is_expr_, typename Right::proto_is_expr_>$/;"	s	namespace:boost::proto::detail	inherits:generate_if
boost::proto::detail::as_expr_if2	/usr/include/boost/proto/operators.hpp	/^        struct as_expr_if2$/;"	s	namespace:boost::proto::detail
boost::proto::detail::as_expr_if2	/usr/include/boost/proto/operators.hpp	/^        struct as_expr_if2<Tag, Left, Right, typename Left::proto_is_expr_, void>$/;"	s	namespace:boost::proto::detail	inherits:generate_if_left
boost::proto::detail::as_expr_if2	/usr/include/boost/proto/operators.hpp	/^        struct as_expr_if2<Tag, Left, Right, void, typename Right::proto_is_expr_>$/;"	s	namespace:boost::proto::detail	inherits:generate_if_right
boost::proto::detail::as_expr_if2::expr_type	/usr/include/boost/proto/operators.hpp	/^            typedef proto::expr<Tag, list2<Left &, typename proto_domain::template result<proto_domain(term_type)>::type>, 2> expr_type;$/;"	t	struct:boost::proto::detail::as_expr_if2	access:public
boost::proto::detail::as_expr_if2::expr_type	/usr/include/boost/proto/operators.hpp	/^            typedef proto::expr<Tag, list2<typename proto_domain::template result<proto_domain(term_type)>::type, Right &>, 2> expr_type;$/;"	t	struct:boost::proto::detail::as_expr_if2	access:public
boost::proto::detail::as_expr_if2::make	/usr/include/boost/proto/operators.hpp	/^            make(Left &left, Right &right)$/;"	f	struct:boost::proto::detail::as_expr_if2	access:public	signature:(Left &left, Right &right)
boost::proto::detail::as_expr_if2::proto_domain	/usr/include/boost/proto/operators.hpp	/^            typedef typename Left::proto_domain proto_domain;$/;"	t	struct:boost::proto::detail::as_expr_if2	access:public
boost::proto::detail::as_expr_if2::proto_domain	/usr/include/boost/proto/operators.hpp	/^            typedef typename Right::proto_domain proto_domain;$/;"	t	struct:boost::proto::detail::as_expr_if2	access:public
boost::proto::detail::as_expr_if2::term_type	/usr/include/boost/proto/operators.hpp	/^            typedef proto::expr<tag::terminal, term<Left &>, 0> term_type;$/;"	t	struct:boost::proto::detail::as_expr_if2	access:public
boost::proto::detail::as_expr_if2::term_type	/usr/include/boost/proto/operators.hpp	/^            typedef proto::expr<tag::terminal, term<Right &>, 0> term_type;$/;"	t	struct:boost::proto::detail::as_expr_if2	access:public
boost::proto::detail::as_expr_if::expr_type	/usr/include/boost/proto/operators.hpp	/^            typedef proto::expr<Tag, list2<Left &, Right &>, 2> expr_type;$/;"	t	struct:boost::proto::detail::as_expr_if	access:public
boost::proto::detail::as_expr_if::make	/usr/include/boost/proto/operators.hpp	/^            make(Left &left, Right &right)$/;"	f	struct:boost::proto::detail::as_expr_if	access:public	signature:(Left &left, Right &right)
boost::proto::detail::as_expr_if::proto_domain	/usr/include/boost/proto/operators.hpp	/^            typedef typename choose_domain2<typename Left::proto_domain, typename Right::proto_domain>::type proto_domain;$/;"	t	struct:boost::proto::detail::as_expr_if	access:public
boost::proto::detail::as_lvalue	/usr/include/boost/proto/detail/as_lvalue.hpp	/^        T &as_lvalue(T &t)$/;"	f	namespace:boost::proto::detail	signature:(T &t)
boost::proto::detail::as_lvalue	/usr/include/boost/proto/detail/as_lvalue.hpp	/^        T const &as_lvalue(T const &t)$/;"	f	namespace:boost::proto::detail	signature:(T const &t)
boost::proto::detail::as_mutable	/usr/include/boost/proto/detail/decltype.hpp	/^        struct as_mutable$/;"	s	namespace:boost::proto::detail
boost::proto::detail::as_mutable	/usr/include/boost/proto/detail/decltype.hpp	/^        struct as_mutable<T &>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::as_mutable	/usr/include/boost/proto/detail/decltype.hpp	/^        struct as_mutable<T const &>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::as_mutable::type	/usr/include/boost/proto/detail/decltype.hpp	/^            typedef T &type;$/;"	t	struct:boost::proto::detail::as_mutable	access:public
boost::proto::detail::as_subscriptable	/usr/include/boost/proto/detail/decltype.hpp	/^        struct as_subscriptable$/;"	s	namespace:boost::proto::detail
boost::proto::detail::as_subscriptable	/usr/include/boost/proto/detail/decltype.hpp	/^        struct as_subscriptable<T &>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::as_subscriptable	/usr/include/boost/proto/detail/decltype.hpp	/^        struct as_subscriptable<T const &>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::as_subscriptable	/usr/include/boost/proto/detail/decltype.hpp	/^        struct as_subscriptable<T const>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::as_subscriptable::type	/usr/include/boost/proto/detail/decltype.hpp	/^            type;$/;"	t	struct:boost::proto::detail::as_subscriptable	access:public
boost::proto::detail::by_value_generator_	/usr/include/boost/proto/generate.hpp	/^            struct by_value_generator_<Expr, 0>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::by_value_generator_::make	/usr/include/boost/proto/generate.hpp	/^                static type const make(Expr const &e)$/;"	f	struct:boost::proto::detail::by_value_generator_	access:public	signature:(Expr const &e)
boost::proto::detail::by_value_generator_::type	/usr/include/boost/proto/generate.hpp	/^                type;$/;"	t	struct:boost::proto::detail::by_value_generator_	access:public
boost::proto::detail::callable_context_wrapper	/usr/include/boost/proto/context/callable.hpp	/^            struct callable_context_wrapper$/;"	s	namespace:boost::proto::detail	inherits:remove_cv::type
boost::proto::detail::callable_context_wrapper::callable_context_wrapper	/usr/include/boost/proto/context/callable.hpp	/^                callable_context_wrapper();$/;"	p	struct:boost::proto::detail::callable_context_wrapper	access:public	signature:()
boost::proto::detail::callable_context_wrapper::fun_type	/usr/include/boost/proto/context/callable.hpp	/^                typedef private_type_ fun_type(...);$/;"	t	struct:boost::proto::detail::callable_context_wrapper	access:public
boost::proto::detail::callable_context_wrapper::operator =	/usr/include/boost/proto/context/callable.hpp	/^                callable_context_wrapper &operator =(callable_context_wrapper const &);$/;"	p	struct:boost::proto::detail::callable_context_wrapper	access:private	signature:(callable_context_wrapper const &)
boost::proto::detail::callable_context_wrapper::operator fun_type *	/usr/include/boost/proto/context/callable.hpp	/^                operator fun_type *() const;$/;"	p	struct:boost::proto::detail::callable_context_wrapper	access:public	signature:() const
boost::proto::detail::check_is_expr_handled	/usr/include/boost/proto/context/callable.hpp	/^            no_type check_is_expr_handled(private_type_ const &);$/;"	p	namespace:boost::proto::detail	signature:(private_type_ const &)
boost::proto::detail::check_is_expr_handled	/usr/include/boost/proto/context/callable.hpp	/^            yes_type check_is_expr_handled(T const &);$/;"	p	namespace:boost::proto::detail	signature:(T const &)
boost::proto::detail::check_reference	/usr/include/boost/proto/detail/decltype.hpp	/^        char (&check_reference(T const &))[2];$/;"	p	namespace:boost::proto::detail	signature:(T const &)
boost::proto::detail::check_reference	/usr/include/boost/proto/detail/decltype.hpp	/^        char check_reference(T &);$/;"	p	namespace:boost::proto::detail	signature:(T &)
boost::proto::detail::choose_domain2	/usr/include/boost/proto/operators.hpp	/^        struct choose_domain2$/;"	s	namespace:boost::proto::detail
boost::proto::detail::choose_domain2	/usr/include/boost/proto/operators.hpp	/^        struct choose_domain2<Domain1, proto::default_domain>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::choose_domain2	/usr/include/boost/proto/operators.hpp	/^        struct choose_domain2<proto::default_domain, Domain2>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::choose_domain2	/usr/include/boost/proto/operators.hpp	/^        struct choose_domain2<proto::default_domain, proto::default_domain>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::choose_domain2::BOOST_MPL_ASSERT	/usr/include/boost/proto/operators.hpp	/^            BOOST_MPL_ASSERT((boost::is_same<Domain1, Domain2>));$/;"	p	struct:boost::proto::detail::choose_domain2	access:public	signature:(boost::is_same<Domain1, Domain2>)
boost::proto::detail::choose_domain2::type	/usr/include/boost/proto/operators.hpp	/^            typedef Domain1 type;$/;"	t	struct:boost::proto::detail::choose_domain2	access:public
boost::proto::detail::choose_domain2::type	/usr/include/boost/proto/operators.hpp	/^            typedef Domain2 type;$/;"	t	struct:boost::proto::detail::choose_domain2	access:public
boost::proto::detail::choose_domain2::type	/usr/include/boost/proto/operators.hpp	/^            typedef proto::default_domain type;$/;"	t	struct:boost::proto::detail::choose_domain2	access:public
boost::proto::detail::classtypeof	/usr/include/boost/proto/detail/decltype.hpp	/^        struct classtypeof<T U::*>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::classtypeof::type	/usr/include/boost/proto/detail/decltype.hpp	/^            typedef U type;$/;"	t	struct:boost::proto::detail::classtypeof	access:public
boost::proto::detail::comma_result	/usr/include/boost/proto/detail/decltype.hpp	/^        struct comma_result$/;"	s	namespace:boost::proto::detail
boost::proto::detail::comma_result	/usr/include/boost/proto/detail/decltype.hpp	/^        struct comma_result<A0, void>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::comma_result	/usr/include/boost/proto/detail/decltype.hpp	/^        struct comma_result<void, A1>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::comma_result	/usr/include/boost/proto/detail/decltype.hpp	/^        struct comma_result<void, void>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::comma_result::type	/usr/include/boost/proto/detail/decltype.hpp	/^            typedef A1 type;$/;"	t	struct:boost::proto::detail::comma_result	access:public
boost::proto::detail::comma_result::type	/usr/include/boost/proto/detail/decltype.hpp	/^            typedef void type;$/;"	t	struct:boost::proto::detail::comma_result	access:public
boost::proto::detail::construct_	/usr/include/boost/proto/transform/make.hpp	/^            struct construct_$/;"	s	namespace:boost::proto::detail
boost::proto::detail::construct_	/usr/include/boost/proto/transform/make.hpp	/^            struct construct_<Type, true>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::construct_::operator ()	/usr/include/boost/proto/transform/make.hpp	/^                Type operator ()() const$/;"	f	struct:boost::proto::detail::construct_	access:public	signature:() const
boost::proto::detail::construct_::result_type	/usr/include/boost/proto/transform/make.hpp	/^                typedef Type result_type;$/;"	t	struct:boost::proto::detail::construct_	access:public
boost::proto::detail::deduce_domain0	/usr/include/boost/proto/make_expr.hpp	/^            struct deduce_domain0$/;"	s	namespace:boost::proto::detail
boost::proto::detail::deduce_domain0::type	/usr/include/boost/proto/make_expr.hpp	/^                typedef default_domain type;$/;"	t	struct:boost::proto::detail::deduce_domain0	access:public
boost::proto::detail::deep_copy_impl	/usr/include/boost/proto/deep_copy.hpp	/^            struct deep_copy_impl<Expr, 0>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::deep_copy_impl::actual_terminal_type	/usr/include/boost/proto/deep_copy.hpp	/^                actual_terminal_type;$/;"	t	struct:boost::proto::detail::deep_copy_impl	access:public
boost::proto::detail::deep_copy_impl::expr_type	/usr/include/boost/proto/deep_copy.hpp	/^                typedef typename terminal<actual_terminal_type>::type expr_type;$/;"	t	struct:boost::proto::detail::deep_copy_impl	access:public
boost::proto::detail::deep_copy_impl::operator ()	/usr/include/boost/proto/deep_copy.hpp	/^                result_type operator()(Expr2 const &e, S const &, D const &) const$/;"	f	struct:boost::proto::detail::deep_copy_impl	access:public	signature:(Expr2 const &e, S const &, D const &) const
boost::proto::detail::deep_copy_impl::proto_domain	/usr/include/boost/proto/deep_copy.hpp	/^                typedef typename Expr::proto_domain proto_domain;$/;"	t	struct:boost::proto::detail::deep_copy_impl	access:public
boost::proto::detail::deep_copy_impl::raw_terminal_type	/usr/include/boost/proto/deep_copy.hpp	/^                typedef BOOST_PROTO_UNCVREF(typename Expr::proto_child0) raw_terminal_type;$/;"	t	struct:boost::proto::detail::deep_copy_impl	access:public
boost::proto::detail::deep_copy_impl::result_type	/usr/include/boost/proto/deep_copy.hpp	/^                typedef typename proto_domain::template result<proto_domain(expr_type)>::type result_type;$/;"	t	struct:boost::proto::detail::deep_copy_impl	access:public
boost::proto::detail::dont_care	/usr/include/boost/proto/detail/dont_care.hpp	/^        struct dont_care$/;"	s	namespace:boost::proto::detail
boost::proto::detail::dont_care::dont_care	/usr/include/boost/proto/detail/dont_care.hpp	/^            dont_care(...);$/;"	p	struct:boost::proto::detail::dont_care	access:public	signature:(....)
boost::proto::detail::enable_unary	/usr/include/boost/proto/operators.hpp	/^        struct enable_unary$/;"	s	namespace:boost::proto::detail	inherits:boost::enable_if_c
boost::proto::detail::enable_unary	/usr/include/boost/proto/operators.hpp	/^        struct enable_unary<deduce_domain, Trait, Arg, Expr>$/;"	s	namespace:boost::proto::detail	inherits:boost::enable_if_c
boost::proto::detail::enable_unary	/usr/include/boost/proto/operators.hpp	/^        struct enable_unary<default_domain, Trait, Arg, Expr>$/;"	s	namespace:boost::proto::detail	inherits:boost::enable_if_c
boost::proto::detail::expr_iterator	/usr/include/boost/proto/fusion.hpp	/^        struct expr_iterator$/;"	s	namespace:boost::proto::detail	inherits:fusion::iterator_base
boost::proto::detail::expr_iterator::BOOST_STATIC_CONSTANT	/usr/include/boost/proto/fusion.hpp	/^            BOOST_STATIC_CONSTANT(long, index = Pos);$/;"	p	struct:boost::proto::detail::expr_iterator	access:public	signature:(long, index = Pos)
boost::proto::detail::expr_iterator::category	/usr/include/boost/proto/fusion.hpp	/^            typedef fusion::random_access_traversal_tag category;$/;"	t	struct:boost::proto::detail::expr_iterator	access:public
boost::proto::detail::expr_iterator::expr	/usr/include/boost/proto/fusion.hpp	/^            Expr const &expr;$/;"	m	struct:boost::proto::detail::expr_iterator	access:public
boost::proto::detail::expr_iterator::expr_iterator	/usr/include/boost/proto/fusion.hpp	/^            expr_iterator(Expr const &e)$/;"	f	struct:boost::proto::detail::expr_iterator	access:public	signature:(Expr const &e)
boost::proto::detail::expr_iterator::expr_type	/usr/include/boost/proto/fusion.hpp	/^            typedef Expr expr_type;$/;"	t	struct:boost::proto::detail::expr_iterator	access:public
boost::proto::detail::expr_iterator::fusion_tag	/usr/include/boost/proto/fusion.hpp	/^            typedef tag::proto_expr_iterator fusion_tag;$/;"	t	struct:boost::proto::detail::expr_iterator	access:public
boost::proto::detail::expr_iterator::proto_tag	/usr/include/boost/proto/fusion.hpp	/^            typedef typename Expr::proto_tag proto_tag;$/;"	t	struct:boost::proto::detail::expr_iterator	access:public
boost::proto::detail::expr_params	/usr/include/boost/proto/generate.hpp	/^            struct expr_params<proto::expr<Tag, Args, N> >$/;"	s	namespace:boost::proto::detail
boost::proto::detail::expr_params::args	/usr/include/boost/proto/generate.hpp	/^                typedef Args args;$/;"	t	struct:boost::proto::detail::expr_params	access:public
boost::proto::detail::expr_params::BOOST_STATIC_CONSTANT	/usr/include/boost/proto/generate.hpp	/^                BOOST_STATIC_CONSTANT(long, arity = N);$/;"	p	struct:boost::proto::detail::expr_params	access:public	signature:(long, arity = N)
boost::proto::detail::expr_params::tag	/usr/include/boost/proto/generate.hpp	/^                typedef Tag tag;$/;"	t	struct:boost::proto::detail::expr_params	access:public
boost::proto::detail::expr_traits	/usr/include/boost/proto/args.hpp	/^            struct expr_traits$/;"	s	namespace:boost::proto::detail
boost::proto::detail::expr_traits	/usr/include/boost/proto/args.hpp	/^            struct expr_traits<Expr &>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::expr_traits	/usr/include/boost/proto/args.hpp	/^            struct expr_traits<Expr const &>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::expr_traits::const_reference	/usr/include/boost/proto/args.hpp	/^                typedef Expr &const_reference;$/;"	t	struct:boost::proto::detail::expr_traits	access:public
boost::proto::detail::expr_traits::const_reference	/usr/include/boost/proto/args.hpp	/^                typedef Expr const &const_reference;$/;"	t	struct:boost::proto::detail::expr_traits	access:public
boost::proto::detail::expr_traits::reference	/usr/include/boost/proto/args.hpp	/^                typedef Expr &reference;$/;"	t	struct:boost::proto::detail::expr_traits	access:public
boost::proto::detail::expr_traits::reference	/usr/include/boost/proto/args.hpp	/^                typedef Expr const &reference;$/;"	t	struct:boost::proto::detail::expr_traits	access:public
boost::proto::detail::expr_traits::value_type	/usr/include/boost/proto/args.hpp	/^                typedef Expr value_type;$/;"	t	struct:boost::proto::detail::expr_traits	access:public
boost::proto::detail::flat_view	/usr/include/boost/proto/fusion.hpp	/^        struct flat_view$/;"	s	namespace:boost::proto::detail
boost::proto::detail::flat_view::category	/usr/include/boost/proto/fusion.hpp	/^            typedef fusion::forward_traversal_tag category;$/;"	t	struct:boost::proto::detail::flat_view	access:public
boost::proto::detail::flat_view::expr_	/usr/include/boost/proto/fusion.hpp	/^            Expr &expr_;$/;"	m	struct:boost::proto::detail::flat_view	access:public
boost::proto::detail::flat_view::expr_type	/usr/include/boost/proto/fusion.hpp	/^            typedef Expr expr_type;$/;"	t	struct:boost::proto::detail::flat_view	access:public
boost::proto::detail::flat_view::flat_view	/usr/include/boost/proto/fusion.hpp	/^            explicit flat_view(Expr &e)$/;"	f	struct:boost::proto::detail::flat_view	access:public	signature:(Expr &e)
boost::proto::detail::flat_view::fusion_tag	/usr/include/boost/proto/fusion.hpp	/^            typedef tag::proto_flat_view fusion_tag;$/;"	t	struct:boost::proto::detail::flat_view	access:public
boost::proto::detail::flat_view::proto_tag	/usr/include/boost/proto/fusion.hpp	/^            typedef typename Expr::proto_tag proto_tag;$/;"	t	struct:boost::proto::detail::flat_view	access:public
boost::proto::detail::fold_impl	/usr/include/boost/proto/transform/fold.hpp	/^            struct fold_impl$/;"	s	namespace:boost::proto::detail
boost::proto::detail::fold_tree_	/usr/include/boost/proto/transform/fold_tree.hpp	/^        struct fold_tree_$/;"	s	namespace:boost::proto::detail	inherits:if_
boost::proto::detail::generate_if	/usr/include/boost/proto/operators.hpp	/^        struct generate_if$/;"	s	namespace:boost::proto::detail	inherits:lazy_enable_if_c
boost::proto::detail::generate_if	/usr/include/boost/proto/operators.hpp	/^        struct generate_if<proto::default_domain, Expr, void>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::generate_if::type	/usr/include/boost/proto/operators.hpp	/^            typedef Expr type;$/;"	t	struct:boost::proto::detail::generate_if	access:public
boost::proto::detail::generate_if_left	/usr/include/boost/proto/operators.hpp	/^        struct generate_if_left$/;"	s	namespace:boost::proto::detail	inherits:lazy_enable_if_c
boost::proto::detail::generate_if_left	/usr/include/boost/proto/operators.hpp	/^        struct generate_if_left<proto::default_domain, Tag, Left, Right>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::generate_if_left::type	/usr/include/boost/proto/operators.hpp	/^            typedef proto::expr<Tag, proto::list2<Left &, Right>, 2> type;$/;"	t	struct:boost::proto::detail::generate_if_left	access:public
boost::proto::detail::generate_if_right	/usr/include/boost/proto/operators.hpp	/^        struct generate_if_right$/;"	s	namespace:boost::proto::detail	inherits:lazy_enable_if_c
boost::proto::detail::generate_if_right	/usr/include/boost/proto/operators.hpp	/^        struct generate_if_right<proto::default_domain, Tag, Left, Right>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::generate_if_right::type	/usr/include/boost/proto/operators.hpp	/^            typedef proto::expr<Tag, proto::list2<Left, Right &>, 2> type;$/;"	t	struct:boost::proto::detail::generate_if_right	access:public
boost::proto::detail::get_pointerns	/usr/include/boost/proto/detail/decltype.hpp	/^        namespace get_pointerns$/;"	n	namespace:boost::proto::detail
boost::proto::detail::get_pointerns::get_pointer	/usr/include/boost/proto/detail/decltype.hpp	/^            get_pointer(T &t)$/;"	f	namespace:boost::proto::detail::get_pointerns	signature:(T &t)
boost::proto::detail::get_pointerns::get_pointer	/usr/include/boost/proto/detail/decltype.hpp	/^            get_pointer(T const &t)$/;"	f	namespace:boost::proto::detail::get_pointerns	signature:(T const &t)
boost::proto::detail::get_pointerns::mem_ptr_fun	/usr/include/boost/proto/detail/decltype.hpp	/^            struct mem_ptr_fun$/;"	s	namespace:boost::proto::detail::get_pointerns
boost::proto::detail::get_pointerns::mem_ptr_fun	/usr/include/boost/proto/detail/decltype.hpp	/^            struct mem_ptr_fun<T, U, true>$/;"	s	namespace:boost::proto::detail::get_pointerns
boost::proto::detail::get_pointerns::mem_ptr_fun::operator ()	/usr/include/boost/proto/detail/decltype.hpp	/^                result_type operator()($/;"	f	struct:boost::proto::detail::get_pointerns::mem_ptr_fun	access:public	signature:( typename add_reference<typename add_const<T>::type>::type t , typename add_reference<typename add_const<U>::type>::type u ) const
boost::proto::detail::get_pointerns::mem_ptr_fun::operator ()	/usr/include/boost/proto/detail/decltype.hpp	/^                result_type operator()($/;"	f	struct:boost::proto::detail::get_pointerns::mem_ptr_fun	access:public	signature:( typename add_reference<typename add_const<T>::type>::type t , U u ) const
boost::proto::detail::get_pointerns::mem_ptr_fun::proto::detail::make	/usr/include/boost/proto/detail/decltype.hpp	/^                    BOOST_PROTO_GET_POINTER(V, proto::detail::make_mutable<T>()) ->* proto::detail::make<U>()$/;"	p	class:boost::proto::detail::get_pointerns::mem_ptr_fun::proto::detail	access:public	signature:()
boost::proto::detail::get_pointerns::mem_ptr_fun::proto::detail::make	/usr/include/boost/proto/detail/decltype.hpp	/^                    proto::detail::make_mutable<T>() ->* proto::detail::make<U>()$/;"	p	class:boost::proto::detail::get_pointerns::mem_ptr_fun::proto::detail	access:public	signature:()
boost::proto::detail::get_pointerns::mem_ptr_fun::V	/usr/include/boost/proto/detail/decltype.hpp	/^                V;$/;"	t	struct:boost::proto::detail::get_pointerns::mem_ptr_fun	access:public
boost::proto::detail::get_pointerns::result_of_	/usr/include/boost/proto/detail/decltype.hpp	/^            struct result_of_$/;"	s	namespace:boost::proto::detail::get_pointerns	inherits:boost::result_of
boost::proto::detail::get_pointerns::result_of_	/usr/include/boost/proto/detail/decltype.hpp	/^            struct result_of_<T U::*(V), typename enable_if_c<is_member_object_pointer<T U::*>::value>::type>$/;"	s	namespace:boost::proto::detail::get_pointerns
boost::proto::detail::get_pointerns::result_of_::BOOST_STATIC_CONSTANT	/usr/include/boost/proto/detail/decltype.hpp	/^                BOOST_STATIC_CONSTANT(bool, is_ptr_to_const = 2 == sizeof(test_ptr_to_const(BOOST_PROTO_GET_POINTER(U, make<V>()))));$/;"	p	struct:boost::proto::detail::get_pointerns::result_of_	access:public	signature:(bool, is_ptr_to_const = 2 == sizeof(test_ptr_to_const(BOOST_PROTO_GET_POINTER(U, make<V>()))))
boost::proto::detail::get_pointerns::result_of_::BOOST_STATIC_CONSTANT	/usr/include/boost/proto/detail/decltype.hpp	/^                BOOST_STATIC_CONSTANT(bool, is_V_a_smart_ptr = 2 == sizeof(test_V_is_a_U<U>(&lvalue(make<V>()))));$/;"	p	struct:boost::proto::detail::get_pointerns::result_of_	access:public	signature:(bool, is_V_a_smart_ptr = 2 == sizeof(test_V_is_a_U<U>(&lvalue(make<V>()))))
boost::proto::detail::get_pointerns::result_of_::type	/usr/include/boost/proto/detail/decltype.hpp	/^                type;$/;"	t	struct:boost::proto::detail::get_pointerns::result_of_	access:public
boost::proto::detail::get_pointerns::test_ptr_to_const	/usr/include/boost/proto/detail/decltype.hpp	/^            char (&test_ptr_to_const(void const *))[2];$/;"	p	namespace:boost::proto::detail::get_pointerns	signature:(void const *)
boost::proto::detail::get_pointerns::test_ptr_to_const	/usr/include/boost/proto/detail/decltype.hpp	/^            char test_ptr_to_const(void *);$/;"	p	namespace:boost::proto::detail::get_pointerns	signature:(void *)
boost::proto::detail::get_pointerns::test_V_is_a_U	/usr/include/boost/proto/detail/decltype.hpp	/^            template<typename U> char (&test_V_is_a_U(...))[2];$/;"	p	namespace:boost::proto::detail::get_pointerns	signature:(....)
boost::proto::detail::get_pointerns::test_V_is_a_U	/usr/include/boost/proto/detail/decltype.hpp	/^            template<typename U> char test_V_is_a_U(U *);$/;"	p	namespace:boost::proto::detail::get_pointerns	signature:(U *)
boost::proto::detail::get_pointerns::test_V_is_a_U	/usr/include/boost/proto/detail/decltype.hpp	/^            template<typename U> char test_V_is_a_U(U const *);$/;"	p	namespace:boost::proto::detail::get_pointerns	signature:(U const *)
boost::proto::detail::has_get_pointerns	/usr/include/boost/proto/detail/decltype.hpp	/^        namespace has_get_pointerns$/;"	n	namespace:boost::proto::detail
boost::proto::detail::has_get_pointerns::get_pointer	/usr/include/boost/proto/detail/decltype.hpp	/^            void *(&get_pointer(...))[2];$/;"	p	namespace:boost::proto::detail::has_get_pointerns	signature:(....)
boost::proto::detail::has_get_pointerns::has_get_pointer	/usr/include/boost/proto/detail/decltype.hpp	/^            struct has_get_pointer$/;"	s	namespace:boost::proto::detail::has_get_pointerns
boost::proto::detail::has_get_pointerns::has_get_pointer::BOOST_STATIC_CONSTANT	/usr/include/boost/proto/detail/decltype.hpp	/^                BOOST_STATIC_CONSTANT(bool, value = sizeof(void *) == sizeof(get_pointer(make<T &>())));$/;"	p	struct:boost::proto::detail::has_get_pointerns::has_get_pointer	access:public	signature:(bool, value = sizeof(void *) == sizeof(get_pointer(make<T &>())))
boost::proto::detail::has_get_pointerns::has_get_pointer::type	/usr/include/boost/proto/detail/decltype.hpp	/^                typedef mpl::bool_<value> type;$/;"	t	struct:boost::proto::detail::has_get_pointerns::has_get_pointer	access:public
boost::proto::detail::has_tag	/usr/include/boost/proto/transform/fold_tree.hpp	/^        struct has_tag : transform<has_tag<Tag> >$/;"	s	namespace:boost::proto::detail	inherits:transform
boost::proto::detail::has_tag::impl	/usr/include/boost/proto/transform/fold_tree.hpp	/^            struct impl$/;"	s	struct:boost::proto::detail::has_tag	inherits:transform_impl	access:public
boost::proto::detail::has_tag::impl	/usr/include/boost/proto/transform/fold_tree.hpp	/^            struct impl<Expr &, State, Data, typename Expr::proto_tag>$/;"	s	struct:boost::proto::detail::has_tag	inherits:transform_impl	access:public
boost::proto::detail::has_tag::impl	/usr/include/boost/proto/transform/fold_tree.hpp	/^            struct impl<Expr, State, Data, typename Expr::proto_tag>$/;"	s	struct:boost::proto::detail::has_tag	inherits:transform_impl	access:public
boost::proto::detail::has_tag::impl::result_type	/usr/include/boost/proto/transform/fold_tree.hpp	/^                typedef mpl::false_ result_type;$/;"	t	struct:boost::proto::detail::has_tag::impl	access:public
boost::proto::detail::has_tag::impl::result_type	/usr/include/boost/proto/transform/fold_tree.hpp	/^                typedef mpl::true_ result_type;$/;"	t	struct:boost::proto::detail::has_tag::impl	access:public
boost::proto::detail::if_vararg	/usr/include/boost/proto/traits.hpp	/^            struct if_vararg$/;"	s	namespace:boost::proto::detail
boost::proto::detail::if_vararg	/usr/include/boost/proto/traits.hpp	/^            struct if_vararg<T, typename T::proto_is_vararg_>$/;"	s	namespace:boost::proto::detail	inherits:T
boost::proto::detail::ignore	/usr/include/boost/proto/proto_fwd.hpp	/^        struct ignore$/;"	s	namespace:boost::proto::detail
boost::proto::detail::ignore	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef detail::ignore const ignore;$/;"	t	class:boost::proto::detail
boost::proto::detail::ignore::ignore	/usr/include/boost/proto/proto_fwd.hpp	/^            ignore()$/;"	f	struct:boost::proto::detail::ignore	access:public	signature:()
boost::proto::detail::ignore::ignore	/usr/include/boost/proto/proto_fwd.hpp	/^            ignore(T const &)$/;"	f	struct:boost::proto::detail::ignore	access:public	signature:(T const &)
boost::proto::detail::ignore_unused	/usr/include/boost/proto/detail/ignore_unused.hpp	/^        inline void ignore_unused(T const &)$/;"	f	namespace:boost::proto::detail	signature:(T const &)
boost::proto::detail::implicit_expr	/usr/include/boost/proto/make_expr.hpp	/^        implicit_expr(A0 &a0)$/;"	f	class:boost::proto::detail	signature:(A0 &a0)
boost::proto::detail::implicit_expr_1	/usr/include/boost/proto/make_expr.hpp	/^            struct implicit_expr_1$/;"	s	namespace:boost::proto::detail
boost::proto::detail::implicit_expr_1	/usr/include/boost/proto/make_expr.hpp	/^            struct implicit_expr_1<A0, typename A0::proto_is_expr_>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::implicit_expr_1::a0	/usr/include/boost/proto/make_expr.hpp	/^                A0 &a0;$/;"	m	struct:boost::proto::detail::implicit_expr_1	access:public
boost::proto::detail::implicit_expr_1::operator A0 &	/usr/include/boost/proto/make_expr.hpp	/^                operator A0 &() const$/;"	f	struct:boost::proto::detail::implicit_expr_1	access:public	signature:() const
boost::proto::detail::implicit_expr_1::operator Expr	/usr/include/boost/proto/make_expr.hpp	/^                operator Expr() const$/;"	f	struct:boost::proto::detail::implicit_expr_1	access:public	signature:() const
boost::proto::detail::implicit_expr_1::operator proto::expr<Tag, Args, 1>	/usr/include/boost/proto/make_expr.hpp	/^                operator proto::expr<Tag, Args, 1>() const$/;"	f	struct:boost::proto::detail::implicit_expr_1	access:public	signature:() const
boost::proto::detail::implicit_expr_1::operator proto::expr<tag::terminal, Args, 0>	/usr/include/boost/proto/make_expr.hpp	/^                operator proto::expr<tag::terminal, Args, 0>() const$/;"	f	struct:boost::proto::detail::implicit_expr_1	access:public	signature:() const
boost::proto::detail::implicit_expr_1::operator uncv_a0_type &	/usr/include/boost/proto/make_expr.hpp	/^                operator uncv_a0_type &() const$/;"	f	struct:boost::proto::detail::implicit_expr_1	access:public	signature:() const
boost::proto::detail::implicit_expr_1::uncv_a0_type	/usr/include/boost/proto/make_expr.hpp	/^                typedef typename remove_cv<A0>::type uncv_a0_type;$/;"	t	struct:boost::proto::detail::implicit_expr_1	access:public
boost::proto::detail::implicit_expr_wrap	/usr/include/boost/proto/make_expr.hpp	/^            Expr implicit_expr_wrap(Base const &e, mpl::false_, Expr *)$/;"	f	namespace:boost::proto::detail	signature:(Base const &e, mpl::false_, Expr *)
boost::proto::detail::implicit_expr_wrap	/usr/include/boost/proto/make_expr.hpp	/^            Expr implicit_expr_wrap(Base const &e, mpl::true_, Expr *)$/;"	f	namespace:boost::proto::detail	signature:(Base const &e, mpl::true_, Expr *)
boost::proto::detail::is_callable2_	/usr/include/boost/proto/traits.hpp	/^            struct is_callable2_$/;"	s	namespace:boost::proto::detail	inherits:mpl::false_
boost::proto::detail::is_callable2_	/usr/include/boost/proto/traits.hpp	/^            struct is_callable2_<T, typename T::proto_is_callable_>$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
boost::proto::detail::is_callable_	/usr/include/boost/proto/traits.hpp	/^            struct is_callable_$/;"	s	namespace:boost::proto::detail	inherits:is_callable2_
boost::proto::detail::is_cv_ref_compatible	/usr/include/boost/proto/matches.hpp	/^            struct is_cv_ref_compatible$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
boost::proto::detail::is_cv_ref_compatible	/usr/include/boost/proto/matches.hpp	/^            struct is_cv_ref_compatible<T &, U &>$/;"	s	namespace:boost::proto::detail	inherits:mpl::bool_
boost::proto::detail::is_cv_ref_compatible	/usr/include/boost/proto/matches.hpp	/^            struct is_cv_ref_compatible<T, U &>$/;"	s	namespace:boost::proto::detail	inherits:mpl::false_
boost::proto::detail::is_expr_handled	/usr/include/boost/proto/context/callable.hpp	/^            struct is_expr_handled<Expr, Context, 0>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::is_expr_handled::BOOST_STATIC_CONSTANT	/usr/include/boost/proto/context/callable.hpp	/^                BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::proto::detail::is_expr_handled	access:public	signature:(bool, value = ( sizeof(yes_type) == sizeof( detail::check_is_expr_handled( (sctx_(stag_, proto::value(sexpr_)), 0) ) )))
boost::proto::detail::is_expr_handled::sctx_	/usr/include/boost/proto/context/callable.hpp	/^                static callable_context_wrapper<Context> &sctx_;$/;"	m	struct:boost::proto::detail::is_expr_handled	access:public
boost::proto::detail::is_expr_handled::sexpr_	/usr/include/boost/proto/context/callable.hpp	/^                static Expr &sexpr_;$/;"	m	struct:boost::proto::detail::is_expr_handled	access:public
boost::proto::detail::is_expr_handled::stag_	/usr/include/boost/proto/context/callable.hpp	/^                static typename Expr::proto_tag &stag_;$/;"	m	struct:boost::proto::detail::is_expr_handled	access:public
boost::proto::detail::is_expr_handled::type	/usr/include/boost/proto/context/callable.hpp	/^                typedef mpl::bool_<value> type;$/;"	t	struct:boost::proto::detail::is_expr_handled	access:public
boost::proto::detail::is_poly_function	/usr/include/boost/proto/detail/poly_function.hpp	/^        struct is_poly_function$/;"	s	namespace:boost::proto::detail	inherits:mpl::false_
boost::proto::detail::is_poly_function	/usr/include/boost/proto/detail/poly_function.hpp	/^        struct is_poly_function<T, typename T::is_poly_function_base_>$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
boost::proto::detail::lambda_matches	/usr/include/boost/proto/matches.hpp	/^            struct lambda_matches$/;"	s	namespace:boost::proto::detail	inherits:mpl::false_
boost::proto::detail::lambda_matches	/usr/include/boost/proto/matches.hpp	/^            struct lambda_matches<T, proto::_ BOOST_MPL_AUX_LAMBDA_ARITY_PARAM(-1)>$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
boost::proto::detail::lambda_matches	/usr/include/boost/proto/matches.hpp	/^            struct lambda_matches<T, T BOOST_MPL_AUX_LAMBDA_ARITY_PARAM(-1)>$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
boost::proto::detail::lambda_matches	/usr/include/boost/proto/matches.hpp	/^            struct lambda_matches<T<Expr0>, T<Grammar0> BOOST_MPL_AUX_LAMBDA_ARITY_PARAM(1) >$/;"	s	namespace:boost::proto::detail	inherits:lambda_matches
boost::proto::detail::lambda_matches	/usr/include/boost/proto/matches.hpp	/^            struct lambda_matches<T[M], T[M] BOOST_MPL_AUX_LAMBDA_ARITY_PARAM(-1)>$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
boost::proto::detail::lambda_matches	/usr/include/boost/proto/matches.hpp	/^            struct lambda_matches<T[M], U BOOST_MPL_AUX_LAMBDA_ARITY_PARAM(-1)>$/;"	s	namespace:boost::proto::detail	inherits:array_matches
boost::proto::detail::last	/usr/include/boost/proto/matches.hpp	/^            struct last<proto::and_<> >$/;"	s	namespace:boost::proto::detail
boost::proto::detail::last	/usr/include/boost/proto/matches.hpp	/^            struct last<proto::and_<G0> >$/;"	s	namespace:boost::proto::detail
boost::proto::detail::last::type	/usr/include/boost/proto/matches.hpp	/^                typedef G0 type;$/;"	t	struct:boost::proto::detail::last	access:public
boost::proto::detail::last::type	/usr/include/boost/proto/matches.hpp	/^                typedef proto::_ type;$/;"	t	struct:boost::proto::detail::last	access:public
boost::proto::detail::lvalue	/usr/include/boost/proto/detail/decltype.hpp	/^        T &lvalue(T &t)$/;"	f	namespace:boost::proto::detail	signature:(T &t)
boost::proto::detail::lvalue	/usr/include/boost/proto/detail/decltype.hpp	/^        T const &lvalue(T const &t)$/;"	f	namespace:boost::proto::detail	signature:(T const &t)
boost::proto::detail::make	/usr/include/boost/proto/detail/decltype.hpp	/^        T make();$/;"	p	namespace:boost::proto::detail	signature:()
boost::proto::detail::make_	/usr/include/boost/proto/transform/make.hpp	/^            struct make_$/;"	s	namespace:boost::proto::detail
boost::proto::detail::make_::not_applied_	/usr/include/boost/proto/transform/make.hpp	/^                typedef void not_applied_;$/;"	t	struct:boost::proto::detail::make_	access:public
boost::proto::detail::make_::type	/usr/include/boost/proto/transform/make.hpp	/^                typedef R type;$/;"	t	struct:boost::proto::detail::make_	access:public
boost::proto::detail::make_expr_	/usr/include/boost/proto/make_expr.hpp	/^            struct make_expr_$/;"	s	namespace:boost::proto::detail
boost::proto::detail::make_expr_	/usr/include/boost/proto/make_expr.hpp	/^            struct make_expr_<tag::terminal, deduce_domain, A$/;"	s	namespace:boost::proto::detail	inherits:make_expr_
boost::proto::detail::make_expr_	/usr/include/boost/proto/make_expr.hpp	/^            struct make_expr_<tag::terminal, Domain, A$/;"	s	namespace:boost::proto::detail
boost::proto::detail::make_expr_::operator ()	/usr/include/boost/proto/make_expr.hpp	/^                result_type operator()(typename add_reference<A>::type a) const$/;"	f	struct:boost::proto::detail::make_expr_	access:public	signature:(typename add_reference<A>::type a) const
boost::proto::detail::make_expr_::result_type	/usr/include/boost/proto/make_expr.hpp	/^                typedef typename proto::detail::protoify_<A, Domain>::type result_type;$/;"	t	struct:boost::proto::detail::make_expr_	access:public
boost::proto::detail::make_if_	/usr/include/boost/proto/transform/make.hpp	/^            struct make_if_<proto::expr<Tag, Args, N>, Expr, State, Data, false>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::make_if_	/usr/include/boost/proto/transform/make.hpp	/^            struct make_if_<R, Expr, State, Data, false>$/;"	s	namespace:boost::proto::detail	inherits:make_
boost::proto::detail::make_if_	/usr/include/boost/proto/transform/make.hpp	/^            struct make_if_<R, Expr, State, Data, true>$/;"	s	namespace:boost::proto::detail	inherits:remove_const
boost::proto::detail::make_if_::not_applied_	/usr/include/boost/proto/transform/make.hpp	/^                typedef void not_applied_;$/;"	t	struct:boost::proto::detail::make_if_	access:public
boost::proto::detail::make_if_::type	/usr/include/boost/proto/transform/make.hpp	/^                typedef proto::expr<Tag, Args, N> type;$/;"	t	struct:boost::proto::detail::make_if_	access:public
boost::proto::detail::make_mutable	/usr/include/boost/proto/detail/decltype.hpp	/^        typename as_mutable<T>::type make_mutable();$/;"	p	namespace:boost::proto::detail	signature:()
boost::proto::detail::make_subscriptable	/usr/include/boost/proto/detail/decltype.hpp	/^        typename as_subscriptable<T>::type make_subscriptable();$/;"	p	namespace:boost::proto::detail	signature:()
boost::proto::detail::make_terminal	/usr/include/boost/proto/expr.hpp	/^            proto::expr<Tag, proto::term<Arg0>, 0> make_terminal(T &t, proto::expr<Tag, proto::term<Arg0>, 0> *)$/;"	f	namespace:boost::proto::detail	signature:(T &t, proto::expr<Tag, proto::term<Arg0>, 0> *)
boost::proto::detail::make_terminal	/usr/include/boost/proto/expr.hpp	/^            proto::expr<Tag, proto::term<Arg0[N]>, 0> make_terminal(T const(&t)[N], proto::expr<Tag, proto::term<Arg0[N]>, 0> *)$/;"	f	namespace:boost::proto::detail	signature:(T const(&t)[N], proto::expr<Tag, proto::term<Arg0[N]>, 0> *)
boost::proto::detail::matches_	/usr/include/boost/proto/matches.hpp	/^            struct matches_$/;"	s	namespace:boost::proto::detail	inherits:mpl::false_
boost::proto::detail::matches_	/usr/include/boost/proto/matches.hpp	/^            struct matches_< Expr, proto::_ >$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
boost::proto::detail::matches_	/usr/include/boost/proto/matches.hpp	/^            struct matches_< proto::expr<Tag, Args1, 0>, proto::expr<proto::_, Args2, 0> >$/;"	s	namespace:boost::proto::detail	inherits:terminal_matches
boost::proto::detail::matches_	/usr/include/boost/proto/matches.hpp	/^            struct matches_< proto::expr<Tag, Args1, 0>, proto::expr<proto::_, Args2, N2> >$/;"	s	namespace:boost::proto::detail	inherits:mpl::false_
boost::proto::detail::matches_	/usr/include/boost/proto/matches.hpp	/^            struct matches_< proto::expr<Tag, Args1, 0>, proto::expr<Tag, Args2, 0> >$/;"	s	namespace:boost::proto::detail	inherits:terminal_matches
boost::proto::detail::matches_	/usr/include/boost/proto/matches.hpp	/^            struct matches_< proto::expr<Tag, Args1, 1>, proto::expr<proto::_, Args2, 1> >$/;"	s	namespace:boost::proto::detail	inherits:matches_
boost::proto::detail::matches_	/usr/include/boost/proto/matches.hpp	/^            struct matches_< proto::expr<Tag, Args1, 1>, proto::expr<Tag, Args2, 1> >$/;"	s	namespace:boost::proto::detail	inherits:matches_
boost::proto::detail::matches_	/usr/include/boost/proto/matches.hpp	/^            struct matches_< proto::expr<Tag, Args1, N1>, proto::expr<proto::_, Args2, N2> >$/;"	s	namespace:boost::proto::detail	inherits:vararg_matchesN2,N2,N1
boost::proto::detail::matches_	/usr/include/boost/proto/matches.hpp	/^            struct matches_< proto::expr<Tag, Args1, N1>, proto::expr<Tag, Args2, N2> >$/;"	s	namespace:boost::proto::detail	inherits:vararg_matchesN2,N2,N1
boost::proto::detail::matches_	/usr/include/boost/proto/matches.hpp	/^            struct matches_<Expr, and_<> >$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
boost::proto::detail::matches_	/usr/include/boost/proto/matches.hpp	/^            struct matches_<Expr, and_<G0> >$/;"	s	namespace:boost::proto::detail	inherits:matches_
boost::proto::detail::matches_	/usr/include/boost/proto/matches.hpp	/^            struct matches_<Expr, not_<Grammar> >$/;"	s	namespace:boost::proto::detail	inherits:mpl::not_
boost::proto::detail::matches_	/usr/include/boost/proto/matches.hpp	/^            struct matches_<Expr, or_<> >$/;"	s	namespace:boost::proto::detail	inherits:mpl::false_
boost::proto::detail::matches_	/usr/include/boost/proto/matches.hpp	/^            struct matches_<Expr, or_<G0> >$/;"	s	namespace:boost::proto::detail	inherits:matches_
boost::proto::detail::matches_	/usr/include/boost/proto/matches.hpp	/^            struct matches_<Expr, proto::if_<If, Then, Else> >$/;"	s	namespace:boost::proto::detail	inherits:mpl::eval_if_c::type
boost::proto::detail::matches_	/usr/include/boost/proto/matches.hpp	/^            struct matches_<Expr, proto::if_<If> >$/;"	s	namespace:boost::proto::detail	inherits:detail::uncvref::type
boost::proto::detail::matches_	/usr/include/boost/proto/matches.hpp	/^            struct matches_<Expr, switch_<Cases> >$/;"	s	namespace:boost::proto::detail	inherits:matches_
boost::proto::detail::matches_::which	/usr/include/boost/proto/matches.hpp	/^                typedef G0 which;$/;"	t	struct:boost::proto::detail::matches_	access:public
boost::proto::detail::matches_::which	/usr/include/boost/proto/matches.hpp	/^                typedef not_<_> which;$/;"	t	struct:boost::proto::detail::matches_	access:public
boost::proto::detail::memfun	/usr/include/boost/proto/detail/decltype.hpp	/^        struct memfun$/;"	s	namespace:boost::proto::detail
boost::proto::detail::memfun::memfun	/usr/include/boost/proto/detail/decltype.hpp	/^            memfun(T t, PMF p)$/;"	f	struct:boost::proto::detail::memfun	access:public	signature:(T t, PMF p)
boost::proto::detail::memfun::obj	/usr/include/boost/proto/detail/decltype.hpp	/^            T obj;$/;"	m	struct:boost::proto::detail::memfun	access:private
boost::proto::detail::memfun::operator ()	/usr/include/boost/proto/detail/decltype.hpp	/^            result_type operator()() const$/;"	f	struct:boost::proto::detail::memfun	access:public	signature:() const
boost::proto::detail::memfun::pmf	/usr/include/boost/proto/detail/decltype.hpp	/^            PMF pmf;$/;"	m	struct:boost::proto::detail::memfun	access:private
boost::proto::detail::memfun::pmf_type	/usr/include/boost/proto/detail/decltype.hpp	/^            typedef typename remove_const<typename remove_reference<PMF>::type>::type pmf_type;$/;"	t	struct:boost::proto::detail::memfun	access:public
boost::proto::detail::memfun::result_type	/usr/include/boost/proto/detail/decltype.hpp	/^            typedef typename boost::result_of<pmf_type(T)>::type result_type;$/;"	t	struct:boost::proto::detail::memfun	access:public
boost::proto::detail::memfun::V	/usr/include/boost/proto/detail/decltype.hpp	/^            typedef typename classtypeof<pmf_type>::type V;$/;"	t	struct:boost::proto::detail::memfun	access:public
boost::proto::detail::mono_function_t	/usr/include/boost/proto/detail/poly_function.hpp	/^        typedef char (&mono_function_t)[2];$/;"	t	namespace:boost::proto::detail
boost::proto::detail::nested_type	/usr/include/boost/proto/transform/make.hpp	/^            struct nested_type$/;"	s	namespace:boost::proto::detail
boost::proto::detail::nested_type	/usr/include/boost/proto/transform/make.hpp	/^            struct nested_type<T, false>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::nested_type::type	/usr/include/boost/proto/transform/make.hpp	/^                typedef T type;$/;"	t	struct:boost::proto::detail::nested_type	access:public
boost::proto::detail::nested_type::type	/usr/include/boost/proto/transform/make.hpp	/^                typedef typename T::type type;$/;"	t	struct:boost::proto::detail::nested_type	access:public
boost::proto::detail::nested_type_if	/usr/include/boost/proto/transform/make.hpp	/^            struct nested_type_if$/;"	s	namespace:boost::proto::detail	inherits:nested_type
boost::proto::detail::nondeduced_domain	/usr/include/boost/proto/make_expr.hpp	/^            struct nondeduced_domain$/;"	s	namespace:boost::proto::detail
boost::proto::detail::nondeduced_domain	/usr/include/boost/proto/make_expr.hpp	/^            struct nondeduced_domain<default_domain>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::nondeduced_domain::nondeduced_domain	/usr/include/boost/proto/make_expr.hpp	/^                nondeduced_domain(default_domain);$/;"	p	struct:boost::proto::detail::nondeduced_domain	access:public	signature:(default_domain)
boost::proto::detail::nondeduced_domain::nondeduced_domain	/usr/include/boost/proto/make_expr.hpp	/^                nondeduced_domain(T);$/;"	p	struct:boost::proto::detail::nondeduced_domain	access:public	signature:(T)
boost::proto::detail::nondeduced_domain::type	/usr/include/boost/proto/make_expr.hpp	/^                typedef nondeduced_domain type;$/;"	t	struct:boost::proto::detail::nondeduced_domain	access:public
boost::proto::detail::normalize_arg	/usr/include/boost/proto/detail/poly_function.hpp	/^        struct normalize_arg$/;"	s	namespace:boost::proto::detail
boost::proto::detail::normalize_arg	/usr/include/boost/proto/detail/poly_function.hpp	/^        struct normalize_arg<boost::reference_wrapper<T> &>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::normalize_arg	/usr/include/boost/proto/detail/poly_function.hpp	/^        struct normalize_arg<boost::reference_wrapper<T> >$/;"	s	namespace:boost::proto::detail
boost::proto::detail::normalize_arg	/usr/include/boost/proto/detail/poly_function.hpp	/^        struct normalize_arg<boost::reference_wrapper<T> const &>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::normalize_arg	/usr/include/boost/proto/detail/poly_function.hpp	/^        struct normalize_arg<T &>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::normalize_arg	/usr/include/boost/proto/detail/poly_function.hpp	/^        struct normalize_arg<T const &>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::normalize_arg::reference	/usr/include/boost/proto/detail/poly_function.hpp	/^            typedef T &reference;$/;"	t	struct:boost::proto::detail::normalize_arg	access:public
boost::proto::detail::normalize_arg::reference	/usr/include/boost/proto/detail/poly_function.hpp	/^            typedef T const &reference;$/;"	t	struct:boost::proto::detail::normalize_arg	access:public
boost::proto::detail::normalize_arg::type	/usr/include/boost/proto/detail/poly_function.hpp	/^            typedef T &type;$/;"	t	struct:boost::proto::detail::normalize_arg	access:public
boost::proto::detail::normalize_arg::type	/usr/include/boost/proto/detail/poly_function.hpp	/^            typedef T type;$/;"	t	struct:boost::proto::detail::normalize_arg	access:public
boost::proto::detail::not_a_generator	/usr/include/boost/proto/domain.hpp	/^        struct not_a_generator$/;"	s	namespace:boost::proto::detail
boost::proto::detail::not_a_grammar	/usr/include/boost/proto/domain.hpp	/^        struct not_a_grammar$/;"	s	namespace:boost::proto::detail
boost::proto::detail::not_a_valid_type	/usr/include/boost/proto/expr.hpp	/^            struct not_a_valid_type$/;"	s	namespace:boost::proto::detail
boost::proto::detail::not_a_valid_type::not_a_valid_type	/usr/include/boost/proto/expr.hpp	/^                not_a_valid_type()$/;"	f	struct:boost::proto::detail::not_a_valid_type	access:private	signature:()
boost::proto::detail::no_type	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef char (&no_type)[2];$/;"	t	namespace:boost::proto::detail
boost::proto::detail::pass_through_impl	/usr/include/boost/proto/transform/pass_through.hpp	/^            struct pass_through_impl$/;"	s	namespace:boost::proto::detail
boost::proto::detail::pass_through_impl	/usr/include/boost/proto/transform/pass_through.hpp	/^            struct pass_through_impl<Grammar, Expr, State, Data, 0>$/;"	s	namespace:boost::proto::detail	inherits:transform_impl
boost::proto::detail::pass_through_impl::operator ()	/usr/include/boost/proto/transform/pass_through.hpp	/^                operator()($/;"	f	struct:boost::proto::detail::pass_through_impl	access:public	signature:( typename pass_through_impl::expr_param e , typename pass_through_impl::state_param , typename pass_through_impl::data_param ) const
boost::proto::detail::pass_through_impl::result_type	/usr/include/boost/proto/transform/pass_through.hpp	/^                typedef Expr result_type;$/;"	t	struct:boost::proto::detail::pass_through_impl	access:public
boost::proto::detail::poly_function	/usr/include/boost/proto/detail/poly_function.hpp	/^        struct poly_function$/;"	s	namespace:boost::proto::detail	inherits:poly_function_base
boost::proto::detail::poly_function::operator ()	/usr/include/boost/proto/detail/poly_function.hpp	/^            NullaryResult operator()() const$/;"	f	struct:boost::proto::detail::poly_function	access:public	signature:() const
boost::proto::detail::poly_function::result	/usr/include/boost/proto/detail/poly_function.hpp	/^            struct result<This()>$/;"	s	struct:boost::proto::detail::poly_function	inherits:Derived::,impl	access:public
boost::proto::detail::poly_function::result::type	/usr/include/boost/proto/detail/poly_function.hpp	/^                typedef typename result::result_type type;$/;"	t	struct:boost::proto::detail::poly_function::result	access:public
boost::proto::detail::poly_function_base	/usr/include/boost/proto/detail/poly_function.hpp	/^        struct poly_function_base$/;"	s	namespace:boost::proto::detail
boost::proto::detail::poly_function_t	/usr/include/boost/proto/detail/poly_function.hpp	/^        typedef char poly_function_t;$/;"	t	namespace:boost::proto::detail
boost::proto::detail::poly_function_traits	/usr/include/boost/proto/detail/poly_function.hpp	/^        struct poly_function_traits$/;"	s	namespace:boost::proto::detail
boost::proto::detail::poly_function_traits	/usr/include/boost/proto/detail/poly_function.hpp	/^        struct poly_function_traits<Fun, Sig, sizeof(mono_function_t)>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::poly_function_traits::function_type	/usr/include/boost/proto/detail/poly_function.hpp	/^            typedef Fun function_type;$/;"	t	struct:boost::proto::detail::poly_function_traits	access:public
boost::proto::detail::poly_function_traits::result_type	/usr/include/boost/proto/detail/poly_function.hpp	/^            typedef typename Fun::result_type result_type;$/;"	t	struct:boost::proto::detail::poly_function_traits	access:public
boost::proto::detail::poly_function_traits::result_type	/usr/include/boost/proto/detail/poly_function.hpp	/^            typedef typename Fun::template result<Sig>::type result_type;$/;"	t	struct:boost::proto::detail::poly_function_traits	access:public
boost::proto::detail::private_type_	/usr/include/boost/proto/proto_fwd.hpp	/^        struct private_type_$/;"	s	namespace:boost::proto::detail
boost::proto::detail::private_type_::operator ,	/usr/include/boost/proto/proto_fwd.hpp	/^            private_type_ operator ,(int) const;$/;"	p	struct:boost::proto::detail::private_type_	access:public	signature:(int) const
boost::proto::detail::protoify_	/usr/include/boost/proto/make_expr.hpp	/^            struct protoify_$/;"	s	namespace:boost::proto::detail
boost::proto::detail::protoify_	/usr/include/boost/proto/make_expr.hpp	/^            struct protoify_<T &, Domain>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::protoify_::call	/usr/include/boost/proto/make_expr.hpp	/^                static type call(T &t)$/;"	f	struct:boost::proto::detail::protoify_	access:public	signature:(T &t)
boost::proto::detail::protoify_::type	/usr/include/boost/proto/make_expr.hpp	/^                type;$/;"	t	struct:boost::proto::detail::protoify_	access:public
boost::proto::detail::protoify_::unref_type	/usr/include/boost/proto/make_expr.hpp	/^                unref_type;$/;"	t	struct:boost::proto::detail::protoify_	access:public
boost::proto::detail::proto_get_pointer	/usr/include/boost/proto/detail/decltype.hpp	/^        U *proto_get_pointer(T &t, V *, U *)$/;"	f	namespace:boost::proto::detail	signature:(T &t, V *, U *)
boost::proto::detail::proto_get_pointer	/usr/include/boost/proto/detail/decltype.hpp	/^        U const *proto_get_pointer(T &t, V *, U const *)$/;"	f	namespace:boost::proto::detail	signature:(T &t, V *, U const *)
boost::proto::detail::proto_get_pointer	/usr/include/boost/proto/detail/decltype.hpp	/^        V *proto_get_pointer(T &t, V *, ...)$/;"	f	namespace:boost::proto::detail	signature:(T &t, V *, ...)
boost::proto::detail::result_of_fixup	/usr/include/boost/proto/detail/decltype.hpp	/^        struct result_of_fixup$/;"	s	namespace:boost::proto::detail	inherits:mpl::if_c
boost::proto::detail::result_of_fixup	/usr/include/boost/proto/detail/decltype.hpp	/^        struct result_of_fixup<R T::*, U>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::result_of_fixup	/usr/include/boost/proto/detail/decltype.hpp	/^        struct result_of_fixup<T &, U>$/;"	s	namespace:boost::proto::detail	inherits:result_of_fixup
boost::proto::detail::result_of_fixup	/usr/include/boost/proto/detail/decltype.hpp	/^        struct result_of_fixup<T *, U>$/;"	s	namespace:boost::proto::detail	inherits:result_of_fixup
boost::proto::detail::result_of_fixup	/usr/include/boost/proto/detail/decltype.hpp	/^        struct result_of_fixup<T const &, U>$/;"	s	namespace:boost::proto::detail	inherits:result_of_fixup
boost::proto::detail::result_of_fixup	/usr/include/boost/proto/detail/decltype.hpp	/^        struct result_of_fixup<T const, U>$/;"	s	namespace:boost::proto::detail	inherits:result_of_fixup
boost::proto::detail::result_of_fixup::T::type	/usr/include/boost/proto/detail/decltype.hpp	/^            typedef R T::*type;$/;"	t	class:boost::proto::detail::result_of_fixup::T	access:public
boost::proto::detail::reverse_fold_impl	/usr/include/boost/proto/transform/fold.hpp	/^            struct reverse_fold_impl$/;"	s	namespace:boost::proto::detail
boost::proto::detail::reverse_fold_tree_	/usr/include/boost/proto/transform/fold_tree.hpp	/^        struct reverse_fold_tree_$/;"	s	namespace:boost::proto::detail	inherits:if_
boost::proto::detail::same_cv	/usr/include/boost/proto/expr.hpp	/^            struct same_cv$/;"	s	namespace:boost::proto::detail
boost::proto::detail::same_cv	/usr/include/boost/proto/expr.hpp	/^            struct same_cv<T const, U>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::same_cv::type	/usr/include/boost/proto/expr.hpp	/^                typedef U const type;$/;"	t	struct:boost::proto::detail::same_cv	access:public
boost::proto::detail::same_cv::type	/usr/include/boost/proto/expr.hpp	/^                typedef U type;$/;"	t	struct:boost::proto::detail::same_cv	access:public
boost::proto::detail::select_nth	/usr/include/boost/proto/make_expr.hpp	/^            struct select_nth$/;"	s	namespace:boost::proto::detail
boost::proto::detail::select_nth::BOOST_MPL_ASSERT_MSG	/usr/include/boost/proto/make_expr.hpp	/^                BOOST_MPL_ASSERT_MSG((false), PROTO_DOMAIN_MISMATCH, (select_nth));$/;"	p	struct:boost::proto::detail::select_nth	access:public	signature:(false), PROTO_DOMAIN_MISMATCH, (select_nth)
boost::proto::detail::select_nth::type	/usr/include/boost/proto/make_expr.hpp	/^                typedef default_domain type;$/;"	t	struct:boost::proto::detail::select_nth	access:public
boost::proto::detail::sized	/usr/include/boost/proto/make_expr.hpp	/^            struct sized$/;"	s	namespace:boost::proto::detail
boost::proto::detail::sized::buffer	/usr/include/boost/proto/make_expr.hpp	/^                char buffer[I];$/;"	m	struct:boost::proto::detail::sized	access:public
boost::proto::detail::subscript_wrapper	/usr/include/boost/proto/detail/decltype.hpp	/^        struct subscript_wrapper$/;"	s	namespace:boost::proto::detail	inherits:T
boost::proto::detail::T	/usr/include/boost/proto/expr.hpp	/^            proto::expr<Tag, proto::term<Arg0[N]>, 0> make_terminal(T (&t)[N], proto::expr<Tag, proto::term<Arg0[N]>, 0> *)$/;"	m	namespace:boost::proto::detail
boost::proto::detail::terminal_array_matches	/usr/include/boost/proto/matches.hpp	/^            struct terminal_array_matches$/;"	s	namespace:boost::proto::detail	inherits:mpl::false_
boost::proto::detail::terminal_array_matches	/usr/include/boost/proto/matches.hpp	/^            struct terminal_array_matches<T, U *, true>$/;"	s	namespace:boost::proto::detail	inherits:is_convertible
boost::proto::detail::terminal_array_matches	/usr/include/boost/proto/matches.hpp	/^            struct terminal_array_matches<T, U(&)[M], true>$/;"	s	namespace:boost::proto::detail	inherits:is_convertible
boost::proto::detail::terminal_array_matches	/usr/include/boost/proto/matches.hpp	/^            struct terminal_array_matches<T, U(&)[proto::N], true>$/;"	s	namespace:boost::proto::detail	inherits:is_convertible
boost::proto::detail::terminal_matches	/usr/include/boost/proto/matches.hpp	/^            struct terminal_matches$/;"	s	namespace:boost::proto::detail	inherits:mpl::and_
boost::proto::detail::terminal_matches	/usr/include/boost/proto/matches.hpp	/^            struct terminal_matches$/;"	s	namespace:boost::proto::detail	inherits:mpl::or_
boost::proto::detail::terminal_matches	/usr/include/boost/proto/matches.hpp	/^            struct terminal_matches<T &, T>$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
boost::proto::detail::terminal_matches	/usr/include/boost/proto/matches.hpp	/^            struct terminal_matches<T const &, T>$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
boost::proto::detail::terminal_matches	/usr/include/boost/proto/matches.hpp	/^            struct terminal_matches<T const (&)[M], T const[M]>$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
boost::proto::detail::terminal_matches	/usr/include/boost/proto/matches.hpp	/^            struct terminal_matches<T(&)[M], T *>$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
boost::proto::detail::terminal_matches	/usr/include/boost/proto/matches.hpp	/^            struct terminal_matches<T(&)[M], T(&)[proto::N]>$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
boost::proto::detail::terminal_matches	/usr/include/boost/proto/matches.hpp	/^            struct terminal_matches<T, exact<T> >$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
boost::proto::detail::terminal_matches	/usr/include/boost/proto/matches.hpp	/^            struct terminal_matches<T, proto::convertible_to<U> >$/;"	s	namespace:boost::proto::detail	inherits:is_convertible
boost::proto::detail::terminal_matches	/usr/include/boost/proto/matches.hpp	/^            struct terminal_matches<T, proto::_>$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
boost::proto::detail::terminal_matches	/usr/include/boost/proto/matches.hpp	/^            struct terminal_matches<T, T>$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
boost::proto::detail::term_traits	/usr/include/boost/proto/args.hpp	/^            struct term_traits$/;"	s	namespace:boost::proto::detail
boost::proto::detail::term_traits	/usr/include/boost/proto/args.hpp	/^            struct term_traits<T &>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::term_traits	/usr/include/boost/proto/args.hpp	/^            struct term_traits<T (&)[N]>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::term_traits	/usr/include/boost/proto/args.hpp	/^            struct term_traits<T const &>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::term_traits	/usr/include/boost/proto/args.hpp	/^            struct term_traits<T const (&)[N]>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::term_traits	/usr/include/boost/proto/args.hpp	/^            struct term_traits<T const[N]>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::term_traits	/usr/include/boost/proto/args.hpp	/^            struct term_traits<T[N]>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::term_traits::const_reference	/usr/include/boost/proto/args.hpp	/^                typedef T &const_reference;$/;"	t	struct:boost::proto::detail::term_traits	access:public
boost::proto::detail::term_traits::const_reference	/usr/include/boost/proto/args.hpp	/^                typedef T (&const_reference)[N];$/;"	t	struct:boost::proto::detail::term_traits	access:public
boost::proto::detail::term_traits::const_reference	/usr/include/boost/proto/args.hpp	/^                typedef T const &const_reference;$/;"	t	struct:boost::proto::detail::term_traits	access:public
boost::proto::detail::term_traits::const_reference	/usr/include/boost/proto/args.hpp	/^                typedef T const (&const_reference)[N];$/;"	t	struct:boost::proto::detail::term_traits	access:public
boost::proto::detail::term_traits::reference	/usr/include/boost/proto/args.hpp	/^                typedef T &reference;$/;"	t	struct:boost::proto::detail::term_traits	access:public
boost::proto::detail::term_traits::reference	/usr/include/boost/proto/args.hpp	/^                typedef T (&reference)[N];$/;"	t	struct:boost::proto::detail::term_traits	access:public
boost::proto::detail::term_traits::reference	/usr/include/boost/proto/args.hpp	/^                typedef T const &reference;$/;"	t	struct:boost::proto::detail::term_traits	access:public
boost::proto::detail::term_traits::reference	/usr/include/boost/proto/args.hpp	/^                typedef T const (&reference)[N];$/;"	t	struct:boost::proto::detail::term_traits	access:public
boost::proto::detail::term_traits::value_type	/usr/include/boost/proto/args.hpp	/^                typedef T value_type;$/;"	t	struct:boost::proto::detail::term_traits	access:public
boost::proto::detail::term_traits::value_type	/usr/include/boost/proto/args.hpp	/^                typedef T value_type[N];$/;"	t	struct:boost::proto::detail::term_traits	access:public
boost::proto::detail::term_traits::value_type	/usr/include/boost/proto/args.hpp	/^                typedef typename mpl::if_c<is_function<T>::value, T &, T>::type value_type;$/;"	t	struct:boost::proto::detail::term_traits	access:public
boost::proto::detail::test_poly_function	/usr/include/boost/proto/detail/poly_function.hpp	/^        template<typename T> mono_function_t test_poly_function(T *, typename T::result_type * = 0);$/;"	p	namespace:boost::proto::detail	signature:(T *, typename T::result_type * = 0)
boost::proto::detail::test_poly_function	/usr/include/boost/proto/detail/poly_function.hpp	/^        template<typename T> poly_function_t test_poly_function(T *, typename T::is_poly_function_base_ * = 0);$/;"	p	namespace:boost::proto::detail	signature:(T *, typename T::is_poly_function_base_ * = 0)
boost::proto::detail::test_poly_function	/usr/include/boost/proto/detail/poly_function.hpp	/^        template<typename T> unknown_function_t test_poly_function(T *, ...);$/;"	p	namespace:boost::proto::detail	signature:(T *, ...)
boost::proto::detail::typelist	/usr/include/boost/proto/transform/make.hpp	/^            struct typelist$/;"	s	namespace:boost::proto::detail
boost::proto::detail::typelist::type	/usr/include/boost/proto/transform/make.hpp	/^                typedef void type;$/;"	t	struct:boost::proto::detail::typelist	access:public
boost::proto::detail::uncvref	/usr/include/boost/proto/proto_fwd.hpp	/^        struct uncvref$/;"	s	namespace:boost::proto::detail
boost::proto::detail::uncvref	/usr/include/boost/proto/proto_fwd.hpp	/^        struct uncvref<T &>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::uncvref	/usr/include/boost/proto/proto_fwd.hpp	/^        struct uncvref<T const &>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::uncvref	/usr/include/boost/proto/proto_fwd.hpp	/^        struct uncvref<T const>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::uncvref::type	/usr/include/boost/proto/proto_fwd.hpp	/^            typedef T type;$/;"	t	struct:boost::proto::detail::uncvref	access:public
boost::proto::detail::unknown_function_t	/usr/include/boost/proto/detail/poly_function.hpp	/^        typedef char (&unknown_function_t)[3];$/;"	t	namespace:boost::proto::detail
boost::proto::detail::unpack_expr_	/usr/include/boost/proto/make_expr.hpp	/^            struct unpack_expr_$/;"	s	namespace:boost::proto::detail
boost::proto::detail::unpack_expr_	/usr/include/boost/proto/make_expr.hpp	/^            struct unpack_expr_<tag::terminal, deduce_domain, Sequence, 1u>$/;"	s	namespace:boost::proto::detail	inherits:unpack_expr_
boost::proto::detail::unpack_expr_	/usr/include/boost/proto/make_expr.hpp	/^            struct unpack_expr_<tag::terminal, Domain, Sequence, 1u>$/;"	s	namespace:boost::proto::detail
boost::proto::detail::unpack_expr_::call	/usr/include/boost/proto/make_expr.hpp	/^                static type const call(Sequence const &sequence)$/;"	f	struct:boost::proto::detail::unpack_expr_	access:public	signature:(Sequence const &sequence)
boost::proto::detail::unpack_expr_::terminal_type	/usr/include/boost/proto/make_expr.hpp	/^                terminal_type;$/;"	t	struct:boost::proto::detail::unpack_expr_	access:public
boost::proto::detail::unpack_expr_::type	/usr/include/boost/proto/make_expr.hpp	/^                type;$/;"	t	struct:boost::proto::detail::unpack_expr_	access:public
boost::proto::detail::vararg_matches	/usr/include/boost/proto/matches.hpp	/^            struct vararg_matches$/;"	s	namespace:boost::proto::detail	inherits:mpl::false_
boost::proto::detail::vararg_matches	/usr/include/boost/proto/matches.hpp	/^            struct vararg_matches<Args1, Args2, Back, true, false, typename Back::proto_is_vararg_>$/;"	s	namespace:boost::proto::detail	inherits:and_2
boost::proto::detail::vararg_matches	/usr/include/boost/proto/matches.hpp	/^            struct vararg_matches<Args1, Args2, Back, true, true, typename Back::proto_is_vararg_>$/;"	s	namespace:boost::proto::detail	inherits:matches_
boost::proto::detail::yes_type	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef char yes_type;$/;"	t	namespace:boost::proto::detail
boost::proto::detail::_default	/usr/include/boost/proto/transform/default.hpp	/^            struct _default$/;"	s	namespace:boost::proto::detail	inherits:proto::_default
boost::proto::domainns_	/usr/include/boost/proto/domain.hpp	/^    namespace domainns_$/;"	n	namespace:boost::proto
boost::proto::domainns_	/usr/include/boost/proto/proto_fwd.hpp	/^    namespace domainns_$/;"	n	namespace:boost::proto
boost::proto::domainns_::deduce_domain	/usr/include/boost/proto/domain.hpp	/^        struct deduce_domain$/;"	s	namespace:boost::proto::domainns_	inherits:domain
boost::proto::domainns_::default_domain	/usr/include/boost/proto/domain.hpp	/^        struct default_domain$/;"	s	namespace:boost::proto::domainns_	inherits:domain
boost::proto::domainns_::domain	/usr/include/boost/proto/domain.hpp	/^        struct domain$/;"	s	namespace:boost::proto::domainns_	inherits:Generator
boost::proto::domainns_::domain::proto_grammar	/usr/include/boost/proto/domain.hpp	/^            typedef Grammar proto_grammar;$/;"	t	struct:boost::proto::domainns_::domain	access:public
boost::proto::domainns_::domain::proto_is_domain_	/usr/include/boost/proto/domain.hpp	/^            typedef void proto_is_domain_;$/;"	t	struct:boost::proto::domainns_::domain	access:public
boost::proto::eval	/usr/include/boost/proto/eval.hpp	/^    eval(Expr &e, Context &ctx)$/;"	f	namespace:boost::proto	signature:(Expr &e, Context &ctx)
boost::proto::eval	/usr/include/boost/proto/eval.hpp	/^    eval(Expr &e, Context const &ctx)$/;"	f	namespace:boost::proto	signature:(Expr &e, Context const &ctx)
boost::proto::eval_fun	/usr/include/boost/proto/fusion.hpp	/^    struct eval_fun$/;"	s	namespace:boost::proto
boost::proto::eval_fun::ctx_	/usr/include/boost/proto/fusion.hpp	/^        Context &ctx_;$/;"	m	struct:boost::proto::eval_fun	access:private
boost::proto::eval_fun::eval_fun	/usr/include/boost/proto/fusion.hpp	/^        explicit eval_fun(Context &ctx)$/;"	f	struct:boost::proto::eval_fun	access:public	signature:(Context &ctx)
boost::proto::eval_fun::operator ()	/usr/include/boost/proto/fusion.hpp	/^        operator ()(Expr &e) const$/;"	f	struct:boost::proto::eval_fun	access:public	signature:(Expr &e) const
boost::proto::eval_fun::operator ()	/usr/include/boost/proto/fusion.hpp	/^        operator ()(Expr const &e) const$/;"	f	struct:boost::proto::eval_fun	access:public	signature:(Expr const &e) const
boost::proto::eval_fun::result	/usr/include/boost/proto/fusion.hpp	/^        struct result<This(Expr &)>$/;"	s	struct:boost::proto::eval_fun	inherits:proto::result_of::eval	access:public
boost::proto::eval_fun::result	/usr/include/boost/proto/fusion.hpp	/^        struct result<This(Expr)>$/;"	s	struct:boost::proto::eval_fun	inherits:result	access:public
boost::proto::exops	/usr/include/boost/proto/proto_fwd.hpp	/^    namespace exops$/;"	n	namespace:boost::proto
boost::proto::exprns_	/usr/include/boost/proto/expr.hpp	/^        namespace exprns_$/;"	n	namespace:boost::proto
boost::proto::exprns_	/usr/include/boost/proto/extends.hpp	/^    namespace exprns_$/;"	n	namespace:boost::proto
boost::proto::exprns_	/usr/include/boost/proto/proto_fwd.hpp	/^    namespace exprns_$/;"	n	namespace:boost::proto
boost::proto::exprns_::extends	/usr/include/boost/proto/extends.hpp	/^        struct extends$/;"	s	namespace:boost::proto::exprns_
boost::proto::exprns_::extends	/usr/include/boost/proto/extends.hpp	/^        struct extends<Expr, Derived, Domain, 0>$/;"	s	namespace:boost::proto::exprns_
boost::proto::exprns_::extends::extends	/usr/include/boost/proto/extends.hpp	/^            extends()$/;"	f	struct:boost::proto::exprns_::extends	access:public	signature:()
boost::proto::exprns_::extends::extends	/usr/include/boost/proto/extends.hpp	/^            extends(Expr const &expr_)$/;"	f	struct:boost::proto::exprns_::extends	access:public	signature:(Expr const &expr_)
boost::proto::exprns_::extends::extends	/usr/include/boost/proto/extends.hpp	/^            extends(extends const &that)$/;"	f	struct:boost::proto::exprns_::extends	access:public	signature:(extends const &that)
boost::proto::exprns_::is_proto_expr	/usr/include/boost/proto/extends.hpp	/^        struct is_proto_expr$/;"	s	namespace:boost::proto::exprns_
boost::proto::exprns_::virtual_member	/usr/include/boost/proto/extends.hpp	/^        struct virtual_member$/;"	s	namespace:boost::proto::exprns_
boost::proto::exprns_::virtual_member::BOOST_STATIC_CONSTANT	/usr/include/boost/proto/extends.hpp	/^            BOOST_STATIC_CONSTANT(long, proto_arity_c = proto_base_expr::proto_arity_c);$/;"	p	struct:boost::proto::exprns_::virtual_member	access:public	signature:(long, proto_arity_c = proto_base_expr::proto_arity_c)
boost::proto::exprns_::virtual_member::child0	/usr/include/boost/proto/extends.hpp	/^            proto_child0 child0() const$/;"	f	struct:boost::proto::exprns_::virtual_member	access:public	signature:() const
boost::proto::exprns_::virtual_member::child1	/usr/include/boost/proto/extends.hpp	/^            proto_child1 child1() const$/;"	f	struct:boost::proto::exprns_::virtual_member	access:public	signature:() const
boost::proto::exprns_::virtual_member::fusion_tag	/usr/include/boost/proto/extends.hpp	/^            typedef boost::proto::tag::proto_expr fusion_tag;$/;"	t	struct:boost::proto::exprns_::virtual_member	access:public
boost::proto::exprns_::virtual_member::proto_address_of_hack_type_	/usr/include/boost/proto/extends.hpp	/^            typedef typename proto_base_expr::address_of_hack_type_ proto_address_of_hack_type_;$/;"	t	struct:boost::proto::exprns_::virtual_member	access:public
boost::proto::exprns_::virtual_member::proto_args	/usr/include/boost/proto/extends.hpp	/^            typedef typename proto_base_expr::proto_args proto_args;$/;"	t	struct:boost::proto::exprns_::virtual_member	access:public
boost::proto::exprns_::virtual_member::proto_arity	/usr/include/boost/proto/extends.hpp	/^            typedef typename proto_base_expr::proto_arity proto_arity;$/;"	t	struct:boost::proto::exprns_::virtual_member	access:public
boost::proto::exprns_::virtual_member::proto_base	/usr/include/boost/proto/extends.hpp	/^            proto_base_expr const proto_base() const$/;"	f	struct:boost::proto::exprns_::virtual_member	access:public	signature:() const
boost::proto::exprns_::virtual_member::proto_base_expr	/usr/include/boost/proto/extends.hpp	/^            proto_base_expr;$/;"	t	struct:boost::proto::exprns_::virtual_member	access:public
boost::proto::exprns_::virtual_member::proto_derived_expr	/usr/include/boost/proto/extends.hpp	/^            typedef virtual_member<This, Fun, Domain> proto_derived_expr;$/;"	t	struct:boost::proto::exprns_::virtual_member	access:public
boost::proto::exprns_::virtual_member::proto_domain	/usr/include/boost/proto/extends.hpp	/^            typedef Domain proto_domain;$/;"	t	struct:boost::proto::exprns_::virtual_member	access:public
boost::proto::exprns_::virtual_member::proto_is_aggregate_	/usr/include/boost/proto/extends.hpp	/^            typedef void proto_is_aggregate_; \/**< INTERNAL ONLY *\/$/;"	t	struct:boost::proto::exprns_::virtual_member	access:public
boost::proto::exprns_::virtual_member::proto_is_expr_	/usr/include/boost/proto/extends.hpp	/^            typedef void proto_is_expr_; \/**< INTERNAL ONLY *\/$/;"	t	struct:boost::proto::exprns_::virtual_member	access:public
boost::proto::exprns_::virtual_member::proto_tag	/usr/include/boost/proto/extends.hpp	/^            typedef typename proto_base_expr::proto_tag proto_tag;$/;"	t	struct:boost::proto::exprns_::virtual_member	access:public
boost::proto::fold	/usr/include/boost/proto/transform/fold.hpp	/^        struct fold : transform<fold<Sequence, State0, Fun> >$/;"	s	namespace:boost::proto	inherits:transform
boost::proto::fold	/usr/include/boost/proto/transform/fold.hpp	/^        struct fold<_, State0, Fun> : transform<fold<_, State0, Fun> >$/;"	s	namespace:boost::proto	inherits:transform
boost::proto::fold::impl	/usr/include/boost/proto/transform/fold.hpp	/^            struct impl : transform_impl<Expr, State, Data>$/;"	s	struct:boost::proto::fold	inherits:transform_impl	access:public
boost::proto::fold::impl	/usr/include/boost/proto/transform/fold.hpp	/^            struct impl$/;"	s	struct:boost::proto::fold	inherits:detail::fold_impl	access:public
boost::proto::fold::impl::fun	/usr/include/boost/proto/transform/fold.hpp	/^                fun;$/;"	t	struct:boost::proto::fold::impl	access:public
boost::proto::fold::impl::operator ()	/usr/include/boost/proto/transform/fold.hpp	/^                result_type operator ()($/;"	f	struct:boost::proto::fold::impl	access:public	signature:( typename impl::expr_param e , typename impl::state_param s , typename impl::data_param d ) const
boost::proto::fold::impl::result_type	/usr/include/boost/proto/transform/fold.hpp	/^                result_type;$/;"	t	struct:boost::proto::fold::impl	access:public
boost::proto::fold::impl::sequence	/usr/include/boost/proto/transform/fold.hpp	/^                sequence;$/;"	t	struct:boost::proto::fold::impl	access:public
boost::proto::fold::impl::state0	/usr/include/boost/proto/transform/fold.hpp	/^                state0;$/;"	t	struct:boost::proto::fold::impl	access:public
boost::proto::fold_tree	/usr/include/boost/proto/transform/fold_tree.hpp	/^    struct fold_tree$/;"	s	namespace:boost::proto	inherits:transform
boost::proto::fold_tree::impl	/usr/include/boost/proto/transform/fold_tree.hpp	/^        struct impl$/;"	s	struct:boost::proto::fold_tree	inherits:fold::,impl	access:public
boost::proto::functional	/usr/include/boost/proto/deep_copy.hpp	/^        namespace functional$/;"	n	namespace:boost::proto
boost::proto::functional	/usr/include/boost/proto/eval.hpp	/^    namespace functional$/;"	n	namespace:boost::proto
boost::proto::functional	/usr/include/boost/proto/fusion.hpp	/^    namespace functional$/;"	n	namespace:boost::proto
boost::proto::functional	/usr/include/boost/proto/make_expr.hpp	/^        namespace functional$/;"	n	namespace:boost::proto
boost::proto::functional	/usr/include/boost/proto/proto_fwd.hpp	/^    namespace functional$/;"	n	namespace:boost::proto
boost::proto::functional	/usr/include/boost/proto/traits.hpp	/^        namespace functional$/;"	n	namespace:boost::proto
boost::proto::functional::as_child	/usr/include/boost/proto/traits.hpp	/^            struct as_child$/;"	s	namespace:boost::proto::functional
boost::proto::functional::as_child::operator ()	/usr/include/boost/proto/traits.hpp	/^                operator ()(T &t) const$/;"	f	struct:boost::proto::functional::as_child	access:public	signature:(T &t) const
boost::proto::functional::as_child::operator ()	/usr/include/boost/proto/traits.hpp	/^                operator ()(T const &t) const$/;"	f	struct:boost::proto::functional::as_child	access:public	signature:(T const &t) const
boost::proto::functional::as_child::result	/usr/include/boost/proto/traits.hpp	/^                struct result<This(T)>$/;"	s	struct:boost::proto::functional::as_child	access:public
boost::proto::functional::as_child::result::type	/usr/include/boost/proto/traits.hpp	/^                    typedef typename result_of::as_child<unref_type, Domain>::type type;$/;"	t	struct:boost::proto::functional::as_child::result	access:public
boost::proto::functional::as_child::result::unref_type	/usr/include/boost/proto/traits.hpp	/^                    typedef typename remove_reference<T>::type unref_type;$/;"	t	struct:boost::proto::functional::as_child::result	access:public
boost::proto::functional::as_expr	/usr/include/boost/proto/traits.hpp	/^            struct as_expr$/;"	s	namespace:boost::proto::functional
boost::proto::functional::as_expr::operator ()	/usr/include/boost/proto/traits.hpp	/^                operator ()(T &t) const$/;"	f	struct:boost::proto::functional::as_expr	access:public	signature:(T &t) const
boost::proto::functional::as_expr::operator ()	/usr/include/boost/proto/traits.hpp	/^                operator ()(T const &t) const$/;"	f	struct:boost::proto::functional::as_expr	access:public	signature:(T const &t) const
boost::proto::functional::as_expr::operator ()	/usr/include/boost/proto/traits.hpp	/^                operator ()(T const (&t)[N_]) const$/;"	f	struct:boost::proto::functional::as_expr	access:public	signature:(T const (&t)[N_]) const
boost::proto::functional::as_expr::result	/usr/include/boost/proto/traits.hpp	/^                struct result<This(T)>$/;"	s	struct:boost::proto::functional::as_expr	access:public
boost::proto::functional::as_expr::result::type	/usr/include/boost/proto/traits.hpp	/^                    typedef typename result_of::as_expr<unref_type, Domain>::type type;$/;"	t	struct:boost::proto::functional::as_expr::result	access:public
boost::proto::functional::as_expr::result::unref_type	/usr/include/boost/proto/traits.hpp	/^                    typedef typename remove_reference<T>::type unref_type;$/;"	t	struct:boost::proto::functional::as_expr::result	access:public
boost::proto::functional::child	/usr/include/boost/proto/traits.hpp	/^            struct child$/;"	s	namespace:boost::proto::functional
boost::proto::functional::child::operator ()	/usr/include/boost/proto/traits.hpp	/^                operator ()(Expr &e) const$/;"	f	struct:boost::proto::functional::child	access:public	signature:(Expr &e) const
boost::proto::functional::child::operator ()	/usr/include/boost/proto/traits.hpp	/^                operator ()(Expr const &e) const$/;"	f	struct:boost::proto::functional::child	access:public	signature:(Expr const &e) const
boost::proto::functional::child::result	/usr/include/boost/proto/traits.hpp	/^                struct result<This(Expr)>$/;"	s	struct:boost::proto::functional::child	access:public
boost::proto::functional::child::result::type	/usr/include/boost/proto/traits.hpp	/^                    typedef typename result_of::child<Expr, N>::type type;$/;"	t	struct:boost::proto::functional::child::result	access:public
boost::proto::functional::child_c	/usr/include/boost/proto/traits.hpp	/^            struct child_c$/;"	s	namespace:boost::proto::functional
boost::proto::functional::child_c::operator ()	/usr/include/boost/proto/traits.hpp	/^                operator ()(Expr &e) const$/;"	f	struct:boost::proto::functional::child_c	access:public	signature:(Expr &e) const
boost::proto::functional::child_c::operator ()	/usr/include/boost/proto/traits.hpp	/^                operator ()(Expr const &e) const$/;"	f	struct:boost::proto::functional::child_c	access:public	signature:(Expr const &e) const
boost::proto::functional::child_c::result	/usr/include/boost/proto/traits.hpp	/^                struct result<This(Expr)>$/;"	s	struct:boost::proto::functional::child_c	access:public
boost::proto::functional::child_c::result::type	/usr/include/boost/proto/traits.hpp	/^                    typedef typename result_of::child_c<Expr, N>::type type;$/;"	t	struct:boost::proto::functional::child_c::result	access:public
boost::proto::functional::deep_copy	/usr/include/boost/proto/deep_copy.hpp	/^            struct deep_copy$/;"	s	namespace:boost::proto::functional
boost::proto::functional::deep_copy::operator ()	/usr/include/boost/proto/deep_copy.hpp	/^                operator()(Expr const &e) const$/;"	f	struct:boost::proto::functional::deep_copy	access:public	signature:(Expr const &e) const
boost::proto::functional::deep_copy::result	/usr/include/boost/proto/deep_copy.hpp	/^                struct result<This(Expr)>$/;"	s	struct:boost::proto::functional::deep_copy	access:public
boost::proto::functional::deep_copy::result::type	/usr/include/boost/proto/deep_copy.hpp	/^                    type;$/;"	t	struct:boost::proto::functional::deep_copy::result	access:public
boost::proto::functional::eval	/usr/include/boost/proto/eval.hpp	/^        struct eval$/;"	s	namespace:boost::proto::functional
boost::proto::functional::eval::operator ()	/usr/include/boost/proto/eval.hpp	/^            operator ()(Expr &e, Context &ctx) const$/;"	f	struct:boost::proto::functional::eval	access:public	signature:(Expr &e, Context &ctx) const
boost::proto::functional::eval::operator ()	/usr/include/boost/proto/eval.hpp	/^            operator ()(Expr &e, Context const &ctx) const$/;"	f	struct:boost::proto::functional::eval	access:public	signature:(Expr &e, Context const &ctx) const
boost::proto::functional::eval::result	/usr/include/boost/proto/eval.hpp	/^            struct result<This(Expr, Context)>$/;"	s	struct:boost::proto::functional::eval	access:public
boost::proto::functional::eval::result::type	/usr/include/boost/proto/eval.hpp	/^                type;$/;"	t	struct:boost::proto::functional::eval::result	access:public
boost::proto::functional::flatten	/usr/include/boost/proto/fusion.hpp	/^        struct flatten$/;"	s	namespace:boost::proto::functional
boost::proto::functional::flatten::proto::detail::operator ()	/usr/include/boost/proto/fusion.hpp	/^            operator ()(Expr &e) const$/;"	f	class:boost::proto::functional::flatten::proto::detail	access:public	signature:(Expr &e) const
boost::proto::functional::flatten::proto::detail::operator ()	/usr/include/boost/proto/fusion.hpp	/^            operator ()(Expr const &e) const$/;"	f	class:boost::proto::functional::flatten::proto::detail	access:public	signature:(Expr const &e) const
boost::proto::functional::flatten::result	/usr/include/boost/proto/fusion.hpp	/^            struct result<This(Expr &)>$/;"	s	struct:boost::proto::functional::flatten	access:public
boost::proto::functional::flatten::result	/usr/include/boost/proto/fusion.hpp	/^            struct result<This(Expr)>$/;"	s	struct:boost::proto::functional::flatten	inherits:result	access:public
boost::proto::functional::flatten::result::type	/usr/include/boost/proto/fusion.hpp	/^                typedef proto::detail::flat_view<Expr> type;$/;"	t	struct:boost::proto::functional::flatten::result	access:public
boost::proto::functional::left	/usr/include/boost/proto/traits.hpp	/^            struct left$/;"	s	namespace:boost::proto::functional
boost::proto::functional::left::operator ()	/usr/include/boost/proto/traits.hpp	/^                operator ()(Expr &e) const$/;"	f	struct:boost::proto::functional::left	access:public	signature:(Expr &e) const
boost::proto::functional::left::operator ()	/usr/include/boost/proto/traits.hpp	/^                operator ()(Expr const &e) const$/;"	f	struct:boost::proto::functional::left	access:public	signature:(Expr const &e) const
boost::proto::functional::left::result	/usr/include/boost/proto/traits.hpp	/^                struct result<This(Expr)>$/;"	s	struct:boost::proto::functional::left	access:public
boost::proto::functional::left::result::type	/usr/include/boost/proto/traits.hpp	/^                    typedef typename result_of::left<Expr>::type type;$/;"	t	struct:boost::proto::functional::left::result	access:public
boost::proto::functional::make_address_of	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::address_of>          make_address_of;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_assign	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::assign>              make_assign;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_bitwise_and	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::bitwise_and>         make_bitwise_and;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_bitwise_and_assign	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::bitwise_and_assign>  make_bitwise_and_assign;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_bitwise_or	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::bitwise_or>          make_bitwise_or;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_bitwise_or_assign	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::bitwise_or_assign>   make_bitwise_or_assign;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_bitwise_xor	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::bitwise_xor>         make_bitwise_xor;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_bitwise_xor_assign	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::bitwise_xor_assign>  make_bitwise_xor_assign;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_comma	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::comma>               make_comma;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_complement	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::complement>          make_complement;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_dereference	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::dereference>         make_dereference;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_divides	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::divides>             make_divides;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_divides_assign	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::divides_assign>      make_divides_assign;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_equal_to	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::equal_to>            make_equal_to;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_expr	/usr/include/boost/proto/make_expr.hpp	/^            struct make_expr$/;"	s	namespace:boost::proto::functional
boost::proto::functional::make_expr::impl	/usr/include/boost/proto/make_expr.hpp	/^                struct impl$/;"	s	struct:boost::proto::functional::make_expr	inherits:detail::make_expr_	access:public
boost::proto::functional::make_expr::operator ()	/usr/include/boost/proto/make_expr.hpp	/^                operator ()(A0 const &a0) const$/;"	f	struct:boost::proto::functional::make_expr	access:public	signature:(A0 const &a0) const
boost::proto::functional::make_expr::result	/usr/include/boost/proto/make_expr.hpp	/^                struct result<This(A0)>$/;"	s	struct:boost::proto::functional::make_expr	access:public
boost::proto::functional::make_expr::result::type	/usr/include/boost/proto/make_expr.hpp	/^                    type;$/;"	t	struct:boost::proto::functional::make_expr::result	access:public
boost::proto::functional::make_function	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::function>            make_function;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_greater	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::greater>             make_greater;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_greater_equal	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::greater_equal>       make_greater_equal;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_if_else	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::if_else_>            make_if_else;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_less	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::less>                make_less;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_less_equal	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::less_equal>          make_less_equal;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_logical_and	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::logical_and>         make_logical_and;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_logical_not	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::logical_not>         make_logical_not;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_logical_or	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::logical_or>          make_logical_or;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_mem_ptr	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::mem_ptr>             make_mem_ptr;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_minus	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::minus>               make_minus;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_minus_assign	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::minus_assign>        make_minus_assign;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_modulus	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::modulus>             make_modulus;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_modulus_assign	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::modulus_assign>      make_modulus_assign;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_multiplies	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::multiplies>          make_multiplies;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_multiplies_assign	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::multiplies_assign>   make_multiplies_assign;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_negate	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::negate>              make_negate;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_not_equal_to	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::not_equal_to>        make_not_equal_to;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_plus	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::plus>                make_plus;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_plus_assign	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::plus_assign>         make_plus_assign;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_post_dec	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::post_dec>            make_post_dec;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_post_inc	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::post_inc>            make_post_inc;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_pre_dec	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::pre_dec>             make_pre_dec;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_pre_inc	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::pre_inc>             make_pre_inc;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_shift_left	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::shift_left>          make_shift_left;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_shift_left_assign	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::shift_left_assign>   make_shift_left_assign;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_shift_right	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::shift_right>         make_shift_right;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_shift_right_assign	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::shift_right_assign>  make_shift_right_assign;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_subscript	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::subscript>           make_subscript;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_terminal	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::terminal>            make_terminal;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::make_unary_plus	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::unary_plus>          make_unary_plus;$/;"	t	namespace:boost::proto::functional
boost::proto::functional::pop_front	/usr/include/boost/proto/fusion.hpp	/^        struct pop_front$/;"	s	namespace:boost::proto::functional
boost::proto::functional::pop_front::operator ()	/usr/include/boost/proto/fusion.hpp	/^            operator ()(Expr &e) const$/;"	f	struct:boost::proto::functional::pop_front	access:public	signature:(Expr &e) const
boost::proto::functional::pop_front::operator ()	/usr/include/boost/proto/fusion.hpp	/^            operator ()(Expr const &e) const$/;"	f	struct:boost::proto::functional::pop_front	access:public	signature:(Expr const &e) const
boost::proto::functional::pop_front::result	/usr/include/boost/proto/fusion.hpp	/^            struct result<This(Expr &)>$/;"	s	struct:boost::proto::functional::pop_front	inherits:fusion::result_of::pop_front	access:public
boost::proto::functional::pop_front::result	/usr/include/boost/proto/fusion.hpp	/^            struct result<This(Expr)>$/;"	s	struct:boost::proto::functional::pop_front	inherits:result	access:public
boost::proto::functional::reverse	/usr/include/boost/proto/fusion.hpp	/^        struct reverse$/;"	s	namespace:boost::proto::functional
boost::proto::functional::reverse::operator ()	/usr/include/boost/proto/fusion.hpp	/^            operator ()(Expr &e) const$/;"	f	struct:boost::proto::functional::reverse	access:public	signature:(Expr &e) const
boost::proto::functional::reverse::operator ()	/usr/include/boost/proto/fusion.hpp	/^            operator ()(Expr const &e) const$/;"	f	struct:boost::proto::functional::reverse	access:public	signature:(Expr const &e) const
boost::proto::functional::reverse::result	/usr/include/boost/proto/fusion.hpp	/^            struct result<This(Expr &)>$/;"	s	struct:boost::proto::functional::reverse	inherits:fusion::result_of::reverse	access:public
boost::proto::functional::reverse::result	/usr/include/boost/proto/fusion.hpp	/^            struct result<This(Expr)>$/;"	s	struct:boost::proto::functional::reverse	inherits:result	access:public
boost::proto::functional::right	/usr/include/boost/proto/traits.hpp	/^            struct right$/;"	s	namespace:boost::proto::functional
boost::proto::functional::right::operator ()	/usr/include/boost/proto/traits.hpp	/^                operator ()(Expr &e) const$/;"	f	struct:boost::proto::functional::right	access:public	signature:(Expr &e) const
boost::proto::functional::right::operator ()	/usr/include/boost/proto/traits.hpp	/^                operator ()(Expr const &e) const$/;"	f	struct:boost::proto::functional::right	access:public	signature:(Expr const &e) const
boost::proto::functional::right::result	/usr/include/boost/proto/traits.hpp	/^                struct result<This(Expr)>$/;"	s	struct:boost::proto::functional::right	access:public
boost::proto::functional::right::result::type	/usr/include/boost/proto/traits.hpp	/^                    typedef typename result_of::right<Expr>::type type;$/;"	t	struct:boost::proto::functional::right::result	access:public
boost::proto::functional::unfused_expr	/usr/include/boost/proto/make_expr.hpp	/^            struct unfused_expr$/;"	s	namespace:boost::proto::functional	inherits:fusion::unfused_generic
boost::proto::functional::unfused_expr_fun	/usr/include/boost/proto/make_expr.hpp	/^            struct unfused_expr_fun$/;"	s	namespace:boost::proto::functional
boost::proto::functional::unfused_expr_fun::operator ()	/usr/include/boost/proto/make_expr.hpp	/^                operator ()(Sequence const &sequence) const$/;"	f	struct:boost::proto::functional::unfused_expr_fun	access:public	signature:(Sequence const &sequence) const
boost::proto::functional::unfused_expr_fun::result	/usr/include/boost/proto/make_expr.hpp	/^                struct result<This(Sequence)>$/;"	s	struct:boost::proto::functional::unfused_expr_fun	access:public
boost::proto::functional::unfused_expr_fun::result::type	/usr/include/boost/proto/make_expr.hpp	/^                    type;$/;"	t	struct:boost::proto::functional::unfused_expr_fun::result	access:public
boost::proto::functional::unpack_expr	/usr/include/boost/proto/make_expr.hpp	/^            struct unpack_expr$/;"	s	namespace:boost::proto::functional
boost::proto::functional::unpack_expr::operator ()	/usr/include/boost/proto/make_expr.hpp	/^                operator ()(Sequence const &sequence) const$/;"	f	struct:boost::proto::functional::unpack_expr	access:public	signature:(Sequence const &sequence) const
boost::proto::functional::unpack_expr::result	/usr/include/boost/proto/make_expr.hpp	/^                struct result$/;"	s	struct:boost::proto::functional::unpack_expr	access:public
boost::proto::functional::unpack_expr::result	/usr/include/boost/proto/make_expr.hpp	/^                struct result<This(Sequence)>$/;"	s	struct:boost::proto::functional::unpack_expr	access:public
boost::proto::functional::unpack_expr::result::type	/usr/include/boost/proto/make_expr.hpp	/^                    type;$/;"	t	struct:boost::proto::functional::unpack_expr::result	access:public
boost::proto::functional::value	/usr/include/boost/proto/traits.hpp	/^            struct value$/;"	s	namespace:boost::proto::functional
boost::proto::functional::value::operator ()	/usr/include/boost/proto/traits.hpp	/^                operator ()(Expr &e) const$/;"	f	struct:boost::proto::functional::value	access:public	signature:(Expr &e) const
boost::proto::functional::value::operator ()	/usr/include/boost/proto/traits.hpp	/^                operator ()(Expr const &e) const$/;"	f	struct:boost::proto::functional::value	access:public	signature:(Expr const &e) const
boost::proto::functional::value::result	/usr/include/boost/proto/traits.hpp	/^                struct result<This(Expr)>$/;"	s	struct:boost::proto::functional::value	access:public
boost::proto::functional::value::result::type	/usr/include/boost/proto/traits.hpp	/^                    typedef typename result_of::value<Expr>::type type;$/;"	t	struct:boost::proto::functional::value::result	access:public
boost::proto::generatorns_	/usr/include/boost/proto/generate.hpp	/^        namespace generatorns_$/;"	n	namespace:boost::proto
boost::proto::generatorns_	/usr/include/boost/proto/proto_fwd.hpp	/^    namespace generatorns_$/;"	n	namespace:boost::proto
boost::proto::generatorns_::by_value_generator	/usr/include/boost/proto/generate.hpp	/^            struct by_value_generator$/;"	s	namespace:boost::proto::generatorns_
boost::proto::generatorns_::by_value_generator::operator ()	/usr/include/boost/proto/generate.hpp	/^                typename result<by_value_generator(Expr)>::type operator ()(Expr const &e) const$/;"	f	struct:boost::proto::generatorns_::by_value_generator	access:public	signature:(Expr const &e) const
boost::proto::generatorns_::by_value_generator::result	/usr/include/boost/proto/generate.hpp	/^                struct result<This(Expr &)>$/;"	s	struct:boost::proto::generatorns_::by_value_generator	access:public
boost::proto::generatorns_::by_value_generator::result	/usr/include/boost/proto/generate.hpp	/^                struct result<This(Expr const &)>$/;"	s	struct:boost::proto::generatorns_::by_value_generator	access:public
boost::proto::generatorns_::by_value_generator::result	/usr/include/boost/proto/generate.hpp	/^                struct result<This(Expr)>$/;"	s	struct:boost::proto::generatorns_::by_value_generator	access:public
boost::proto::generatorns_::by_value_generator::result::type	/usr/include/boost/proto/generate.hpp	/^                    type;$/;"	t	struct:boost::proto::generatorns_::by_value_generator::result	access:public
boost::proto::generatorns_::compose_generators	/usr/include/boost/proto/generate.hpp	/^            struct compose_generators$/;"	s	namespace:boost::proto::generatorns_
boost::proto::generatorns_::compose_generators::operator ()	/usr/include/boost/proto/generate.hpp	/^                typename result<compose_generators(Expr)>::type operator ()(Expr const &e) const$/;"	f	struct:boost::proto::generatorns_::compose_generators	access:public	signature:(Expr const &e) const
boost::proto::generatorns_::compose_generators::result	/usr/include/boost/proto/generate.hpp	/^                struct result<This(Expr &)>$/;"	s	struct:boost::proto::generatorns_::compose_generators	access:public
boost::proto::generatorns_::compose_generators::result	/usr/include/boost/proto/generate.hpp	/^                struct result<This(Expr const &)>$/;"	s	struct:boost::proto::generatorns_::compose_generators	access:public
boost::proto::generatorns_::compose_generators::result	/usr/include/boost/proto/generate.hpp	/^                struct result<This(Expr)>$/;"	s	struct:boost::proto::generatorns_::compose_generators	access:public
boost::proto::generatorns_::compose_generators::result::type	/usr/include/boost/proto/generate.hpp	/^                    type;$/;"	t	struct:boost::proto::generatorns_::compose_generators::result	access:public
boost::proto::generatorns_::default_generator	/usr/include/boost/proto/generate.hpp	/^            struct default_generator$/;"	s	namespace:boost::proto::generatorns_
boost::proto::generatorns_::default_generator::operator ()	/usr/include/boost/proto/generate.hpp	/^                operator ()(Expr const &e) const$/;"	f	struct:boost::proto::generatorns_::default_generator	access:public	signature:(Expr const &e) const
boost::proto::generatorns_::default_generator::result	/usr/include/boost/proto/generate.hpp	/^                struct result<This(Expr)>$/;"	s	struct:boost::proto::generatorns_::default_generator	access:public
boost::proto::generatorns_::default_generator::result::type	/usr/include/boost/proto/generate.hpp	/^                    typedef Expr type;$/;"	t	struct:boost::proto::generatorns_::default_generator::result	access:public
boost::proto::generatorns_::generator	/usr/include/boost/proto/generate.hpp	/^            struct generator$/;"	s	namespace:boost::proto::generatorns_
boost::proto::generatorns_::generator::operator ()	/usr/include/boost/proto/generate.hpp	/^                Extends<Expr> operator ()(Expr const &e) const$/;"	f	struct:boost::proto::generatorns_::generator	access:public	signature:(Expr const &e) const
boost::proto::generatorns_::generator::result	/usr/include/boost/proto/generate.hpp	/^                struct result<This(Expr &)>$/;"	s	struct:boost::proto::generatorns_::generator	access:public
boost::proto::generatorns_::generator::result	/usr/include/boost/proto/generate.hpp	/^                struct result<This(Expr const &)>$/;"	s	struct:boost::proto::generatorns_::generator	access:public
boost::proto::generatorns_::generator::result	/usr/include/boost/proto/generate.hpp	/^                struct result<This(Expr)>$/;"	s	struct:boost::proto::generatorns_::generator	access:public
boost::proto::generatorns_::generator::result::type	/usr/include/boost/proto/generate.hpp	/^                    typedef Extends<Expr> type;$/;"	t	struct:boost::proto::generatorns_::generator::result	access:public
boost::proto::generatorns_::pod_generator	/usr/include/boost/proto/generate.hpp	/^            struct pod_generator$/;"	s	namespace:boost::proto::generatorns_
boost::proto::generatorns_::pod_generator::operator ()	/usr/include/boost/proto/generate.hpp	/^                Extends<Expr> operator ()(Expr const &e) const$/;"	f	struct:boost::proto::generatorns_::pod_generator	access:public	signature:(Expr const &e) const
boost::proto::generatorns_::pod_generator::result	/usr/include/boost/proto/generate.hpp	/^                struct result<This(Expr &)>$/;"	s	struct:boost::proto::generatorns_::pod_generator	access:public
boost::proto::generatorns_::pod_generator::result	/usr/include/boost/proto/generate.hpp	/^                struct result<This(Expr const &)>$/;"	s	struct:boost::proto::generatorns_::pod_generator	access:public
boost::proto::generatorns_::pod_generator::result	/usr/include/boost/proto/generate.hpp	/^                struct result<This(Expr)>$/;"	s	struct:boost::proto::generatorns_::pod_generator	access:public
boost::proto::generatorns_::pod_generator::result::type	/usr/include/boost/proto/generate.hpp	/^                    typedef Extends<Expr> type;$/;"	t	struct:boost::proto::generatorns_::pod_generator::result	access:public
boost::proto::is_aggregate	/usr/include/boost/proto/traits.hpp	/^        struct is_aggregate$/;"	s	namespace:boost::proto	inherits:is_pod
boost::proto::is_aggregate	/usr/include/boost/proto/traits.hpp	/^        struct is_aggregate<proto::expr<Tag, Args, N>, void>$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_aggregate	/usr/include/boost/proto/traits.hpp	/^        struct is_aggregate<T, typename T::proto_is_aggregate_>$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/fusion.hpp	/^    struct is_callable<functional::flatten>$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/fusion.hpp	/^    struct is_callable<functional::pop_front>$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/fusion.hpp	/^    struct is_callable<functional::reverse>$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/generate.hpp	/^        struct is_callable<by_value_generator>$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/generate.hpp	/^        struct is_callable<compose_generators<First, Second> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/generate.hpp	/^        struct is_callable<default_generator>$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/generate.hpp	/^        struct is_callable<generator<Extends> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/generate.hpp	/^        struct is_callable<pod_generator<Extends> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/make_expr.hpp	/^        struct is_callable<functional::make_expr<Tag, Domain> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/make_expr.hpp	/^        struct is_callable<functional::unfused_expr<Tag, Domain> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/make_expr.hpp	/^        struct is_callable<functional::unpack_expr<Tag, Domain> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/matches.hpp	/^        struct is_callable<and_<BOOST_PP_ENUM_PARAMS(BOOST_PROTO_MAX_LOGICAL_ARITY, G)> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/matches.hpp	/^        struct is_callable<if_<If, Then, Else> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/matches.hpp	/^        struct is_callable<not_<Grammar> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/matches.hpp	/^        struct is_callable<or_<BOOST_PP_ENUM_PARAMS(BOOST_PROTO_MAX_LOGICAL_ARITY, G)> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/matches.hpp	/^        struct is_callable<vararg<Grammar> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/traits.hpp	/^        struct is_callable$/;"	s	namespace:boost::proto	inherits:proto::detail::is_callable_
boost::proto::is_callable	/usr/include/boost/proto/traits.hpp	/^        struct is_callable<functional::as_child<Domain> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/traits.hpp	/^        struct is_callable<functional::as_expr<Domain> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/traits.hpp	/^        struct is_callable<functional::child<N> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/traits.hpp	/^        struct is_callable<functional::child_c<N> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/traits.hpp	/^        struct is_callable<proto::callable>$/;"	s	namespace:boost::proto	inherits:mpl::false_
boost::proto::is_callable	/usr/include/boost/proto/traits.hpp	/^        struct is_callable<proto::expr<Tag, Args, N> >$/;"	s	namespace:boost::proto	inherits:mpl::false_
boost::proto::is_callable	/usr/include/boost/proto/traits.hpp	/^        struct is_callable<proto::_>$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/transform/arg.hpp	/^    struct is_callable<_byref>$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/transform/arg.hpp	/^    struct is_callable<_byval>$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/transform/arg.hpp	/^    struct is_callable<_child_c<N> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/transform/arg.hpp	/^    struct is_callable<_data>$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/transform/arg.hpp	/^    struct is_callable<_expr>$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/transform/arg.hpp	/^    struct is_callable<_state>$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/transform/arg.hpp	/^    struct is_callable<_value>$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/transform/call.hpp	/^        struct is_callable<call<Fun> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/transform/default.hpp	/^        struct is_callable<_default<Grammar> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/transform/fold.hpp	/^        struct is_callable<fold<Sequence, State, Fun> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/transform/fold.hpp	/^        struct is_callable<reverse_fold<Sequence, State, Fun> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/transform/fold_tree.hpp	/^    struct is_callable<fold_tree<Sequence, State0, Fun> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/transform/fold_tree.hpp	/^    struct is_callable<reverse_fold_tree<Sequence, State0, Fun> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/transform/lazy.hpp	/^        struct is_callable<lazy<Object> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/transform/make.hpp	/^        struct is_callable<make<Object> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/transform/make.hpp	/^        struct is_callable<protect<PrimitiveTransform> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_callable	/usr/include/boost/proto/transform/pass_through.hpp	/^        struct is_callable<pass_through<Grammar> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::is_transform	/usr/include/boost/proto/traits.hpp	/^        struct is_transform$/;"	s	namespace:boost::proto	inherits:mpl::false_
boost::proto::is_transform	/usr/include/boost/proto/traits.hpp	/^        struct is_transform<T, typename T::proto_is_transform_>$/;"	s	namespace:boost::proto	inherits:mpl::true_
boost::proto::lazy	/usr/include/boost/proto/transform/lazy.hpp	/^        struct lazy : transform<lazy<Object> >$/;"	s	namespace:boost::proto	inherits:transform
boost::proto::lazy::impl	/usr/include/boost/proto/transform/lazy.hpp	/^            struct impl$/;"	s	struct:boost::proto::lazy	inherits:call::,impl	access:public
boost::proto::lazy_disable_if::make_expr	/usr/include/boost/proto/make_expr.hpp	/^        make_expr(A0 const &a0)$/;"	f	class:boost::proto::lazy_disable_if	signature:(A0 const &a0)
boost::proto::lazy_disable_if::unpack_expr	/usr/include/boost/proto/make_expr.hpp	/^        unpack_expr(Sequence const &sequence)$/;"	f	class:boost::proto::lazy_disable_if	signature:(Sequence const &sequence)
boost::proto::left	/usr/include/boost/proto/traits.hpp	/^        left(Expr const &e)$/;"	f	namespace:boost::proto	signature:(Expr const &e)
boost::proto::lit	/usr/include/boost/proto/literal.hpp	/^    inline literal<T &> const lit(T &t)$/;"	f	namespace:boost::proto	signature:(T &t)
boost::proto::lit	/usr/include/boost/proto/literal.hpp	/^    inline literal<T const &> const lit(T const &t)$/;"	f	namespace:boost::proto	signature:(T const &t)
boost::proto::make	/usr/include/boost/proto/transform/make.hpp	/^        struct make : transform<make<Object> >$/;"	s	namespace:boost::proto	inherits:transform
boost::proto::make::impl	/usr/include/boost/proto/transform/make.hpp	/^            struct impl : transform_impl<Expr, State, Data>$/;"	s	struct:boost::proto::make	inherits:transform_impl	access:public
boost::proto::make::impl::operator ()	/usr/include/boost/proto/transform/make.hpp	/^                result_type operator ()($/;"	f	struct:boost::proto::make::impl	access:public	signature:( typename impl::expr_param , typename impl::state_param , typename impl::data_param ) const
boost::proto::make::impl::result_type	/usr/include/boost/proto/transform/make.hpp	/^                typedef typename detail::make_if_<Object, Expr, State, Data>::type result_type;$/;"	t	struct:boost::proto::make::impl	access:public
boost::proto::op	/usr/include/boost/proto/proto_fwd.hpp	/^    namespace op$/;"	n	namespace:boost::proto
boost::proto::op	/usr/include/boost/proto/traits.hpp	/^        namespace op$/;"	n	namespace:boost::proto
boost::proto::op::binary_expr	/usr/include/boost/proto/traits.hpp	/^            struct binary_expr$/;"	s	namespace:boost::proto::op	inherits:proto::transform
boost::proto::op::binary_expr::impl	/usr/include/boost/proto/traits.hpp	/^                struct impl$/;"	s	struct:boost::proto::op::binary_expr	inherits:detail::pass_through_impl	access:public
boost::proto::op::binary_expr::proto_base_expr	/usr/include/boost/proto/traits.hpp	/^                typedef type proto_base_expr;$/;"	t	struct:boost::proto::op::binary_expr	access:public
boost::proto::op::binary_expr::proto_child0	/usr/include/boost/proto/traits.hpp	/^                typedef T proto_child0;$/;"	t	struct:boost::proto::op::binary_expr	access:public
boost::proto::op::binary_expr::proto_child1	/usr/include/boost/proto/traits.hpp	/^                typedef U proto_child1;$/;"	t	struct:boost::proto::op::binary_expr	access:public
boost::proto::op::binary_expr::proto_tag	/usr/include/boost/proto/traits.hpp	/^                typedef Tag proto_tag;$/;"	t	struct:boost::proto::op::binary_expr	access:public
boost::proto::op::binary_expr::type	/usr/include/boost/proto/traits.hpp	/^                typedef proto::expr<Tag, list2<T, U>, 2> type;$/;"	t	struct:boost::proto::op::binary_expr	access:public
boost::proto::op::if_else_	/usr/include/boost/proto/traits.hpp	/^            struct if_else_$/;"	s	namespace:boost::proto::op	inherits:proto::transform
boost::proto::op::if_else_::impl	/usr/include/boost/proto/traits.hpp	/^                struct impl$/;"	s	struct:boost::proto::op::if_else_	inherits:detail::pass_through_impl	access:public
boost::proto::op::if_else_::proto_base_expr	/usr/include/boost/proto/traits.hpp	/^                typedef type proto_base_expr;$/;"	t	struct:boost::proto::op::if_else_	access:public
boost::proto::op::if_else_::proto_child0	/usr/include/boost/proto/traits.hpp	/^                typedef T proto_child0;$/;"	t	struct:boost::proto::op::if_else_	access:public
boost::proto::op::if_else_::proto_child1	/usr/include/boost/proto/traits.hpp	/^                typedef U proto_child1;$/;"	t	struct:boost::proto::op::if_else_	access:public
boost::proto::op::if_else_::proto_child2	/usr/include/boost/proto/traits.hpp	/^                typedef V proto_child2;$/;"	t	struct:boost::proto::op::if_else_	access:public
boost::proto::op::if_else_::proto_tag	/usr/include/boost/proto/traits.hpp	/^                typedef proto::tag::if_else_ proto_tag;$/;"	t	struct:boost::proto::op::if_else_	access:public
boost::proto::op::if_else_::type	/usr/include/boost/proto/traits.hpp	/^                typedef proto::expr<proto::tag::if_else_, list3<T, U, V>, 3> type;$/;"	t	struct:boost::proto::op::if_else_	access:public
boost::proto::op::nullary_expr	/usr/include/boost/proto/traits.hpp	/^            struct nullary_expr$/;"	s	namespace:boost::proto::op	inherits:proto::transform
boost::proto::op::nullary_expr::impl	/usr/include/boost/proto/traits.hpp	/^                struct impl : transform_impl<Expr, State, Data>$/;"	s	struct:boost::proto::op::nullary_expr	inherits:transform_impl	access:public
boost::proto::op::nullary_expr::impl::operator ()	/usr/include/boost/proto/traits.hpp	/^                    operator ()($/;"	f	struct:boost::proto::op::nullary_expr::impl	access:public	signature:( typename impl::expr_param e , typename impl::state_param , typename impl::data_param ) const
boost::proto::op::nullary_expr::impl::result_type	/usr/include/boost/proto/traits.hpp	/^                    typedef Expr result_type;$/;"	t	struct:boost::proto::op::nullary_expr::impl	access:public
boost::proto::op::nullary_expr::proto_base_expr	/usr/include/boost/proto/traits.hpp	/^                typedef type proto_base_expr;$/;"	t	struct:boost::proto::op::nullary_expr	access:public
boost::proto::op::nullary_expr::proto_child0	/usr/include/boost/proto/traits.hpp	/^                typedef T proto_child0;$/;"	t	struct:boost::proto::op::nullary_expr	access:public
boost::proto::op::nullary_expr::proto_tag	/usr/include/boost/proto/traits.hpp	/^                typedef Tag proto_tag;$/;"	t	struct:boost::proto::op::nullary_expr	access:public
boost::proto::op::nullary_expr::type	/usr/include/boost/proto/traits.hpp	/^                typedef proto::expr<Tag, term<T>, 0> type;$/;"	t	struct:boost::proto::op::nullary_expr	access:public
boost::proto::op::terminal	/usr/include/boost/proto/traits.hpp	/^            struct terminal$/;"	s	namespace:boost::proto::op	inherits:proto::transform
boost::proto::op::terminal::impl	/usr/include/boost/proto/traits.hpp	/^                struct impl : transform_impl<Expr, State, Data>$/;"	s	struct:boost::proto::op::terminal	inherits:transform_impl	access:public
boost::proto::op::terminal::impl::operator ()	/usr/include/boost/proto/traits.hpp	/^                    operator ()($/;"	f	struct:boost::proto::op::terminal::impl	access:public	signature:( typename impl::expr_param e , typename impl::state_param , typename impl::data_param ) const
boost::proto::op::terminal::impl::result_type	/usr/include/boost/proto/traits.hpp	/^                    typedef Expr result_type;$/;"	t	struct:boost::proto::op::terminal::impl	access:public
boost::proto::op::terminal::proto_base_expr	/usr/include/boost/proto/traits.hpp	/^                typedef type proto_base_expr;$/;"	t	struct:boost::proto::op::terminal	access:public
boost::proto::op::terminal::proto_child0	/usr/include/boost/proto/traits.hpp	/^                typedef T proto_child0;$/;"	t	struct:boost::proto::op::terminal	access:public
boost::proto::op::terminal::proto_tag	/usr/include/boost/proto/traits.hpp	/^                typedef proto::tag::terminal proto_tag;$/;"	t	struct:boost::proto::op::terminal	access:public
boost::proto::op::terminal::type	/usr/include/boost/proto/traits.hpp	/^                typedef proto::expr<proto::tag::terminal, term<T>, 0> type;$/;"	t	struct:boost::proto::op::terminal	access:public
boost::proto::op::unary_expr	/usr/include/boost/proto/traits.hpp	/^            struct unary_expr$/;"	s	namespace:boost::proto::op	inherits:proto::transform
boost::proto::op::unary_expr::impl	/usr/include/boost/proto/traits.hpp	/^                struct impl$/;"	s	struct:boost::proto::op::unary_expr	inherits:detail::pass_through_impl	access:public
boost::proto::op::unary_expr::proto_base_expr	/usr/include/boost/proto/traits.hpp	/^                typedef type proto_base_expr;$/;"	t	struct:boost::proto::op::unary_expr	access:public
boost::proto::op::unary_expr::proto_child0	/usr/include/boost/proto/traits.hpp	/^                typedef T proto_child0;$/;"	t	struct:boost::proto::op::unary_expr	access:public
boost::proto::op::unary_expr::proto_tag	/usr/include/boost/proto/traits.hpp	/^                typedef Tag proto_tag;$/;"	t	struct:boost::proto::op::unary_expr	access:public
boost::proto::op::unary_expr::type	/usr/include/boost/proto/traits.hpp	/^                typedef proto::expr<Tag, list1<T>, 1> type;$/;"	t	struct:boost::proto::op::unary_expr	access:public
boost::proto::otherwise	/usr/include/boost/proto/transform/when.hpp	/^        struct otherwise$/;"	s	namespace:boost::proto	inherits:when
boost::proto::pass_through	/usr/include/boost/proto/transform/pass_through.hpp	/^        struct pass_through$/;"	s	namespace:boost::proto	inherits:transform
boost::proto::pass_through::impl	/usr/include/boost/proto/transform/pass_through.hpp	/^            struct impl$/;"	s	struct:boost::proto::pass_through	inherits:detail::pass_through_impl	access:public
boost::proto::protect	/usr/include/boost/proto/transform/make.hpp	/^        struct protect : transform<protect<PrimitiveTransform> >$/;"	s	namespace:boost::proto	inherits:transform
boost::proto::protect::impl	/usr/include/boost/proto/transform/make.hpp	/^            struct impl$/;"	s	struct:boost::proto::protect	access:public
boost::proto::protect::impl::result_type	/usr/include/boost/proto/transform/make.hpp	/^                typedef PrimitiveTransform result_type;$/;"	t	struct:boost::proto::protect::impl	access:public
boost::proto::proto::detail::flatten	/usr/include/boost/proto/fusion.hpp	/^    flatten(Expr &e)$/;"	f	class:boost::proto::proto::detail	signature:(Expr &e)
boost::proto::proto::detail::flatten	/usr/include/boost/proto/fusion.hpp	/^    flatten(Expr const &e)$/;"	f	class:boost::proto::proto::detail	signature:(Expr const &e)
boost::proto::result_of	/usr/include/boost/proto/deep_copy.hpp	/^        namespace result_of$/;"	n	namespace:boost::proto
boost::proto::result_of	/usr/include/boost/proto/domain.hpp	/^    namespace result_of$/;"	n	namespace:boost::proto
boost::proto::result_of	/usr/include/boost/proto/eval.hpp	/^    namespace result_of$/;"	n	namespace:boost::proto
boost::proto::result_of	/usr/include/boost/proto/expr.hpp	/^        namespace result_of$/;"	n	namespace:boost::proto
boost::proto::result_of	/usr/include/boost/proto/fusion.hpp	/^    namespace result_of$/;"	n	namespace:boost::proto
boost::proto::result_of	/usr/include/boost/proto/make_expr.hpp	/^        namespace result_of$/;"	n	namespace:boost::proto
boost::proto::result_of	/usr/include/boost/proto/matches.hpp	/^        namespace result_of$/;"	n	namespace:boost::proto
boost::proto::result_of	/usr/include/boost/proto/proto_fwd.hpp	/^    namespace result_of$/;"	n	namespace:boost::proto
boost::proto::result_of	/usr/include/boost/proto/traits.hpp	/^        namespace result_of$/;"	n	namespace:boost::proto
boost::proto::result_of::arity_of	/usr/include/boost/proto/traits.hpp	/^            struct arity_of$/;"	s	namespace:boost::proto::result_of	inherits:Expr::proto_arity
boost::proto::result_of::arity_of	/usr/include/boost/proto/traits.hpp	/^            struct arity_of<Expr &>$/;"	s	namespace:boost::proto::result_of	inherits:Expr::proto_arity
boost::proto::result_of::as_child	/usr/include/boost/proto/traits.hpp	/^            struct as_child$/;"	s	namespace:boost::proto::result_of
boost::proto::result_of::as_child	/usr/include/boost/proto/traits.hpp	/^            struct as_child<$/;"	s	namespace:boost::proto::result_of
boost::proto::result_of::as_child::call	/usr/include/boost/proto/traits.hpp	/^                static T2 &call(T2 &t)$/;"	f	struct:boost::proto::result_of::as_child	access:public	signature:(T2 &t)
boost::proto::result_of::as_child::call	/usr/include/boost/proto/traits.hpp	/^                static type call(T2 &t)$/;"	f	struct:boost::proto::result_of::as_child	access:public	signature:(T2 &t)
boost::proto::result_of::as_child::expr_	/usr/include/boost/proto/traits.hpp	/^                typedef proto::expr<proto::tag::terminal, term<T &>, 0> expr_;$/;"	t	struct:boost::proto::result_of::as_child	access:public
boost::proto::result_of::as_child::type	/usr/include/boost/proto/traits.hpp	/^                typedef T &type;$/;"	t	struct:boost::proto::result_of::as_child	access:public
boost::proto::result_of::as_child::type	/usr/include/boost/proto/traits.hpp	/^                typedef typename Domain::template result<Domain(expr_)>::type type;$/;"	t	struct:boost::proto::result_of::as_child	access:public
boost::proto::result_of::as_child::type	/usr/include/boost/proto/traits.hpp	/^                typedef typename Domain::template result<Domain(typename T::proto_derived_expr)>::type type;$/;"	t	struct:boost::proto::result_of::as_child	access:public
boost::proto::result_of::as_expr	/usr/include/boost/proto/traits.hpp	/^            struct as_expr$/;"	s	namespace:boost::proto::result_of
boost::proto::result_of::as_expr	/usr/include/boost/proto/traits.hpp	/^            struct as_expr<$/;"	s	namespace:boost::proto::result_of
boost::proto::result_of::as_expr::arg0_	/usr/include/boost/proto/traits.hpp	/^                arg0_;$/;"	t	struct:boost::proto::result_of::as_expr	access:public
boost::proto::result_of::as_expr::call	/usr/include/boost/proto/traits.hpp	/^                static reference call(T2 &t)$/;"	f	struct:boost::proto::result_of::as_expr	access:public	signature:(T2 &t)
boost::proto::result_of::as_expr::call	/usr/include/boost/proto/traits.hpp	/^                static T2 &call(T2 &t)$/;"	f	struct:boost::proto::result_of::as_expr	access:public	signature:(T2 &t)
boost::proto::result_of::as_expr::expr_	/usr/include/boost/proto/traits.hpp	/^                typedef proto::expr<proto::tag::terminal, term<arg0_>, 0> expr_;$/;"	t	struct:boost::proto::result_of::as_expr	access:public
boost::proto::result_of::as_expr::expr_	/usr/include/boost/proto/traits.hpp	/^                typedef typename T::proto_derived_expr expr_; \/\/ removes the const$/;"	t	struct:boost::proto::result_of::as_expr	access:public
boost::proto::result_of::as_expr::reference	/usr/include/boost/proto/traits.hpp	/^                typedef T &reference;$/;"	t	struct:boost::proto::result_of::as_expr	access:public
boost::proto::result_of::as_expr::reference	/usr/include/boost/proto/traits.hpp	/^                typedef type const reference;$/;"	t	struct:boost::proto::result_of::as_expr	access:public
boost::proto::result_of::as_expr::type	/usr/include/boost/proto/traits.hpp	/^                typedef typename Domain::template result<Domain(expr_)>::type type;$/;"	t	struct:boost::proto::result_of::as_expr	access:public
boost::proto::result_of::as_expr::type	/usr/include/boost/proto/traits.hpp	/^                typedef typename T::proto_derived_expr type; \/\/ removes the const$/;"	t	struct:boost::proto::result_of::as_expr	access:public
boost::proto::result_of::child	/usr/include/boost/proto/traits.hpp	/^            struct child$/;"	s	namespace:boost::proto::result_of	inherits:child_c
boost::proto::result_of::deep_copy	/usr/include/boost/proto/deep_copy.hpp	/^            struct deep_copy$/;"	s	namespace:boost::proto::result_of
boost::proto::result_of::deep_copy::type	/usr/include/boost/proto/deep_copy.hpp	/^                type;$/;"	t	struct:boost::proto::result_of::deep_copy	access:public
boost::proto::result_of::domain_of	/usr/include/boost/proto/domain.hpp	/^        struct domain_of$/;"	s	namespace:boost::proto::result_of
boost::proto::result_of::domain_of	/usr/include/boost/proto/domain.hpp	/^        struct domain_of<boost::reference_wrapper<T> const, void>$/;"	s	namespace:boost::proto::result_of
boost::proto::result_of::domain_of	/usr/include/boost/proto/domain.hpp	/^        struct domain_of<boost::reference_wrapper<T>, void>$/;"	s	namespace:boost::proto::result_of
boost::proto::result_of::domain_of	/usr/include/boost/proto/domain.hpp	/^        struct domain_of<T &, void>$/;"	s	namespace:boost::proto::result_of
boost::proto::result_of::domain_of	/usr/include/boost/proto/domain.hpp	/^        struct domain_of<T, typename T::proto_is_expr_>$/;"	s	namespace:boost::proto::result_of
boost::proto::result_of::domain_of::type	/usr/include/boost/proto/domain.hpp	/^            typedef default_domain type;$/;"	t	struct:boost::proto::result_of::domain_of	access:public
boost::proto::result_of::domain_of::type	/usr/include/boost/proto/domain.hpp	/^            typedef typename domain_of<T>::type type;$/;"	t	struct:boost::proto::result_of::domain_of	access:public
boost::proto::result_of::domain_of::type	/usr/include/boost/proto/domain.hpp	/^            typedef typename T::proto_domain type;$/;"	t	struct:boost::proto::result_of::domain_of	access:public
boost::proto::result_of::eval	/usr/include/boost/proto/eval.hpp	/^        struct eval$/;"	s	namespace:boost::proto::result_of
boost::proto::result_of::eval::type	/usr/include/boost/proto/eval.hpp	/^            typedef typename Context::template eval<Expr>::result_type type;$/;"	t	struct:boost::proto::result_of::eval	access:public
boost::proto::result_of::flatten	/usr/include/boost/proto/fusion.hpp	/^        struct flatten$/;"	s	namespace:boost::proto::result_of	inherits:flatten
boost::proto::result_of::flatten	/usr/include/boost/proto/fusion.hpp	/^        struct flatten<Expr &>$/;"	s	namespace:boost::proto::result_of
boost::proto::result_of::flatten::type	/usr/include/boost/proto/fusion.hpp	/^            typedef detail::flat_view<Expr> type;$/;"	t	struct:boost::proto::result_of::flatten	access:public
boost::proto::result_of::is_domain	/usr/include/boost/proto/domain.hpp	/^        struct is_domain$/;"	s	namespace:boost::proto::result_of	inherits:mpl::false_
boost::proto::result_of::is_domain	/usr/include/boost/proto/domain.hpp	/^        struct is_domain<T, typename T::proto_is_domain_>$/;"	s	namespace:boost::proto::result_of	inherits:mpl::true_
boost::proto::result_of::is_expr	/usr/include/boost/proto/traits.hpp	/^            struct is_expr$/;"	s	namespace:boost::proto::result_of	inherits:mpl::false_
boost::proto::result_of::is_expr	/usr/include/boost/proto/traits.hpp	/^            struct is_expr<T &, void>$/;"	s	namespace:boost::proto::result_of	inherits:is_expr
boost::proto::result_of::is_expr	/usr/include/boost/proto/traits.hpp	/^            struct is_expr<T, typename T::proto_is_expr_>$/;"	s	namespace:boost::proto::result_of	inherits:mpl::true_
boost::proto::result_of::left	/usr/include/boost/proto/traits.hpp	/^            struct left$/;"	s	namespace:boost::proto::result_of	inherits:child_c
boost::proto::result_of::make_expr	/usr/include/boost/proto/make_expr.hpp	/^            struct make_expr$/;"	s	namespace:boost::proto::result_of
boost::proto::result_of::make_expr	/usr/include/boost/proto/make_expr.hpp	/^            struct make_expr<$/;"	s	namespace:boost::proto::result_of
boost::proto::result_of::make_expr::make_expr	/usr/include/boost/proto/make_expr.hpp	/^        make_expr(C0 const &c0)$/;"	f	class:boost::proto::result_of::make_expr	signature:(C0 const &c0)
boost::proto::result_of::make_expr::type	/usr/include/boost/proto/make_expr.hpp	/^                type;$/;"	t	struct:boost::proto::result_of::make_expr	access:public
boost::proto::result_of::matches	/usr/include/boost/proto/matches.hpp	/^            struct matches$/;"	s	namespace:boost::proto::result_of	inherits:detail::matches_
boost::proto::result_of::matches	/usr/include/boost/proto/matches.hpp	/^            struct matches<Expr &, Grammar>$/;"	s	namespace:boost::proto::result_of	inherits:detail::matches_
boost::proto::result_of::right	/usr/include/boost/proto/traits.hpp	/^            struct right$/;"	s	namespace:boost::proto::result_of	inherits:child_c
boost::proto::result_of::tag_of	/usr/include/boost/proto/traits.hpp	/^            struct tag_of$/;"	s	namespace:boost::proto::result_of
boost::proto::result_of::tag_of	/usr/include/boost/proto/traits.hpp	/^            struct tag_of<Expr &>$/;"	s	namespace:boost::proto::result_of
boost::proto::result_of::tag_of::type	/usr/include/boost/proto/traits.hpp	/^                typedef typename Expr::proto_tag type;$/;"	t	struct:boost::proto::result_of::tag_of	access:public
boost::proto::result_of::unpack_expr	/usr/include/boost/proto/make_expr.hpp	/^            struct unpack_expr$/;"	s	namespace:boost::proto::result_of
boost::proto::result_of::unpack_expr	/usr/include/boost/proto/make_expr.hpp	/^            struct unpack_expr<Tag, Domain, Sequence, typename Domain::proto_is_domain_>$/;"	s	namespace:boost::proto::result_of
boost::proto::result_of::unpack_expr::type	/usr/include/boost/proto/make_expr.hpp	/^                type;$/;"	t	struct:boost::proto::result_of::unpack_expr	access:public
boost::proto::result_of::unpack_expr::unpack_expr	/usr/include/boost/proto/make_expr.hpp	/^        unpack_expr(Sequence2 const &sequence2)$/;"	f	class:boost::proto::result_of::unpack_expr	signature:(Sequence2 const &sequence2)
boost::proto::result_of::value	/usr/include/boost/proto/traits.hpp	/^            struct value$/;"	s	namespace:boost::proto::result_of
boost::proto::result_of::value	/usr/include/boost/proto/traits.hpp	/^            struct value<Expr &>$/;"	s	namespace:boost::proto::result_of
boost::proto::result_of::value	/usr/include/boost/proto/traits.hpp	/^            struct value<Expr const &>$/;"	s	namespace:boost::proto::result_of
boost::proto::result_of::value::type	/usr/include/boost/proto/traits.hpp	/^                typedef typename detail::term_traits<typename Expr::proto_child0>::const_reference type;$/;"	t	struct:boost::proto::result_of::value	access:public
boost::proto::result_of::value::type	/usr/include/boost/proto/traits.hpp	/^                typedef typename detail::term_traits<typename Expr::proto_child0>::reference type;$/;"	t	struct:boost::proto::result_of::value	access:public
boost::proto::result_of::value::type	/usr/include/boost/proto/traits.hpp	/^                typedef typename detail::term_traits<typename Expr::proto_child0>::value_type type;$/;"	t	struct:boost::proto::result_of::value	access:public
boost::proto::result_of::value::value_type	/usr/include/boost/proto/traits.hpp	/^                typedef typename Expr::proto_child0 value_type;$/;"	t	struct:boost::proto::result_of::value	access:public
boost::proto::reverse_fold	/usr/include/boost/proto/transform/fold.hpp	/^        struct reverse_fold$/;"	s	namespace:boost::proto	inherits:fold
boost::proto::reverse_fold	/usr/include/boost/proto/transform/fold.hpp	/^        struct reverse_fold<_, State0, Fun> : transform<reverse_fold<_, State0, Fun> >$/;"	s	namespace:boost::proto	inherits:transform
boost::proto::reverse_fold::impl	/usr/include/boost/proto/transform/fold.hpp	/^            struct impl$/;"	s	struct:boost::proto::reverse_fold	inherits:detail::reverse_fold_impl	access:public
boost::proto::reverse_fold_tree	/usr/include/boost/proto/transform/fold_tree.hpp	/^    struct reverse_fold_tree$/;"	s	namespace:boost::proto	inherits:transform
boost::proto::reverse_fold_tree::impl	/usr/include/boost/proto/transform/fold_tree.hpp	/^        struct impl$/;"	s	struct:boost::proto::reverse_fold_tree	inherits:reverse_fold::,impl	access:public
boost::proto::right	/usr/include/boost/proto/traits.hpp	/^        right(Expr const &e)$/;"	f	namespace:boost::proto	signature:(Expr const &e)
boost::proto::tag	/usr/include/boost/proto/debug.hpp	/^    namespace tag$/;"	n	namespace:boost::proto
boost::proto::tag	/usr/include/boost/proto/proto_fwd.hpp	/^    namespace tag$/;"	n	namespace:boost::proto
boost::proto::tag	/usr/include/boost/proto/tags.hpp	/^namespace boost { namespace proto { namespace tag$/;"	n	namespace:boost::proto
boost::proto::tag::address_of	/usr/include/boost/proto/tags.hpp	/^    struct address_of {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::assign	/usr/include/boost/proto/tags.hpp	/^    struct assign {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::bitwise_and	/usr/include/boost/proto/tags.hpp	/^    struct bitwise_and {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::bitwise_and_assign	/usr/include/boost/proto/tags.hpp	/^    struct bitwise_and_assign {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::bitwise_or	/usr/include/boost/proto/tags.hpp	/^    struct bitwise_or {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::bitwise_or_assign	/usr/include/boost/proto/tags.hpp	/^    struct bitwise_or_assign {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::bitwise_xor	/usr/include/boost/proto/tags.hpp	/^    struct bitwise_xor {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::bitwise_xor_assign	/usr/include/boost/proto/tags.hpp	/^    struct bitwise_xor_assign {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::comma	/usr/include/boost/proto/tags.hpp	/^    struct comma {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::complement	/usr/include/boost/proto/tags.hpp	/^    struct complement {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::dereference	/usr/include/boost/proto/tags.hpp	/^    struct dereference {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::divides	/usr/include/boost/proto/tags.hpp	/^    struct divides {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::divides_assign	/usr/include/boost/proto/tags.hpp	/^    struct divides_assign {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::equal_to	/usr/include/boost/proto/tags.hpp	/^    struct equal_to {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::function	/usr/include/boost/proto/tags.hpp	/^    struct function {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::greater	/usr/include/boost/proto/tags.hpp	/^    struct greater {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::greater_equal	/usr/include/boost/proto/tags.hpp	/^    struct greater_equal {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::hidden_detail_	/usr/include/boost/proto/debug.hpp	/^        namespace hidden_detail_$/;"	n	namespace:boost::proto::tag
boost::proto::tag::hidden_detail_::not_ostream	/usr/include/boost/proto/debug.hpp	/^            typedef char (&not_ostream)[sizeof(std::ostream)+1];$/;"	t	namespace:boost::proto::tag::hidden_detail_
boost::proto::tag::hidden_detail_::operator <<	/usr/include/boost/proto/debug.hpp	/^            not_ostream operator<<(std::ostream &, detail::dont_care);$/;"	p	namespace:boost::proto::tag::hidden_detail_	signature:(std::ostream &, detail::dont_care)
boost::proto::tag::hidden_detail_::printable_tag_	/usr/include/boost/proto/debug.hpp	/^            struct printable_tag_$/;"	s	namespace:boost::proto::tag::hidden_detail_
boost::proto::tag::hidden_detail_::printable_tag_	/usr/include/boost/proto/debug.hpp	/^            struct printable_tag_<Tag, sizeof(std::ostream)>$/;"	s	namespace:boost::proto::tag::hidden_detail_
boost::proto::tag::hidden_detail_::printable_tag_::call	/usr/include/boost/proto/debug.hpp	/^                static type call() { return Tag(); }$/;"	f	struct:boost::proto::tag::hidden_detail_::printable_tag_	access:public	signature:()
boost::proto::tag::hidden_detail_::printable_tag_::call	/usr/include/boost/proto/debug.hpp	/^                static type call() { return typeid(Tag).name(); }$/;"	f	struct:boost::proto::tag::hidden_detail_::printable_tag_	access:public	signature:()
boost::proto::tag::hidden_detail_::printable_tag_::type	/usr/include/boost/proto/debug.hpp	/^                typedef char const *type;$/;"	t	struct:boost::proto::tag::hidden_detail_::printable_tag_	access:public
boost::proto::tag::hidden_detail_::printable_tag_::type	/usr/include/boost/proto/debug.hpp	/^                typedef Tag type;$/;"	t	struct:boost::proto::tag::hidden_detail_::printable_tag_	access:public
boost::proto::tag::if_else_	/usr/include/boost/proto/tags.hpp	/^    struct if_else_ {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::less	/usr/include/boost/proto/tags.hpp	/^    struct less {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::less_equal	/usr/include/boost/proto/tags.hpp	/^    struct less_equal {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::logical_and	/usr/include/boost/proto/tags.hpp	/^    struct logical_and {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::logical_not	/usr/include/boost/proto/tags.hpp	/^    struct logical_not {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::logical_or	/usr/include/boost/proto/tags.hpp	/^    struct logical_or {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::member	/usr/include/boost/proto/tags.hpp	/^    struct member {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::mem_ptr	/usr/include/boost/proto/tags.hpp	/^    struct mem_ptr {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::minus	/usr/include/boost/proto/tags.hpp	/^    struct minus {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::minus_assign	/usr/include/boost/proto/tags.hpp	/^    struct minus_assign {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::modulus	/usr/include/boost/proto/tags.hpp	/^    struct modulus {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::modulus_assign	/usr/include/boost/proto/tags.hpp	/^    struct modulus_assign {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::multiplies	/usr/include/boost/proto/tags.hpp	/^    struct multiplies {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::multiplies_assign	/usr/include/boost/proto/tags.hpp	/^    struct multiplies_assign {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::negate	/usr/include/boost/proto/tags.hpp	/^    struct negate {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::not_equal_to	/usr/include/boost/proto/tags.hpp	/^    struct not_equal_to {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::plus	/usr/include/boost/proto/tags.hpp	/^    struct plus {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::plus_assign	/usr/include/boost/proto/tags.hpp	/^    struct plus_assign {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::post_dec	/usr/include/boost/proto/tags.hpp	/^    struct post_dec {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::post_inc	/usr/include/boost/proto/tags.hpp	/^    struct post_inc {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::pre_dec	/usr/include/boost/proto/tags.hpp	/^    struct pre_dec {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::pre_inc	/usr/include/boost/proto/tags.hpp	/^    struct pre_inc {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::shift_left	/usr/include/boost/proto/tags.hpp	/^    struct shift_left {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::shift_left_assign	/usr/include/boost/proto/tags.hpp	/^    struct shift_left_assign {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::shift_right	/usr/include/boost/proto/tags.hpp	/^    struct shift_right {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::shift_right_assign	/usr/include/boost/proto/tags.hpp	/^    struct shift_right_assign {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::subscript	/usr/include/boost/proto/tags.hpp	/^    struct subscript {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::terminal	/usr/include/boost/proto/tags.hpp	/^    struct terminal {};$/;"	s	namespace:boost::proto::tag
boost::proto::tag::unary_plus	/usr/include/boost/proto/tags.hpp	/^    struct unary_plus {};$/;"	s	namespace:boost::proto::tag
boost::proto::transform	/usr/include/boost/proto/transform/impl.hpp	/^    struct transform$/;"	s	namespace:boost::proto
boost::proto::transform_impl	/usr/include/boost/proto/transform/impl.hpp	/^    struct transform_impl$/;"	s	namespace:boost::proto
boost::proto::transform_impl	/usr/include/boost/proto/transform/impl.hpp	/^    struct transform_impl<Expr &, State &, Data &>$/;"	s	namespace:boost::proto
boost::proto::transform_impl	/usr/include/boost/proto/transform/impl.hpp	/^    struct transform_impl<Expr &, State &, Data>$/;"	s	namespace:boost::proto
boost::proto::transform_impl	/usr/include/boost/proto/transform/impl.hpp	/^    struct transform_impl<Expr &, State, Data &>$/;"	s	namespace:boost::proto
boost::proto::transform_impl	/usr/include/boost/proto/transform/impl.hpp	/^    struct transform_impl<Expr &, State, Data>$/;"	s	namespace:boost::proto
boost::proto::transform_impl	/usr/include/boost/proto/transform/impl.hpp	/^    struct transform_impl<Expr, State &, Data &>$/;"	s	namespace:boost::proto
boost::proto::transform_impl	/usr/include/boost/proto/transform/impl.hpp	/^    struct transform_impl<Expr, State &, Data>$/;"	s	namespace:boost::proto
boost::proto::transform_impl	/usr/include/boost/proto/transform/impl.hpp	/^    struct transform_impl<Expr, State, Data &>$/;"	s	namespace:boost::proto
boost::proto::transform_impl::data	/usr/include/boost/proto/transform/impl.hpp	/^        typedef Data const data;$/;"	t	struct:boost::proto::transform_impl	access:public
boost::proto::transform_impl::data	/usr/include/boost/proto/transform/impl.hpp	/^        typedef Data data;$/;"	t	struct:boost::proto::transform_impl	access:public
boost::proto::transform_impl::data_param	/usr/include/boost/proto/transform/impl.hpp	/^        typedef Data &data_param;$/;"	t	struct:boost::proto::transform_impl	access:public
boost::proto::transform_impl::data_param	/usr/include/boost/proto/transform/impl.hpp	/^        typedef Data const &data_param;$/;"	t	struct:boost::proto::transform_impl	access:public
boost::proto::transform_impl::expr	/usr/include/boost/proto/transform/impl.hpp	/^        typedef Expr const expr;$/;"	t	struct:boost::proto::transform_impl	access:public
boost::proto::transform_impl::expr	/usr/include/boost/proto/transform/impl.hpp	/^        typedef Expr expr;$/;"	t	struct:boost::proto::transform_impl	access:public
boost::proto::transform_impl::expr_param	/usr/include/boost/proto/transform/impl.hpp	/^        typedef Expr &expr_param;$/;"	t	struct:boost::proto::transform_impl	access:public
boost::proto::transform_impl::expr_param	/usr/include/boost/proto/transform/impl.hpp	/^        typedef Expr const &expr_param;$/;"	t	struct:boost::proto::transform_impl	access:public
boost::proto::transform_impl::state	/usr/include/boost/proto/transform/impl.hpp	/^        typedef State const state;$/;"	t	struct:boost::proto::transform_impl	access:public
boost::proto::transform_impl::state	/usr/include/boost/proto/transform/impl.hpp	/^        typedef State state;$/;"	t	struct:boost::proto::transform_impl	access:public
boost::proto::transform_impl::state_param	/usr/include/boost/proto/transform/impl.hpp	/^        typedef State &state_param;$/;"	t	struct:boost::proto::transform_impl	access:public
boost::proto::transform_impl::state_param	/usr/include/boost/proto/transform/impl.hpp	/^        typedef State const &state_param;$/;"	t	struct:boost::proto::transform_impl	access:public
boost::proto::unexpr	/usr/include/boost/proto/expr.hpp	/^        struct unexpr$/;"	s	namespace:boost::proto	inherits:Expr
boost::proto::unexpr::unexpr	/usr/include/boost/proto/expr.hpp	/^            explicit unexpr(Expr const &e)$/;"	f	struct:boost::proto::unexpr	access:public	signature:(Expr const &e)
boost::proto::utility	/usr/include/boost/proto/literal.hpp	/^    namespace utility$/;"	n	namespace:boost::proto
boost::proto::utility	/usr/include/boost/proto/proto_fwd.hpp	/^    namespace utility$/;"	n	namespace:boost::proto
boost::proto::utility::literal	/usr/include/boost/proto/literal.hpp	/^        struct literal$/;"	s	namespace:boost::proto::utility	inherits:extends
boost::proto::utility::literal::base_type	/usr/include/boost/proto/literal.hpp	/^            typedef extends<terminal_type, literal<T, Domain>, Domain> base_type;$/;"	t	struct:boost::proto::utility::literal	access:private
boost::proto::utility::literal::const_reference	/usr/include/boost/proto/literal.hpp	/^            typedef typename detail::term_traits<T>::const_reference  const_reference;$/;"	t	struct:boost::proto::utility::literal	access:public
boost::proto::utility::literal::get	/usr/include/boost/proto/literal.hpp	/^            const_reference get() const$/;"	f	struct:boost::proto::utility::literal	access:public	signature:() const
boost::proto::utility::literal::get	/usr/include/boost/proto/literal.hpp	/^            reference get()$/;"	f	struct:boost::proto::utility::literal	access:public	signature:()
boost::proto::utility::literal::literal	/usr/include/boost/proto/literal.hpp	/^            literal(literal<U, Domain> const &u)$/;"	f	struct:boost::proto::utility::literal	access:public	signature:(literal<U, Domain> const &u)
boost::proto::utility::literal::literal	/usr/include/boost/proto/literal.hpp	/^            literal(U &u)$/;"	f	struct:boost::proto::utility::literal	access:public	signature:(U &u)
boost::proto::utility::literal::literal	/usr/include/boost/proto/literal.hpp	/^            literal(U const &u)$/;"	f	struct:boost::proto::utility::literal	access:public	signature:(U const &u)
boost::proto::utility::literal::reference	/usr/include/boost/proto/literal.hpp	/^            typedef typename detail::term_traits<T>::reference        reference;$/;"	t	struct:boost::proto::utility::literal	access:public
boost::proto::utility::literal::terminal_type	/usr/include/boost/proto/literal.hpp	/^            typedef expr<tag::terminal, term<T>, 0> terminal_type;$/;"	t	struct:boost::proto::utility::literal	access:private
boost::proto::utility::literal::value_type	/usr/include/boost/proto/literal.hpp	/^            typedef typename detail::term_traits<T>::value_type       value_type;$/;"	t	struct:boost::proto::utility::literal	access:public
boost::proto::value	/usr/include/boost/proto/traits.hpp	/^        value(Expr const &e)$/;"	f	namespace:boost::proto	signature:(Expr const &e)
boost::proto::when	/usr/include/boost/proto/transform/when.hpp	/^        struct when$/;"	s	namespace:boost::proto	inherits:PrimitiveTransform
boost::proto::when	/usr/include/boost/proto/transform/when.hpp	/^        struct when<Grammar, Fun *>$/;"	s	namespace:boost::proto	inherits:when
boost::proto::when::proto_base_expr	/usr/include/boost/proto/transform/when.hpp	/^            typedef typename Grammar::proto_base_expr proto_base_expr;$/;"	t	struct:boost::proto::when	access:public
boost::proto::wildcardns_	/usr/include/boost/proto/matches.hpp	/^        namespace wildcardns_$/;"	n	namespace:boost::proto
boost::proto::wildcardns_	/usr/include/boost/proto/proto_fwd.hpp	/^    namespace wildcardns_$/;"	n	namespace:boost::proto
boost::proto::wildcardns_::_	/usr/include/boost/proto/matches.hpp	/^            struct _ : transform<_>$/;"	s	namespace:boost::proto::wildcardns_	inherits:transform
boost::proto::wildcardns_::_::impl	/usr/include/boost/proto/matches.hpp	/^                struct impl : transform_impl<Expr, State, Data>$/;"	s	struct:boost::proto::wildcardns_::_	inherits:transform_impl	access:public
boost::proto::wildcardns_::_::impl::operator ()	/usr/include/boost/proto/matches.hpp	/^                    operator()($/;"	f	struct:boost::proto::wildcardns_::_::impl	access:public	signature:( typename impl::expr_param e , typename impl::state_param , typename impl::data_param ) const
boost::proto::wildcardns_::_::impl::result_type	/usr/include/boost/proto/matches.hpp	/^                    typedef Expr result_type;$/;"	t	struct:boost::proto::wildcardns_::_::impl	access:public
boost::proto::wildcardns_::_::proto_base_expr	/usr/include/boost/proto/matches.hpp	/^                typedef _ proto_base_expr;$/;"	t	struct:boost::proto::wildcardns_::_	access:public
boost::proto::_byref	/usr/include/boost/proto/transform/arg.hpp	/^    struct _byref : callable$/;"	s	namespace:boost::proto	inherits:callable
boost::proto::_byref::boost::operator ()	/usr/include/boost/proto/transform/arg.hpp	/^        boost::reference_wrapper<T const> const operator ()(T const &t) const$/;"	f	class:boost::proto::_byref::boost	access:public	signature:(T const &t) const
boost::proto::_byref::boost::operator ()	/usr/include/boost/proto/transform/arg.hpp	/^        boost::reference_wrapper<T> const operator ()(T &t) const$/;"	f	class:boost::proto::_byref::boost	access:public	signature:(T &t) const
boost::proto::_byref::result	/usr/include/boost/proto/transform/arg.hpp	/^        struct result<This(T &)>$/;"	s	struct:boost::proto::_byref	access:public
boost::proto::_byref::result	/usr/include/boost/proto/transform/arg.hpp	/^        struct result<This(T)>$/;"	s	struct:boost::proto::_byref	access:public
boost::proto::_byref::result::boost::type	/usr/include/boost/proto/transform/arg.hpp	/^            typedef boost::reference_wrapper<T const> const type;$/;"	t	class:boost::proto::_byref::result::boost	access:public
boost::proto::_byref::result::boost::type	/usr/include/boost/proto/transform/arg.hpp	/^            typedef boost::reference_wrapper<T> const type;$/;"	t	class:boost::proto::_byref::result::boost	access:public
boost::proto::_byval	/usr/include/boost/proto/transform/arg.hpp	/^    struct _byval : callable$/;"	s	namespace:boost::proto	inherits:callable
boost::proto::_byval::operator ()	/usr/include/boost/proto/transform/arg.hpp	/^        T operator ()(boost::reference_wrapper<T> const &t) const$/;"	f	struct:boost::proto::_byval	access:public	signature:(boost::reference_wrapper<T> const &t) const
boost::proto::_byval::operator ()	/usr/include/boost/proto/transform/arg.hpp	/^        T operator ()(T const &t) const$/;"	f	struct:boost::proto::_byval	access:public	signature:(T const &t) const
boost::proto::_byval::result	/usr/include/boost/proto/transform/arg.hpp	/^        struct result<This(boost::reference_wrapper<T>)>$/;"	s	struct:boost::proto::_byval	inherits:result	access:public
boost::proto::_byval::result	/usr/include/boost/proto/transform/arg.hpp	/^        struct result<This(T &)>$/;"	s	struct:boost::proto::_byval	inherits:result	access:public
boost::proto::_byval::result	/usr/include/boost/proto/transform/arg.hpp	/^        struct result<This(T)>$/;"	s	struct:boost::proto::_byval	access:public
boost::proto::_byval::result::type	/usr/include/boost/proto/transform/arg.hpp	/^            typedef T type;$/;"	t	struct:boost::proto::_byval::result	access:public
boost::proto::_child	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef _child0     _child;$/;"	t	namespace:boost::proto
boost::proto::_child0	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef _child_c<0> _child0;$/;"	t	namespace:boost::proto
boost::proto::_child1	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef _child_c<1> _child1;$/;"	t	namespace:boost::proto
boost::proto::_child_c	/usr/include/boost/proto/transform/arg.hpp	/^    struct _child_c : transform<_child_c<N> >$/;"	s	namespace:boost::proto	inherits:transform
boost::proto::_child_c::impl	/usr/include/boost/proto/transform/arg.hpp	/^        struct impl : transform_impl<Expr, State, Data>$/;"	s	struct:boost::proto::_child_c	inherits:transform_impl	access:public
boost::proto::_child_c::impl::operator ()	/usr/include/boost/proto/transform/arg.hpp	/^            operator ()($/;"	f	struct:boost::proto::_child_c::impl	access:public	signature:( typename impl::expr_param e , typename impl::state_param , typename impl::data_param ) const
boost::proto::_child_c::impl::result_type	/usr/include/boost/proto/transform/arg.hpp	/^            result_type;$/;"	t	struct:boost::proto::_child_c::impl	access:public
boost::proto::_data	/usr/include/boost/proto/transform/arg.hpp	/^    struct _data : transform<_data>$/;"	s	namespace:boost::proto	inherits:transform
boost::proto::_data::impl	/usr/include/boost/proto/transform/arg.hpp	/^        struct impl : transform_impl<Expr, State, Data>$/;"	s	struct:boost::proto::_data	inherits:transform_impl	access:public
boost::proto::_data::impl::operator ()	/usr/include/boost/proto/transform/arg.hpp	/^            operator ()($/;"	f	struct:boost::proto::_data::impl	access:public	signature:( typename impl::expr_param , typename impl::state_param , typename impl::data_param d ) const
boost::proto::_data::impl::result_type	/usr/include/boost/proto/transform/arg.hpp	/^            typedef Data result_type;$/;"	t	struct:boost::proto::_data::impl	access:public
boost::proto::_deep_copy	/usr/include/boost/proto/deep_copy.hpp	/^        struct _deep_copy$/;"	s	namespace:boost::proto	inherits:proto::transform
boost::proto::_deep_copy::impl	/usr/include/boost/proto/deep_copy.hpp	/^            struct impl$/;"	s	struct:boost::proto::_deep_copy	inherits:detail::deep_copy_impl	access:public
boost::proto::_default	/usr/include/boost/proto/transform/default.hpp	/^        struct _default$/;"	s	namespace:boost::proto	inherits:transform
boost::proto::_default::impl	/usr/include/boost/proto/transform/default.hpp	/^            struct impl$/;"	s	struct:boost::proto::_default	inherits:impl2	access:public
boost::proto::_default::impl2	/usr/include/boost/proto/transform/default.hpp	/^            struct impl2<Expr, State, Data, Tag, 0>$/;"	s	struct:boost::proto::_default	inherits:_value::impl	access:public
boost::proto::_default::impl2	/usr/include/boost/proto/transform/default.hpp	/^            struct impl2<Expr, State, Data, tag::comma, 2>$/;"	s	struct:boost::proto::_default	inherits:transform_impl	access:public
boost::proto::_default::impl2	/usr/include/boost/proto/transform/default.hpp	/^            struct impl2<Expr, State, Data, tag::function, 1>$/;"	s	struct:boost::proto::_default	inherits:transform_impl	access:public
boost::proto::_default::impl2	/usr/include/boost/proto/transform/default.hpp	/^            struct impl2<Expr, State, Data, tag::function, 2>$/;"	s	struct:boost::proto::_default	inherits:transform_impl	access:public
boost::proto::_default::impl2	/usr/include/boost/proto/transform/default.hpp	/^            struct impl2<Expr, State, Data, tag::if_else_, 3>$/;"	s	struct:boost::proto::_default	inherits:transform_impl	access:public
boost::proto::_default::impl2	/usr/include/boost/proto/transform/default.hpp	/^            struct impl2<Expr, State, Data, tag::mem_ptr, 2>$/;"	s	struct:boost::proto::_default	inherits:memfun_impl	access:public
boost::proto::_default::impl2	/usr/include/boost/proto/transform/default.hpp	/^            struct impl2<Expr, State, Data, tag::post_dec, 1>$/;"	s	struct:boost::proto::_default	inherits:transform_impl	access:public
boost::proto::_default::impl2	/usr/include/boost/proto/transform/default.hpp	/^            struct impl2<Expr, State, Data, tag::post_inc, 1>$/;"	s	struct:boost::proto::_default	inherits:transform_impl	access:public
boost::proto::_default::impl2	/usr/include/boost/proto/transform/default.hpp	/^            struct impl2<Expr, State, Data, tag::subscript, 2>$/;"	s	struct:boost::proto::_default	inherits:transform_impl	access:public
boost::proto::_default::impl2::e0	/usr/include/boost/proto/transform/default.hpp	/^                typedef typename result_of::child_c<Expr, 0>::type e0;$/;"	t	struct:boost::proto::_default::impl2	access:private
boost::proto::_default::impl2::e1	/usr/include/boost/proto/transform/default.hpp	/^                typedef typename result_of::child_c<Expr, 1>::type e1;$/;"	t	struct:boost::proto::_default::impl2	access:private
boost::proto::_default::impl2::e2	/usr/include/boost/proto/transform/default.hpp	/^                typedef typename result_of::child_c<Expr, 2>::type e2;$/;"	t	struct:boost::proto::_default::impl2	access:private
boost::proto::_default::impl2::function_type	/usr/include/boost/proto/transform/default.hpp	/^                function_type;$/;"	t	struct:boost::proto::_default::impl2	access:public
boost::proto::_default::impl2::invoke	/usr/include/boost/proto/transform/default.hpp	/^                result_type invoke($/;"	f	struct:boost::proto::_default::impl2	access:private	signature:( typename impl2::expr_param e , typename impl2::state_param s , typename impl2::data_param d , mpl::false_ , mpl::false_ ) const
boost::proto::_default::impl2::invoke	/usr/include/boost/proto/transform/default.hpp	/^                result_type invoke($/;"	f	struct:boost::proto::_default::impl2	access:private	signature:( typename impl2::expr_param e , typename impl2::state_param s , typename impl2::data_param d , mpl::false_ , mpl::true_ ) const
boost::proto::_default::impl2::invoke	/usr/include/boost/proto/transform/default.hpp	/^                result_type invoke($/;"	f	struct:boost::proto::_default::impl2	access:private	signature:( typename impl2::expr_param e , typename impl2::state_param s , typename impl2::data_param d , mpl::true_ , mpl::false_ ) const
boost::proto::_default::impl2::operator ()	/usr/include/boost/proto/transform/default.hpp	/^                result_type operator ()($/;"	f	struct:boost::proto::_default::impl2	access:public	signature:( typename impl2::expr_param e , typename impl2::state_param s , typename impl2::data_param d ) const
boost::proto::_default::impl2::r0	/usr/include/boost/proto/transform/default.hpp	/^                typedef typename Grammar::template impl<e0, State, Data>::result_type r0;$/;"	t	struct:boost::proto::_default::impl2	access:private
boost::proto::_default::impl2::r1	/usr/include/boost/proto/transform/default.hpp	/^                typedef typename Grammar::template impl<e1, State, Data>::result_type r1;$/;"	t	struct:boost::proto::_default::impl2	access:private
boost::proto::_default::impl2::r2	/usr/include/boost/proto/transform/default.hpp	/^                typedef typename Grammar::template impl<e2, State, Data>::result_type r2;$/;"	t	struct:boost::proto::_default::impl2	access:private
boost::proto::_default::impl2::result_type	/usr/include/boost/proto/transform/default.hpp	/^                result_type;$/;"	t	struct:boost::proto::_default::impl2	access:public
boost::proto::_default::impl2::result_type	/usr/include/boost/proto/transform/default.hpp	/^                typedef typename proto::detail::comma_result<r0, r1>::type result_type;$/;"	t	struct:boost::proto::_default::impl2	access:public
boost::proto::_default::is_member_function_invocation	/usr/include/boost/proto/transform/default.hpp	/^            struct is_member_function_invocation$/;"	s	struct:boost::proto::_default	inherits:is_member_function_pointer	access:public
boost::proto::_default::memfun_impl	/usr/include/boost/proto/transform/default.hpp	/^            struct memfun_impl$/;"	s	struct:boost::proto::_default	inherits:transform_impl	access:public
boost::proto::_default::memfun_impl	/usr/include/boost/proto/transform/default.hpp	/^            struct memfun_impl<Expr, State, Data, true>$/;"	s	struct:boost::proto::_default	inherits:transform_impl	access:public
boost::proto::_default::memfun_impl::e0	/usr/include/boost/proto/transform/default.hpp	/^                typedef typename result_of::child_c<Expr, 0>::type e0;$/;"	t	struct:boost::proto::_default::memfun_impl	access:private
boost::proto::_default::memfun_impl::e1	/usr/include/boost/proto/transform/default.hpp	/^                typedef typename result_of::child_c<Expr, 1>::type e1;$/;"	t	struct:boost::proto::_default::memfun_impl	access:private
boost::proto::_default::memfun_impl::operator ()	/usr/include/boost/proto/transform/default.hpp	/^                result_type const operator ()($/;"	f	struct:boost::proto::_default::memfun_impl	access:public	signature:( typename memfun_impl::expr_param e , typename memfun_impl::state_param s , typename memfun_impl::data_param d ) const
boost::proto::_default::memfun_impl::operator ()	/usr/include/boost/proto/transform/default.hpp	/^                result_type operator ()($/;"	f	struct:boost::proto::_default::memfun_impl	access:public	signature:( typename memfun_impl::expr_param e , typename memfun_impl::state_param s , typename memfun_impl::data_param d ) const
boost::proto::_default::memfun_impl::r0	/usr/include/boost/proto/transform/default.hpp	/^                typedef typename Grammar::template impl<e0, State, Data>::result_type r0;$/;"	t	struct:boost::proto::_default::memfun_impl	access:private
boost::proto::_default::memfun_impl::r1	/usr/include/boost/proto/transform/default.hpp	/^                typedef typename Grammar::template impl<e1, State, Data>::result_type r1;$/;"	t	struct:boost::proto::_default::memfun_impl	access:private
boost::proto::_default::memfun_impl::result_type	/usr/include/boost/proto/transform/default.hpp	/^                typedef detail::memfun<r0, r1> result_type;$/;"	t	struct:boost::proto::_default::memfun_impl	access:public
boost::proto::_default::memfun_impl::result_type	/usr/include/boost/proto/transform/default.hpp	/^                typedef typename detail::mem_ptr_fun<r0, r1>::result_type result_type;$/;"	t	struct:boost::proto::_default::memfun_impl	access:public
boost::proto::_eval	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::eval        _eval;$/;"	t	namespace:boost::proto
boost::proto::_expr	/usr/include/boost/proto/transform/arg.hpp	/^    struct _expr : transform<_expr>$/;"	s	namespace:boost::proto	inherits:transform
boost::proto::_expr::impl	/usr/include/boost/proto/transform/arg.hpp	/^        struct impl : transform_impl<Expr, State, Data>$/;"	s	struct:boost::proto::_expr	inherits:transform_impl	access:public
boost::proto::_expr::impl::operator ()	/usr/include/boost/proto/transform/arg.hpp	/^            operator()($/;"	f	struct:boost::proto::_expr::impl	access:public	signature:( typename impl::expr_param e , typename impl::state_param , typename impl::data_param ) const
boost::proto::_expr::impl::result_type	/usr/include/boost/proto/transform/arg.hpp	/^            typedef Expr result_type;$/;"	t	struct:boost::proto::_expr::impl	access:public
boost::proto::_flatten	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::flatten     _flatten;$/;"	t	namespace:boost::proto
boost::proto::_left	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef _child0     _left;$/;"	t	namespace:boost::proto
boost::proto::_make_address_of	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::address_of>         _make_address_of;$/;"	t	namespace:boost::proto
boost::proto::_make_assign	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::assign>             _make_assign;$/;"	t	namespace:boost::proto
boost::proto::_make_bitwise_and	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::bitwise_and>        _make_bitwise_and;$/;"	t	namespace:boost::proto
boost::proto::_make_bitwise_and_assign	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::bitwise_and_assign> _make_bitwise_and_assign;$/;"	t	namespace:boost::proto
boost::proto::_make_bitwise_or	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::bitwise_or>         _make_bitwise_or;$/;"	t	namespace:boost::proto
boost::proto::_make_bitwise_or_assign	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::bitwise_or_assign>  _make_bitwise_or_assign;$/;"	t	namespace:boost::proto
boost::proto::_make_bitwise_xor	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::bitwise_xor>        _make_bitwise_xor;$/;"	t	namespace:boost::proto
boost::proto::_make_bitwise_xor_assign	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::bitwise_xor_assign> _make_bitwise_xor_assign;$/;"	t	namespace:boost::proto
boost::proto::_make_comma	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::comma>              _make_comma;$/;"	t	namespace:boost::proto
boost::proto::_make_complement	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::complement>         _make_complement;$/;"	t	namespace:boost::proto
boost::proto::_make_dereference	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::dereference>        _make_dereference;$/;"	t	namespace:boost::proto
boost::proto::_make_divides	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::divides>            _make_divides;$/;"	t	namespace:boost::proto
boost::proto::_make_divides_assign	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::divides_assign>     _make_divides_assign;$/;"	t	namespace:boost::proto
boost::proto::_make_equal_to	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::equal_to>           _make_equal_to;$/;"	t	namespace:boost::proto
boost::proto::_make_function	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::function>           _make_function;$/;"	t	namespace:boost::proto
boost::proto::_make_greater	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::greater>            _make_greater;$/;"	t	namespace:boost::proto
boost::proto::_make_greater_equal	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::greater_equal>      _make_greater_equal;$/;"	t	namespace:boost::proto
boost::proto::_make_if_else	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::if_else_>           _make_if_else;$/;"	t	namespace:boost::proto
boost::proto::_make_less	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::less>               _make_less;$/;"	t	namespace:boost::proto
boost::proto::_make_less_equal	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::less_equal>         _make_less_equal;$/;"	t	namespace:boost::proto
boost::proto::_make_logical_and	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::logical_and>        _make_logical_and;$/;"	t	namespace:boost::proto
boost::proto::_make_logical_not	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::logical_not>        _make_logical_not;$/;"	t	namespace:boost::proto
boost::proto::_make_logical_or	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::logical_or>         _make_logical_or;$/;"	t	namespace:boost::proto
boost::proto::_make_mem_ptr	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::mem_ptr>            _make_mem_ptr;$/;"	t	namespace:boost::proto
boost::proto::_make_minus	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::minus>              _make_minus;$/;"	t	namespace:boost::proto
boost::proto::_make_minus_assign	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::minus_assign>       _make_minus_assign;$/;"	t	namespace:boost::proto
boost::proto::_make_modulus	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::modulus>            _make_modulus;$/;"	t	namespace:boost::proto
boost::proto::_make_modulus_assign	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::modulus_assign>     _make_modulus_assign;$/;"	t	namespace:boost::proto
boost::proto::_make_multiplies	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::multiplies>         _make_multiplies;$/;"	t	namespace:boost::proto
boost::proto::_make_multiplies_assign	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::multiplies_assign>  _make_multiplies_assign;$/;"	t	namespace:boost::proto
boost::proto::_make_negate	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::negate>             _make_negate;$/;"	t	namespace:boost::proto
boost::proto::_make_not_equal_to	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::not_equal_to>       _make_not_equal_to;$/;"	t	namespace:boost::proto
boost::proto::_make_plus	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::plus>               _make_plus;$/;"	t	namespace:boost::proto
boost::proto::_make_plus_assign	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::plus_assign>        _make_plus_assign;$/;"	t	namespace:boost::proto
boost::proto::_make_post_dec	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::post_dec>           _make_post_dec;$/;"	t	namespace:boost::proto
boost::proto::_make_post_inc	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::post_inc>           _make_post_inc;$/;"	t	namespace:boost::proto
boost::proto::_make_pre_dec	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::pre_dec>            _make_pre_dec;$/;"	t	namespace:boost::proto
boost::proto::_make_pre_inc	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::pre_inc>            _make_pre_inc;$/;"	t	namespace:boost::proto
boost::proto::_make_shift_left	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::shift_left>         _make_shift_left;$/;"	t	namespace:boost::proto
boost::proto::_make_shift_left_assign	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::shift_left_assign>  _make_shift_left_assign;$/;"	t	namespace:boost::proto
boost::proto::_make_shift_right	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::shift_right>        _make_shift_right;$/;"	t	namespace:boost::proto
boost::proto::_make_shift_right_assign	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::shift_right_assign> _make_shift_right_assign;$/;"	t	namespace:boost::proto
boost::proto::_make_subscript	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::subscript>          _make_subscript;$/;"	t	namespace:boost::proto
boost::proto::_make_terminal	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::terminal>           _make_terminal;$/;"	t	namespace:boost::proto
boost::proto::_make_unary_plus	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::unary_plus>         _make_unary_plus;$/;"	t	namespace:boost::proto
boost::proto::_pop_front	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::pop_front   _pop_front;$/;"	t	namespace:boost::proto
boost::proto::_reverse	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::reverse     _reverse;$/;"	t	namespace:boost::proto
boost::proto::_right	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef _child1     _right;$/;"	t	namespace:boost::proto
boost::proto::_state	/usr/include/boost/proto/transform/arg.hpp	/^    struct _state : transform<_state>$/;"	s	namespace:boost::proto	inherits:transform
boost::proto::_state::impl	/usr/include/boost/proto/transform/arg.hpp	/^        struct impl : transform_impl<Expr, State, Data>$/;"	s	struct:boost::proto::_state	inherits:transform_impl	access:public
boost::proto::_state::impl::operator ()	/usr/include/boost/proto/transform/arg.hpp	/^            operator ()($/;"	f	struct:boost::proto::_state::impl	access:public	signature:( typename impl::expr_param , typename impl::state_param s , typename impl::data_param ) const
boost::proto::_state::impl::result_type	/usr/include/boost/proto/transform/arg.hpp	/^            typedef State result_type;$/;"	t	struct:boost::proto::_state::impl	access:public
boost::proto::_value	/usr/include/boost/proto/transform/arg.hpp	/^    struct _value : transform<_value>$/;"	s	namespace:boost::proto	inherits:transform
boost::proto::_value::impl	/usr/include/boost/proto/transform/arg.hpp	/^        struct impl : transform_impl<Expr, State, Data>$/;"	s	struct:boost::proto::_value	inherits:transform_impl	access:public
boost::proto::_value::impl::operator ()	/usr/include/boost/proto/transform/arg.hpp	/^            operator ()($/;"	f	struct:boost::proto::_value::impl	access:public	signature:( typename impl::expr_param e , typename impl::state_param , typename impl::data_param ) const
boost::proto::_value::impl::result_type	/usr/include/boost/proto/transform/arg.hpp	/^            result_type;$/;"	t	struct:boost::proto::_value::impl	access:public
boost::result_of	/usr/include/boost/proto/generate.hpp	/^        struct result_of<proto::default_domain(Expr)>$/;"	s	namespace:boost
boost::result_of::type	/usr/include/boost/proto/generate.hpp	/^            typedef Expr type;$/;"	t	struct:boost::result_of	access:public
BOOST_MPL_ASSERT	/usr/include/boost/proto/operators.hpp	/^            BOOST_MPL_ASSERT((boost::is_same<Domain1, Domain2>));$/;"	p	struct:boost::proto::detail::choose_domain2	access:public	signature:(boost::is_same<Domain1, Domain2>)
BOOST_MPL_ASSERT_MSG	/usr/include/boost/proto/make_expr.hpp	/^                BOOST_MPL_ASSERT_MSG((false), PROTO_DOMAIN_MISMATCH, (select_nth));$/;"	p	struct:boost::proto::detail::select_nth	access:public	signature:(false), PROTO_DOMAIN_MISMATCH, (select_nth)
BOOST_PP_CAT	/usr/include/boost/proto/detail/funop.hpp	/^    struct BOOST_PP_CAT(funop, BOOST_PP_ITERATION())$/;"	f	signature:(funop, BOOST_PP_ITERATION())
BOOST_PP_ITERATION_PARAMS_1	/usr/include/boost/proto/args.hpp	153;"	d
BOOST_PP_ITERATION_PARAMS_1	/usr/include/boost/proto/context/callable.hpp	235;"	d
BOOST_PP_ITERATION_PARAMS_1	/usr/include/boost/proto/context/default.hpp	373;"	d
BOOST_PP_ITERATION_PARAMS_1	/usr/include/boost/proto/context/null.hpp	44;"	d
BOOST_PP_ITERATION_PARAMS_1	/usr/include/boost/proto/deep_copy.hpp	173;"	d
BOOST_PP_ITERATION_PARAMS_1	/usr/include/boost/proto/detail/poly_function.hpp	172;"	d
BOOST_PP_ITERATION_PARAMS_1	/usr/include/boost/proto/detail/poly_function.hpp	208;"	d
BOOST_PP_ITERATION_PARAMS_1	/usr/include/boost/proto/expr.hpp	122;"	d
BOOST_PP_ITERATION_PARAMS_1	/usr/include/boost/proto/expr.hpp	139;"	d
BOOST_PP_ITERATION_PARAMS_1	/usr/include/boost/proto/generate.hpp	68;"	d
BOOST_PP_ITERATION_PARAMS_1	/usr/include/boost/proto/make_expr.hpp	368;"	d
BOOST_PP_ITERATION_PARAMS_1	/usr/include/boost/proto/make_expr.hpp	574;"	d
BOOST_PP_ITERATION_PARAMS_1	/usr/include/boost/proto/make_expr.hpp	748;"	d
BOOST_PP_ITERATION_PARAMS_1	/usr/include/boost/proto/make_expr.hpp	822;"	d
BOOST_PP_ITERATION_PARAMS_1	/usr/include/boost/proto/matches.hpp	363;"	d
BOOST_PP_ITERATION_PARAMS_1	/usr/include/boost/proto/matches.hpp	365;"	d
BOOST_PP_ITERATION_PARAMS_1	/usr/include/boost/proto/matches.hpp	369;"	d
BOOST_PP_ITERATION_PARAMS_1	/usr/include/boost/proto/traits.hpp	782;"	d
BOOST_PP_ITERATION_PARAMS_1	/usr/include/boost/proto/transform/call.hpp	346;"	d
BOOST_PP_ITERATION_PARAMS_1	/usr/include/boost/proto/transform/default.hpp	445;"	d
BOOST_PP_ITERATION_PARAMS_1	/usr/include/boost/proto/transform/fold.hpp	160;"	d
BOOST_PP_ITERATION_PARAMS_1	/usr/include/boost/proto/transform/lazy.hpp	42;"	d
BOOST_PP_ITERATION_PARAMS_1	/usr/include/boost/proto/transform/make.hpp	257;"	d
BOOST_PP_ITERATION_PARAMS_1	/usr/include/boost/proto/transform/pass_through.hpp	55;"	d
BOOST_PP_ITERATION_PARAMS_1	/usr/include/boost/proto/transform/when.hpp	100;"	d
BOOST_PP_LOCAL_LIMITS	/usr/include/boost/proto/debug.hpp	168;"	d
BOOST_PP_LOCAL_LIMITS	/usr/include/boost/proto/detail/decltype.hpp	261;"	d
BOOST_PP_LOCAL_LIMITS	/usr/include/boost/proto/detail/local.hpp	33;"	d
BOOST_PP_LOCAL_MACRO	/usr/include/boost/proto/debug.hpp	153;"	d
BOOST_PP_LOCAL_MACRO	/usr/include/boost/proto/detail/decltype.hpp	249;"	d
BOOST_PP_LOCAL_MACRO	/usr/include/boost/proto/detail/local.hpp	35;"	d
BOOST_PROTO_A	/usr/include/boost/proto/repeat.hpp	43;"	d
BOOST_PROTO_a	/usr/include/boost/proto/repeat.hpp	68;"	d
BOOST_PROTO_ADDROF	/usr/include/boost/proto/extends.hpp	38;"	d
BOOST_PROTO_AGGREGATE	/usr/include/boost/proto/proto_fwd.hpp	664;"	d
BOOST_PROTO_ARGS_HPP_EAN_04_01_2005	/usr/include/boost/proto/args.hpp	12;"	d
BOOST_PROTO_ARG_TRAITS_HPP_EAN_04_01_2005	/usr/include/boost/proto/traits.hpp	13;"	d
BOOST_PROTO_AS_CHILD	/usr/include/boost/proto/make_expr.hpp	84;"	d
BOOST_PROTO_AS_CHILD_TYPE	/usr/include/boost/proto/make_expr.hpp	75;"	d
BOOST_PROTO_AUTO	/usr/include/boost/proto/proto_typeof.hpp	130;"	d
BOOST_PROTO_AUTO_TPL	/usr/include/boost/proto/proto_typeof.hpp	131;"	d
BOOST_PROTO_A_const	/usr/include/boost/proto/repeat.hpp	48;"	d
BOOST_PROTO_A_const_ref	/usr/include/boost/proto/repeat.hpp	33;"	d
BOOST_PROTO_A_const_ref_a	/usr/include/boost/proto/repeat.hpp	53;"	d
BOOST_PROTO_A_ref	/usr/include/boost/proto/repeat.hpp	38;"	d
BOOST_PROTO_A_ref_a	/usr/include/boost/proto/repeat.hpp	58;"	d
BOOST_PROTO_BASIC_EXTENDS	/usr/include/boost/proto/extends.hpp	185;"	d
BOOST_PROTO_BASIC_EXTENDS_	/usr/include/boost/proto/extends.hpp	147;"	d
BOOST_PROTO_BINARY_OP_RESULT	/usr/include/boost/proto/context/default.hpp	133;"	d
BOOST_PROTO_BINARY_OP_RESULT	/usr/include/boost/proto/context/default.hpp	68;"	d
BOOST_PROTO_BINARY_OP_RESULT	/usr/include/boost/proto/transform/default.hpp	136;"	d
BOOST_PROTO_BINARY_OP_RESULT	/usr/include/boost/proto/transform/default.hpp	66;"	d
BOOST_PROTO_BROKEN_CONST_OVERLOADS	/usr/include/boost/proto/proto_fwd.hpp	51;"	d
BOOST_PROTO_BROKEN_CONST_QUALIFIED_FUNCTIONS	/usr/include/boost/proto/proto_fwd.hpp	58;"	d
BOOST_PROTO_BROKEN_PTS	/usr/include/boost/proto/proto_fwd.hpp	82;"	d
BOOST_PROTO_CALLABLE	/usr/include/boost/proto/proto_fwd.hpp	663;"	d
BOOST_PROTO_CHILD	/usr/include/boost/proto/debug.hpp	149;"	d
BOOST_PROTO_CHILD	/usr/include/boost/proto/debug.hpp	170;"	d
BOOST_PROTO_CHILD	/usr/include/boost/proto/expr.hpp	143;"	d
BOOST_PROTO_CHILD	/usr/include/boost/proto/expr.hpp	43;"	d
BOOST_PROTO_CHILD	/usr/include/boost/proto/traits.hpp	777;"	d
BOOST_PROTO_CHILD	/usr/include/boost/proto/traits.hpp	785;"	d
BOOST_PROTO_CHILD_N	/usr/include/boost/proto/context/callable.hpp	231;"	d
BOOST_PROTO_CHILD_N	/usr/include/boost/proto/context/callable.hpp	242;"	d
BOOST_PROTO_CHILD_N_TYPE	/usr/include/boost/proto/context/callable.hpp	227;"	d
BOOST_PROTO_CHILD_N_TYPE	/usr/include/boost/proto/context/callable.hpp	241;"	d
BOOST_PROTO_CHILD_N_TYPE	/usr/include/boost/proto/transform/fold.hpp	102;"	d
BOOST_PROTO_CHILD_N_TYPE	/usr/include/boost/proto/transform/fold.hpp	167;"	d
BOOST_PROTO_CONST0	/usr/include/boost/proto/extends.hpp	50;"	d
BOOST_PROTO_CONST1	/usr/include/boost/proto/extends.hpp	54;"	d
BOOST_PROTO_CONTEXT_CALLABLE_HPP_EAN_06_23_2007	/usr/include/boost/proto/context/callable.hpp	15;"	d
BOOST_PROTO_CONTEXT_DEFAULT_HPP_EAN_01_08_2007	/usr/include/boost/proto/context/default.hpp	13;"	d
BOOST_PROTO_CONTEXT_HPP_EAN_06_23_2007	/usr/include/boost/proto/context.hpp	10;"	d
BOOST_PROTO_CONTEXT_NULL_HPP_EAN_06_24_2007	/usr/include/boost/proto/context/null.hpp	13;"	d
BOOST_PROTO_CORE_HPP_EAN_04_01_2005	/usr/include/boost/proto/core.hpp	11;"	d
BOOST_PROTO_DEBUG_HPP_EAN_12_31_2006	/usr/include/boost/proto/debug.hpp	10;"	d
BOOST_PROTO_DECLTYPE_	/usr/include/boost/proto/detail/decltype.hpp	39;"	d
BOOST_PROTO_DECLTYPE_	/usr/include/boost/proto/detail/decltype.hpp	51;"	d
BOOST_PROTO_DECLTYPE_NESTED_TYPEDEF_TPL_	/usr/include/boost/proto/detail/decltype.hpp	41;"	d
BOOST_PROTO_DEEP_COPY_HPP_EAN_11_21_2006	/usr/include/boost/proto/deep_copy.hpp	11;"	d
BOOST_PROTO_DEFINE_BINARY_METAFUNCTION	/usr/include/boost/proto/traits.hpp	708;"	d
BOOST_PROTO_DEFINE_BINARY_METAFUNCTION	/usr/include/boost/proto/traits.hpp	773;"	d
BOOST_PROTO_DEFINE_BINARY_OPERATOR	/usr/include/boost/proto/operators.hpp	272;"	d
BOOST_PROTO_DEFINE_BINARY_OPERATOR	/usr/include/boost/proto/operators.hpp	358;"	d
BOOST_PROTO_DEFINE_BINARY_OPERATOR	/usr/include/boost/proto/operators.hpp	379;"	d
BOOST_PROTO_DEFINE_BY_VALUE	/usr/include/boost/proto/generate.hpp	46;"	d
BOOST_PROTO_DEFINE_BY_VALUE	/usr/include/boost/proto/generate.hpp	71;"	d
BOOST_PROTO_DEFINE_BY_VALUE_TYPE	/usr/include/boost/proto/generate.hpp	42;"	d
BOOST_PROTO_DEFINE_BY_VALUE_TYPE	/usr/include/boost/proto/generate.hpp	72;"	d
BOOST_PROTO_DEFINE_CHILD_N	/usr/include/boost/proto/args.hpp	126;"	d
BOOST_PROTO_DEFINE_CHILD_N	/usr/include/boost/proto/args.hpp	156;"	d
BOOST_PROTO_DEFINE_DEEP_COPY_FUN	/usr/include/boost/proto/deep_copy.hpp	169;"	d
BOOST_PROTO_DEFINE_DEEP_COPY_FUN	/usr/include/boost/proto/deep_copy.hpp	176;"	d
BOOST_PROTO_DEFINE_DEEP_COPY_TYPE	/usr/include/boost/proto/deep_copy.hpp	161;"	d
BOOST_PROTO_DEFINE_DEEP_COPY_TYPE	/usr/include/boost/proto/deep_copy.hpp	177;"	d
BOOST_PROTO_DEFINE_FUNCTION_TEMPLATE	/usr/include/boost/proto/detail/deprecated.hpp	222;"	d
BOOST_PROTO_DEFINE_FUN_OP	/usr/include/boost/proto/extends.hpp	134;"	d
BOOST_PROTO_DEFINE_FUN_OP_CONST	/usr/include/boost/proto/extends.hpp	124;"	d
BOOST_PROTO_DEFINE_FUN_OP_IMPL_	/usr/include/boost/proto/extends.hpp	66;"	d
BOOST_PROTO_DEFINE_FUN_OP_NON_CONST	/usr/include/boost/proto/extends.hpp	129;"	d
BOOST_PROTO_DEFINE_FUN_OP_VARIADIC_IMPL_	/usr/include/boost/proto/extends.hpp	95;"	d
BOOST_PROTO_DEFINE_LAMBDA_MATCHES	/usr/include/boost/proto/matches.hpp	356;"	d
BOOST_PROTO_DEFINE_LAMBDA_MATCHES	/usr/include/boost/proto/matches.hpp	374;"	d
BOOST_PROTO_DEFINE_MATCHES	/usr/include/boost/proto/matches.hpp	350;"	d
BOOST_PROTO_DEFINE_MATCHES	/usr/include/boost/proto/matches.hpp	373;"	d
BOOST_PROTO_DEFINE_OPERATORS	/usr/include/boost/proto/operators.hpp	414;"	d
BOOST_PROTO_DEFINE_TAG_NAME	/usr/include/boost/proto/debug.hpp	113;"	d
BOOST_PROTO_DEFINE_TAG_NAME	/usr/include/boost/proto/debug.hpp	58;"	d
BOOST_PROTO_DEFINE_TRANSFORM	/usr/include/boost/proto/transform/pass_through.hpp	46;"	d
BOOST_PROTO_DEFINE_TRANSFORM	/usr/include/boost/proto/transform/pass_through.hpp	58;"	d
BOOST_PROTO_DEFINE_TRANSFORM_TYPE	/usr/include/boost/proto/transform/pass_through.hpp	39;"	d
BOOST_PROTO_DEFINE_TRANSFORM_TYPE	/usr/include/boost/proto/transform/pass_through.hpp	59;"	d
BOOST_PROTO_DEFINE_UNARY_METAFUNCTION	/usr/include/boost/proto/traits.hpp	690;"	d
BOOST_PROTO_DEFINE_UNARY_METAFUNCTION	/usr/include/boost/proto/traits.hpp	772;"	d
BOOST_PROTO_DEFINE_UNARY_OPERATOR	/usr/include/boost/proto/operators.hpp	245;"	d
BOOST_PROTO_DEFINE_UNARY_OPERATOR	/usr/include/boost/proto/operators.hpp	357;"	d
BOOST_PROTO_DEFINE_UNARY_OPERATOR	/usr/include/boost/proto/operators.hpp	360;"	d
BOOST_PROTO_DEFINE_VARARG_FUNCTION_TEMPLATE	/usr/include/boost/proto/detail/deprecated.hpp	239;"	d
BOOST_PROTO_DEFINE_VOID_N	/usr/include/boost/proto/args.hpp	130;"	d
BOOST_PROTO_DETAIL_DECLTYPE_HPP_EAN_04_04_2008	/usr/include/boost/proto/detail/decltype.hpp	10;"	d
BOOST_PROTO_DETAIL_DEPRECATED_HPP_EAN_11_25_2008	/usr/include/boost/proto/detail/deprecated.hpp	11;"	d
BOOST_PROTO_DETAIL_DONT_CARE_HPP_EAN_11_07_2007	/usr/include/boost/proto/detail/dont_care.hpp	10;"	d
BOOST_PROTO_DETAIL_FUSION_POP_FRONT_EAH_01_22_2008	/usr/include/boost/proto/detail/pop_front.hpp	9;"	d
BOOST_PROTO_DETAIL_FUSION_REVERSE_EAH_01_22_2008	/usr/include/boost/proto/detail/reverse.hpp	9;"	d
BOOST_PROTO_DETAIL_IGNORE_UNUSED_HPP_EAN_03_03_2008	/usr/include/boost/proto/detail/ignore_unused.hpp	11;"	d
BOOST_PROTO_DETAIL_POLY_FUNCTION_EAN_2008_05_02	/usr/include/boost/proto/detail/poly_function.hpp	13;"	d
BOOST_PROTO_DISABLE_IF_IS_CONST	/usr/include/boost/proto/proto_fwd.hpp	65;"	d
BOOST_PROTO_DISABLE_IF_IS_CONST	/usr/include/boost/proto/proto_fwd.hpp	68;"	d
BOOST_PROTO_DISABLE_IF_IS_CONST	/usr/include/boost/proto/traits.hpp	/^        child(Expr &e BOOST_PROTO_DISABLE_IF_IS_CONST(Expr))$/;"	f	namespace:boost::proto	signature:(Expr)
BOOST_PROTO_DISABLE_IF_IS_CONST	/usr/include/boost/proto/traits.hpp	/^        child(Expr2 &expr2 BOOST_PROTO_DISABLE_IF_IS_CONST(Expr2))$/;"	f	namespace:boost::proto	signature:(Expr2)
BOOST_PROTO_DISABLE_IF_IS_CONST	/usr/include/boost/proto/traits.hpp	/^        child_c(Expr &e BOOST_PROTO_DISABLE_IF_IS_CONST(Expr))$/;"	f	namespace:boost::proto	signature:(Expr)
BOOST_PROTO_DISABLE_IF_IS_CONST	/usr/include/boost/proto/traits.hpp	/^        left(Expr &e BOOST_PROTO_DISABLE_IF_IS_CONST(Expr))$/;"	f	namespace:boost::proto	signature:(Expr)
BOOST_PROTO_DISABLE_IF_IS_CONST	/usr/include/boost/proto/traits.hpp	/^        right(Expr &e BOOST_PROTO_DISABLE_IF_IS_CONST(Expr))$/;"	f	namespace:boost::proto	signature:(Expr)
BOOST_PROTO_DISABLE_IF_IS_CONST	/usr/include/boost/proto/traits.hpp	/^        value(Expr &e BOOST_PROTO_DISABLE_IF_IS_CONST(Expr))$/;"	f	namespace:boost::proto	signature:(Expr)
BOOST_PROTO_DISABLE_IF_IS_FUNCTION	/usr/include/boost/proto/proto_fwd.hpp	74;"	d
BOOST_PROTO_DISABLE_IF_IS_FUNCTION	/usr/include/boost/proto/proto_fwd.hpp	77;"	d
BOOST_PROTO_DISABLE_IF_IS_FUNCTION	/usr/include/boost/proto/traits.hpp	/^        as_child(T &t BOOST_PROTO_DISABLE_IF_IS_CONST(T) BOOST_PROTO_DISABLE_IF_IS_FUNCTION(T))$/;"	f	namespace:boost::proto	signature:(T)
BOOST_PROTO_DISABLE_IF_IS_FUNCTION	/usr/include/boost/proto/traits.hpp	/^        as_expr(T &t BOOST_PROTO_DISABLE_IF_IS_CONST(T) BOOST_PROTO_DISABLE_IF_IS_FUNCTION(T))$/;"	f	namespace:boost::proto	signature:(T)
BOOST_PROTO_DOMAIN_HPP_EAN_02_13_2007	/usr/include/boost/proto/domain.hpp	12;"	d
BOOST_PROTO_EVAL_HPP_EAN_03_29_2007	/usr/include/boost/proto/eval.hpp	10;"	d
BOOST_PROTO_EVAL_N	/usr/include/boost/proto/context/null.hpp	40;"	d
BOOST_PROTO_EVAL_N	/usr/include/boost/proto/context/null.hpp	50;"	d
BOOST_PROTO_EXPR_HPP_EAN_04_01_2005	/usr/include/boost/proto/expr.hpp	11;"	d
BOOST_PROTO_EXTENDS	/usr/include/boost/proto/extends.hpp	408;"	d
BOOST_PROTO_EXTENDS_ASSIGN	/usr/include/boost/proto/extends.hpp	260;"	d
BOOST_PROTO_EXTENDS_ASSIGN_CONST	/usr/include/boost/proto/extends.hpp	254;"	d
BOOST_PROTO_EXTENDS_ASSIGN_IMPL_	/usr/include/boost/proto/extends.hpp	192;"	d
BOOST_PROTO_EXTENDS_ASSIGN_NON_CONST	/usr/include/boost/proto/extends.hpp	257;"	d
BOOST_PROTO_EXTENDS_CHILD	/usr/include/boost/proto/extends.hpp	141;"	d
BOOST_PROTO_EXTENDS_FUNCTION	/usr/include/boost/proto/extends.hpp	371;"	d
BOOST_PROTO_EXTENDS_FUNCTION_	/usr/include/boost/proto/extends.hpp	342;"	d
BOOST_PROTO_EXTENDS_FUNCTION_CONST	/usr/include/boost/proto/extends.hpp	361;"	d
BOOST_PROTO_EXTENDS_FUNCTION_NON_CONST	/usr/include/boost/proto/extends.hpp	366;"	d
BOOST_PROTO_EXTENDS_HPP_EAN_11_1_2006	/usr/include/boost/proto/extends.hpp	10;"	d
BOOST_PROTO_EXTENDS_MEMBERS	/usr/include/boost/proto/extends.hpp	592;"	d
BOOST_PROTO_EXTENDS_MEMBER_	/usr/include/boost/proto/extends.hpp	582;"	d
BOOST_PROTO_EXTENDS_SUBSCRIPT	/usr/include/boost/proto/extends.hpp	335;"	d
BOOST_PROTO_EXTENDS_SUBSCRIPT_CONST	/usr/include/boost/proto/extends.hpp	329;"	d
BOOST_PROTO_EXTENDS_SUBSCRIPT_IMPL_	/usr/include/boost/proto/extends.hpp	267;"	d
BOOST_PROTO_EXTENDS_SUBSCRIPT_NON_CONST	/usr/include/boost/proto/extends.hpp	332;"	d
BOOST_PROTO_FOLD_STATE	/usr/include/boost/proto/transform/fold.hpp	116;"	d
BOOST_PROTO_FOLD_STATE	/usr/include/boost/proto/transform/fold.hpp	165;"	d
BOOST_PROTO_FOLD_STATE_TYPE	/usr/include/boost/proto/transform/fold.hpp	106;"	d
BOOST_PROTO_FOLD_STATE_TYPE	/usr/include/boost/proto/transform/fold.hpp	166;"	d
BOOST_PROTO_FUSION_AS_CHILD_AT	/usr/include/boost/proto/make_expr.hpp	149;"	d
BOOST_PROTO_FUSION_AS_CHILD_AT	/usr/include/boost/proto/make_expr.hpp	857;"	d
BOOST_PROTO_FUSION_AS_CHILD_AT_TYPE	/usr/include/boost/proto/make_expr.hpp	140;"	d
BOOST_PROTO_FUSION_AS_CHILD_AT_TYPE	/usr/include/boost/proto/make_expr.hpp	858;"	d
BOOST_PROTO_FUSION_AT	/usr/include/boost/proto/make_expr.hpp	134;"	d
BOOST_PROTO_FUSION_AT	/usr/include/boost/proto/make_expr.hpp	855;"	d
BOOST_PROTO_FUSION_AT_TYPE	/usr/include/boost/proto/make_expr.hpp	110;"	d
BOOST_PROTO_FUSION_AT_TYPE	/usr/include/boost/proto/make_expr.hpp	856;"	d
BOOST_PROTO_FUSION_HPP_EAN_11_04_2006	/usr/include/boost/proto/fusion.hpp	10;"	d
BOOST_PROTO_FUSION_ITERATORS	/usr/include/boost/proto/make_expr.hpp	127;"	d
BOOST_PROTO_FUSION_ITERATORS	/usr/include/boost/proto/make_expr.hpp	861;"	d
BOOST_PROTO_FUSION_ITERATORS_TYPE	/usr/include/boost/proto/make_expr.hpp	101;"	d
BOOST_PROTO_FUSION_ITERATORS_TYPE	/usr/include/boost/proto/make_expr.hpp	862;"	d
BOOST_PROTO_FUSION_NEXT_ITERATOR	/usr/include/boost/proto/make_expr.hpp	120;"	d
BOOST_PROTO_FUSION_NEXT_ITERATOR	/usr/include/boost/proto/make_expr.hpp	859;"	d
BOOST_PROTO_FUSION_NEXT_ITERATOR_TYPE	/usr/include/boost/proto/make_expr.hpp	860;"	d
BOOST_PROTO_FUSION_NEXT_ITERATOR_TYPE	/usr/include/boost/proto/make_expr.hpp	93;"	d
BOOST_PROTO_FWD_HPP_EAN_04_01_2005	/usr/include/boost/proto/proto_fwd.hpp	10;"	d
BOOST_PROTO_GENERATE_HPP_EAN_02_13_2007	/usr/include/boost/proto/generate.hpp	12;"	d
BOOST_PROTO_GET_POINTER	/usr/include/boost/proto/detail/decltype.hpp	301;"	d
BOOST_PROTO_HPP_EAN_04_01_2005	/usr/include/boost/proto/proto.hpp	10;"	d
BOOST_PROTO_IMPLICIT_ARG	/usr/include/boost/proto/traits.hpp	786;"	d
BOOST_PROTO_invoke	/usr/include/boost/proto/repeat.hpp	73;"	d
BOOST_PROTO_LITERAL_HPP_EAN_01_03_2007	/usr/include/boost/proto/literal.hpp	11;"	d
BOOST_PROTO_LOCAL_a	/usr/include/boost/proto/detail/decltype.hpp	513;"	d
BOOST_PROTO_LOCAL_A	/usr/include/boost/proto/detail/local.hpp	22;"	d
BOOST_PROTO_LOCAL_a	/usr/include/boost/proto/detail/local.hpp	30;"	d
BOOST_PROTO_LOCAL_A	/usr/include/boost/proto/detail/local.hpp	50;"	d
BOOST_PROTO_LOCAL_a	/usr/include/boost/proto/detail/local.hpp	52;"	d
BOOST_PROTO_LOCAL_A_a	/usr/include/boost/proto/detail/local.hpp	26;"	d
BOOST_PROTO_LOCAL_A_a	/usr/include/boost/proto/detail/local.hpp	51;"	d
BOOST_PROTO_LOCAL_ITERATE	/usr/include/boost/proto/repeat.hpp	308;"	d
BOOST_PROTO_LOCAL_LIMITS	/usr/include/boost/proto/detail/decltype.hpp	514;"	d
BOOST_PROTO_LOCAL_LIMITS	/usr/include/boost/proto/detail/local.hpp	14;"	d
BOOST_PROTO_LOCAL_LIMITS	/usr/include/boost/proto/detail/local.hpp	48;"	d
BOOST_PROTO_LOCAL_MACRO	/usr/include/boost/proto/detail/decltype.hpp	505;"	d
BOOST_PROTO_LOCAL_MACRO	/usr/include/boost/proto/detail/local.hpp	47;"	d
BOOST_PROTO_LOCAL_typename_A	/usr/include/boost/proto/detail/local.hpp	18;"	d
BOOST_PROTO_LOCAL_typename_A	/usr/include/boost/proto/detail/local.hpp	49;"	d
BOOST_PROTO_MAKE_EXPR_HPP_EAN_04_01_2005	/usr/include/boost/proto/make_expr.hpp	13;"	d
BOOST_PROTO_MATCHES_HPP_EAN_11_03_2006	/usr/include/boost/proto/matches.hpp	12;"	d
BOOST_PROTO_MATCHES_N_FUN	/usr/include/boost/proto/matches.hpp	344;"	d
BOOST_PROTO_MATCHES_N_FUN	/usr/include/boost/proto/matches.hpp	372;"	d
BOOST_PROTO_MAX_ARITY	/usr/include/boost/proto/proto_fwd.hpp	29;"	d
BOOST_PROTO_MAX_FUNCTION_CALL_ARITY	/usr/include/boost/proto/proto_fwd.hpp	37;"	d
BOOST_PROTO_MAX_LOGICAL_ARITY	/usr/include/boost/proto/proto_fwd.hpp	33;"	d
BOOST_PROTO_OFFSETOF	/usr/include/boost/proto/extends.hpp	41;"	d
BOOST_PROTO_OPERATORS_HPP_EAN_04_01_2005	/usr/include/boost/proto/operators.hpp	11;"	d
BOOST_PROTO_POLY_FUNCTION	/usr/include/boost/proto/detail/poly_function.hpp	140;"	d
BOOST_PROTO_ref_a	/usr/include/boost/proto/repeat.hpp	63;"	d
BOOST_PROTO_ref_a_aux	/usr/include/boost/proto/repeat.hpp	23;"	d
BOOST_PROTO_REPEAT	/usr/include/boost/proto/repeat.hpp	197;"	d
BOOST_PROTO_REPEAT_EX	/usr/include/boost/proto/repeat.hpp	183;"	d
BOOST_PROTO_REPEAT_FROM_TO	/usr/include/boost/proto/repeat.hpp	169;"	d
BOOST_PROTO_REPEAT_FROM_TO_EX	/usr/include/boost/proto/repeat.hpp	87;"	d
BOOST_PROTO_REPEAT_HPP_EAN_11_24_2008	/usr/include/boost/proto/repeat.hpp	10;"	d
BOOST_PROTO_REVERSE_FOLD_STATE	/usr/include/boost/proto/transform/fold.hpp	143;"	d
BOOST_PROTO_REVERSE_FOLD_STATE	/usr/include/boost/proto/transform/fold.hpp	163;"	d
BOOST_PROTO_REVERSE_FOLD_STATE_TYPE	/usr/include/boost/proto/transform/fold.hpp	130;"	d
BOOST_PROTO_REVERSE_FOLD_STATE_TYPE	/usr/include/boost/proto/transform/fold.hpp	164;"	d
BOOST_PROTO_SEQ_PUSH_FRONT	/usr/include/boost/proto/detail/deprecated.hpp	140;"	d
BOOST_PROTO_TAGS_HPP_EAN_04_01_2005	/usr/include/boost/proto/tags.hpp	10;"	d
BOOST_PROTO_TEMPLATE_NO_	/usr/include/boost/proto/extends.hpp	62;"	d
BOOST_PROTO_TEMPLATE_PARAMS_NO_	/usr/include/boost/proto/detail/deprecated.hpp	101;"	d
BOOST_PROTO_TEMPLATE_PARAMS_YES_	/usr/include/boost/proto/detail/deprecated.hpp	83;"	d
BOOST_PROTO_TEMPLATE_YES_	/usr/include/boost/proto/extends.hpp	58;"	d
BOOST_PROTO_TRANSFORM	/usr/include/boost/proto/transform/impl.hpp	68;"	d
BOOST_PROTO_TRANSFORM_	/usr/include/boost/proto/transform/impl.hpp	18;"	d
BOOST_PROTO_TRANSFORM_ARG_HPP_EAN_11_01_2007	/usr/include/boost/proto/transform/arg.hpp	10;"	d
BOOST_PROTO_TRANSFORM_AS_LVALUE_HPP_EAN_12_27_2007	/usr/include/boost/proto/detail/as_lvalue.hpp	10;"	d
BOOST_PROTO_TRANSFORM_CALL_HPP_EAN_11_02_2007	/usr/include/boost/proto/transform/call.hpp	11;"	d
BOOST_PROTO_TRANSFORM_DEFAULT_HPP_EAN_04_04_2008	/usr/include/boost/proto/transform/default.hpp	12;"	d
BOOST_PROTO_TRANSFORM_FOLD_HPP_EAN_11_04_2007	/usr/include/boost/proto/transform/fold.hpp	11;"	d
BOOST_PROTO_TRANSFORM_FOLD_TREE_HPP_EAN_11_05_2007	/usr/include/boost/proto/transform/fold_tree.hpp	10;"	d
BOOST_PROTO_TRANSFORM_HPP_EAN_06_23_2007	/usr/include/boost/proto/transform.hpp	10;"	d
BOOST_PROTO_TRANSFORM_IMPL_HPP_EAN_04_03_2008	/usr/include/boost/proto/transform/impl.hpp	10;"	d
BOOST_PROTO_TRANSFORM_LAZY_HPP_EAN_12_02_2007	/usr/include/boost/proto/transform/lazy.hpp	11;"	d
BOOST_PROTO_TRANSFORM_MAKE_HPP_EAN_12_02_2007	/usr/include/boost/proto/transform/make.hpp	11;"	d
BOOST_PROTO_TRANSFORM_PASS_THROUGH_HPP_EAN_12_26_2006	/usr/include/boost/proto/transform/pass_through.hpp	14;"	d
BOOST_PROTO_TRANSFORM_WHEN_HPP_EAN_10_29_2007	/usr/include/boost/proto/transform/when.hpp	11;"	d
BOOST_PROTO_typename_A	/usr/include/boost/proto/repeat.hpp	28;"	d
BOOST_PROTO_UNARY_OP_IS_POSTFIX_0	/usr/include/boost/proto/operators.hpp	242;"	d
BOOST_PROTO_UNARY_OP_IS_POSTFIX_1	/usr/include/boost/proto/operators.hpp	243;"	d
BOOST_PROTO_UNARY_OP_RESULT	/usr/include/boost/proto/context/default.hpp	132;"	d
BOOST_PROTO_UNARY_OP_RESULT	/usr/include/boost/proto/context/default.hpp	50;"	d
BOOST_PROTO_UNARY_OP_RESULT	/usr/include/boost/proto/transform/default.hpp	135;"	d
BOOST_PROTO_UNARY_OP_RESULT	/usr/include/boost/proto/transform/default.hpp	44;"	d
BOOST_PROTO_UNCVREF	/usr/include/boost/proto/proto_fwd.hpp	137;"	d
BOOST_PROTO_UNEXPR	/usr/include/boost/proto/proto_fwd.hpp	662;"	d
BOOST_PROTO_USE_GET_POINTER	/usr/include/boost/proto/detail/decltype.hpp	297;"	d
BOOST_PROTO_VARARG_AS_CHILD_	/usr/include/boost/proto/detail/deprecated.hpp	134;"	d
BOOST_PROTO_VARARG_AS_EXPR_	/usr/include/boost/proto/detail/deprecated.hpp	118;"	d
BOOST_PROTO_VARARG_AS_PARAM_	/usr/include/boost/proto/detail/deprecated.hpp	146;"	d
BOOST_PROTO_VARARG_FUN_	/usr/include/boost/proto/detail/deprecated.hpp	152;"	d
BOOST_PROTO_VARARG_TEMPLATE_	/usr/include/boost/proto/detail/deprecated.hpp	67;"	d
BOOST_PROTO_VARARG_TEMPLATE_AUX_	/usr/include/boost/proto/detail/deprecated.hpp	42;"	d
BOOST_PROTO_VARARG_TEMPLATE_NO_	/usr/include/boost/proto/detail/deprecated.hpp	62;"	d
BOOST_PROTO_VARARG_TEMPLATE_YES_	/usr/include/boost/proto/detail/deprecated.hpp	48;"	d
BOOST_PROTO_VARARG_TYPE_	/usr/include/boost/proto/detail/deprecated.hpp	106;"	d
BOOST_PROTO_VARARG_TYPE_AUX_	/usr/include/boost/proto/detail/deprecated.hpp	77;"	d
BOOST_PROTO_VOID	/usr/include/boost/proto/expr.hpp	144;"	d
BOOST_PROTO_VOID	/usr/include/boost/proto/expr.hpp	50;"	d
BOOST_STATIC_CONSTANT	/usr/include/boost/proto/args.hpp	/^                BOOST_STATIC_CONSTANT(long, arity = 0);$/;"	p	struct:boost::proto::argsns_::term	access:public	signature:(long, arity = 0)
BOOST_STATIC_CONSTANT	/usr/include/boost/proto/context/callable.hpp	/^                BOOST_STATIC_CONSTANT(bool, value =$/;"	p	struct:boost::proto::detail::is_expr_handled	access:public	signature:(bool, value = ( sizeof(yes_type) == sizeof( detail::check_is_expr_handled( (sctx_(stag_, proto::value(sexpr_)), 0) ) )))
BOOST_STATIC_CONSTANT	/usr/include/boost/proto/detail/decltype.hpp	/^                BOOST_STATIC_CONSTANT(bool, is_ptr_to_const = 2 == sizeof(test_ptr_to_const(BOOST_PROTO_GET_POINTER(U, make<V>()))));$/;"	p	struct:boost::proto::detail::get_pointerns::result_of_	access:public	signature:(bool, is_ptr_to_const = 2 == sizeof(test_ptr_to_const(BOOST_PROTO_GET_POINTER(U, make<V>()))))
BOOST_STATIC_CONSTANT	/usr/include/boost/proto/detail/decltype.hpp	/^                BOOST_STATIC_CONSTANT(bool, is_V_a_smart_ptr = 2 == sizeof(test_V_is_a_U<U>(&lvalue(make<V>()))));$/;"	p	struct:boost::proto::detail::get_pointerns::result_of_	access:public	signature:(bool, is_V_a_smart_ptr = 2 == sizeof(test_V_is_a_U<U>(&lvalue(make<V>()))))
BOOST_STATIC_CONSTANT	/usr/include/boost/proto/detail/decltype.hpp	/^                BOOST_STATIC_CONSTANT(bool, value = sizeof(void *) == sizeof(get_pointer(make<T &>())));$/;"	p	struct:boost::proto::detail::has_get_pointerns::has_get_pointer	access:public	signature:(bool, value = sizeof(void *) == sizeof(get_pointer(make<T &>())))
BOOST_STATIC_CONSTANT	/usr/include/boost/proto/extends.hpp	/^            BOOST_STATIC_CONSTANT(long, proto_arity_c = proto_base_expr::proto_arity_c);$/;"	p	struct:boost::proto::exprns_::virtual_member	access:public	signature:(long, proto_arity_c = proto_base_expr::proto_arity_c)
BOOST_STATIC_CONSTANT	/usr/include/boost/proto/fusion.hpp	/^            BOOST_STATIC_CONSTANT(long, index = Pos);$/;"	p	struct:boost::proto::detail::expr_iterator	access:public	signature:(long, index = Pos)
BOOST_STATIC_CONSTANT	/usr/include/boost/proto/generate.hpp	/^                BOOST_STATIC_CONSTANT(long, arity = N);$/;"	p	struct:boost::proto::detail::expr_params	access:public	signature:(long, arity = N)
BOOST_STATIC_CONSTANT	/usr/include/boost/proto/operators.hpp	/^            BOOST_STATIC_CONSTANT(int, value = 0);$/;"	p	struct:boost::proto::detail::arg_weight	access:public	signature:(int, value = 0)
BOOST_STATIC_CONSTANT	/usr/include/boost/proto/operators.hpp	/^            BOOST_STATIC_CONSTANT(int, value = 1 + Trait::value);$/;"	p	struct:boost::proto::detail::arg_weight	access:public	signature:(int, value = 1 + Trait::value)
BOOST_XPRESSIVE_PROTO_PROTO_TYPEOF_H	/usr/include/boost/proto/proto_typeof.hpp	11;"	d
buffer	/usr/include/boost/proto/make_expr.hpp	/^                char buffer[I];$/;"	m	struct:boost::proto::detail::sized	access:public
by_value_generator	/usr/include/boost/proto/generate.hpp	/^            struct by_value_generator$/;"	s	namespace:boost::proto::generatorns_
by_value_generator_	/usr/include/boost/proto/generate.hpp	/^            struct by_value_generator_<Expr, 0>$/;"	s	namespace:boost::proto::detail
call	/usr/include/boost/proto/debug.hpp	/^                static type call() { return Tag(); }$/;"	f	struct:boost::proto::tag::hidden_detail_::printable_tag_	access:public	signature:()
call	/usr/include/boost/proto/debug.hpp	/^                static type call() { return typeid(Tag).name(); }$/;"	f	struct:boost::proto::tag::hidden_detail_::printable_tag_	access:public	signature:()
call	/usr/include/boost/proto/detail/reverse.hpp	/^                call(Iterator const& i)$/;"	f	struct:boost::fusion::meta::deref_impl::apply	access:public	signature:(Iterator const& i)
call	/usr/include/boost/proto/detail/reverse.hpp	/^                call(Iterator const& i)$/;"	f	struct:boost::fusion::meta::next_impl::apply	access:public	signature:(Iterator const& i)
call	/usr/include/boost/proto/detail/reverse.hpp	/^                call(Iterator const& i)$/;"	f	struct:boost::fusion::meta::prior_impl::apply	access:public	signature:(Iterator const& i)
call	/usr/include/boost/proto/detail/reverse.hpp	/^                call(Sequence const& s)$/;"	f	struct:boost::fusion::meta::begin_impl::apply	access:public	signature:(Sequence const& s)
call	/usr/include/boost/proto/detail/reverse.hpp	/^                call(Sequence const& s)$/;"	f	struct:boost::fusion::meta::end_impl::apply	access:public	signature:(Sequence const& s)
call	/usr/include/boost/proto/fusion.hpp	/^                static type call(Iterator const &iter)$/;"	f	struct:boost::fusion::extension::advance_impl::apply	access:public	signature:(Iterator const &iter)
call	/usr/include/boost/proto/fusion.hpp	/^                static type call(Iterator const &iter)$/;"	f	struct:boost::fusion::extension::deref_impl::apply	access:public	signature:(Iterator const &iter)
call	/usr/include/boost/proto/fusion.hpp	/^                static type call(Sequence &seq)$/;"	f	struct:boost::fusion::extension::at_impl::apply	access:public	signature:(Sequence &seq)
call	/usr/include/boost/proto/fusion.hpp	/^                static type call(Sequence &sequence)$/;"	f	struct:boost::fusion::extension::segments_impl::apply	access:public	signature:(Sequence &sequence)
call	/usr/include/boost/proto/fusion.hpp	/^                static type call(Sequence const &seq)$/;"	f	struct:boost::fusion::extension::begin_impl::apply	access:public	signature:(Sequence const &seq)
call	/usr/include/boost/proto/fusion.hpp	/^                static type call(Sequence const &seq)$/;"	f	struct:boost::fusion::extension::end_impl::apply	access:public	signature:(Sequence const &seq)
call	/usr/include/boost/proto/make_expr.hpp	/^                static type call(T &t)$/;"	f	struct:boost::proto::detail::protoify_	access:public	signature:(T &t)
call	/usr/include/boost/proto/make_expr.hpp	/^                static type const call(Sequence const &sequence)$/;"	f	struct:boost::proto::detail::unpack_expr_	access:public	signature:(Sequence const &sequence)
call	/usr/include/boost/proto/traits.hpp	/^                static reference call(T2 &t)$/;"	f	struct:boost::proto::result_of::as_expr	access:public	signature:(T2 &t)
call	/usr/include/boost/proto/traits.hpp	/^                static T2 &call(T2 &t)$/;"	f	struct:boost::proto::result_of::as_child	access:public	signature:(T2 &t)
call	/usr/include/boost/proto/traits.hpp	/^                static T2 &call(T2 &t)$/;"	f	struct:boost::proto::result_of::as_expr	access:public	signature:(T2 &t)
call	/usr/include/boost/proto/traits.hpp	/^                static type call(T2 &t)$/;"	f	struct:boost::proto::result_of::as_child	access:public	signature:(T2 &t)
call	/usr/include/boost/proto/transform/call.hpp	/^        struct call$/;"	s	namespace:boost::proto	inherits:PrimitiveTransform
call	/usr/include/boost/proto/transform/call.hpp	/^        struct call<Fun()> : transform<call<Fun()> >$/;"	s	namespace:boost::proto	inherits:transform
call	/usr/include/boost/proto/transform/call.hpp	/^        struct call<Fun(A0)> : transform<call<Fun(A0)> >$/;"	s	namespace:boost::proto	inherits:transform
call	/usr/include/boost/proto/transform/call.hpp	/^        struct call<Fun(A0, A1)> : transform<call<Fun(A0, A1)> >$/;"	s	namespace:boost::proto	inherits:transform
call	/usr/include/boost/proto/transform/call.hpp	/^        struct call<Fun(A0, A1, A2)> : transform<call<Fun(A0, A1, A2)> >$/;"	s	namespace:boost::proto	inherits:transform
callable	/usr/include/boost/proto/proto_fwd.hpp	/^    struct callable$/;"	s	namespace:boost::proto
callable_context	/usr/include/boost/proto/context/callable.hpp	/^            struct callable_context$/;"	s	namespace:boost::proto::context
callable_context_wrapper	/usr/include/boost/proto/context/callable.hpp	/^                callable_context_wrapper();$/;"	p	struct:boost::proto::detail::callable_context_wrapper	access:public	signature:()
callable_context_wrapper	/usr/include/boost/proto/context/callable.hpp	/^            struct callable_context_wrapper$/;"	s	namespace:boost::proto::detail	inherits:remove_cv::type
callable_eval	/usr/include/boost/proto/context/callable.hpp	/^            struct callable_eval$/;"	s	namespace:boost::proto::context
callable_eval	/usr/include/boost/proto/context/callable.hpp	/^            struct callable_eval<Expr, Context, 0>$/;"	s	namespace:boost::proto::context
category	/usr/include/boost/proto/fusion.hpp	/^            typedef fusion::forward_traversal_tag category;$/;"	t	struct:boost::proto::detail::flat_view	access:public
category	/usr/include/boost/proto/fusion.hpp	/^            typedef fusion::random_access_traversal_tag category;$/;"	t	struct:boost::proto::detail::expr_iterator	access:public
category_of_impl	/usr/include/boost/proto/fusion.hpp	/^        struct category_of_impl<proto::tag::proto_expr>$/;"	s	namespace:boost::fusion::extension
category_of_impl	/usr/include/boost/proto/fusion.hpp	/^        struct category_of_impl<proto::tag::proto_flat_view>$/;"	s	namespace:boost::fusion::extension
check_is_expr_handled	/usr/include/boost/proto/context/callable.hpp	/^            no_type check_is_expr_handled(private_type_ const &);$/;"	p	namespace:boost::proto::detail	signature:(private_type_ const &)
check_is_expr_handled	/usr/include/boost/proto/context/callable.hpp	/^            yes_type check_is_expr_handled(T const &);$/;"	p	namespace:boost::proto::detail	signature:(T const &)
check_reference	/usr/include/boost/proto/detail/decltype.hpp	/^        char (&check_reference(T const &))[2];$/;"	p	namespace:boost::proto::detail	signature:(T const &)
check_reference	/usr/include/boost/proto/detail/decltype.hpp	/^        char check_reference(T &);$/;"	p	namespace:boost::proto::detail	signature:(T &)
child	/usr/include/boost/proto/traits.hpp	/^            struct child$/;"	s	namespace:boost::proto::functional
child	/usr/include/boost/proto/traits.hpp	/^            struct child$/;"	s	namespace:boost::proto::result_of	inherits:child_c
child	/usr/include/boost/proto/traits.hpp	/^        child(Expr const &e)$/;"	f	namespace:boost::proto	signature:(Expr const &e)
child	/usr/include/boost/proto/traits.hpp	/^        child(Expr2 const &expr2)$/;"	f	namespace:boost::proto	signature:(Expr2 const &expr2)
child0	/usr/include/boost/proto/args.hpp	/^                typedef Arg0 child0;$/;"	t	struct:boost::proto::argsns_::term	access:public
child0	/usr/include/boost/proto/extends.hpp	/^            proto_child0 child0() const$/;"	f	struct:boost::proto::exprns_::virtual_member	access:public	signature:() const
child1	/usr/include/boost/proto/extends.hpp	/^            proto_child1 child1() const$/;"	f	struct:boost::proto::exprns_::virtual_member	access:public	signature:() const
child_c	/usr/include/boost/proto/traits.hpp	/^            struct child_c$/;"	s	namespace:boost::proto::functional
child_c	/usr/include/boost/proto/traits.hpp	/^        child_c(Expr const &e)$/;"	f	namespace:boost::proto	signature:(Expr const &e)
choose_domain2	/usr/include/boost/proto/operators.hpp	/^        struct choose_domain2$/;"	s	namespace:boost::proto::detail
choose_domain2	/usr/include/boost/proto/operators.hpp	/^        struct choose_domain2<Domain1, proto::default_domain>$/;"	s	namespace:boost::proto::detail
choose_domain2	/usr/include/boost/proto/operators.hpp	/^        struct choose_domain2<proto::default_domain, Domain2>$/;"	s	namespace:boost::proto::detail
choose_domain2	/usr/include/boost/proto/operators.hpp	/^        struct choose_domain2<proto::default_domain, proto::default_domain>$/;"	s	namespace:boost::proto::detail
classtypeof	/usr/include/boost/proto/detail/decltype.hpp	/^        struct classtypeof<T U::*>$/;"	s	namespace:boost::proto::detail
comma	/usr/include/boost/proto/tags.hpp	/^    struct comma {};$/;"	s	namespace:boost::proto::tag
comma_result	/usr/include/boost/proto/detail/decltype.hpp	/^        struct comma_result$/;"	s	namespace:boost::proto::detail
comma_result	/usr/include/boost/proto/detail/decltype.hpp	/^        struct comma_result<A0, void>$/;"	s	namespace:boost::proto::detail
comma_result	/usr/include/boost/proto/detail/decltype.hpp	/^        struct comma_result<void, A1>$/;"	s	namespace:boost::proto::detail
comma_result	/usr/include/boost/proto/detail/decltype.hpp	/^        struct comma_result<void, void>$/;"	s	namespace:boost::proto::detail
complement	/usr/include/boost/proto/tags.hpp	/^    struct complement {};$/;"	s	namespace:boost::proto::tag
compose_generators	/usr/include/boost/proto/generate.hpp	/^            struct compose_generators$/;"	s	namespace:boost::proto::generatorns_
condition	/usr/include/boost/proto/matches.hpp	/^                    condition;$/;"	t	struct:boost::proto::control::if_::impl	access:public
construct_	/usr/include/boost/proto/transform/make.hpp	/^            struct construct_$/;"	s	namespace:boost::proto::detail
construct_	/usr/include/boost/proto/transform/make.hpp	/^            struct construct_<Type, true>$/;"	s	namespace:boost::proto::detail
const_reference	/usr/include/boost/proto/args.hpp	/^                typedef Expr &const_reference;$/;"	t	struct:boost::proto::detail::expr_traits	access:public
const_reference	/usr/include/boost/proto/args.hpp	/^                typedef Expr const &const_reference;$/;"	t	struct:boost::proto::detail::expr_traits	access:public
const_reference	/usr/include/boost/proto/args.hpp	/^                typedef T &const_reference;$/;"	t	struct:boost::proto::detail::term_traits	access:public
const_reference	/usr/include/boost/proto/args.hpp	/^                typedef T (&const_reference)[N];$/;"	t	struct:boost::proto::detail::term_traits	access:public
const_reference	/usr/include/boost/proto/args.hpp	/^                typedef T const &const_reference;$/;"	t	struct:boost::proto::detail::term_traits	access:public
const_reference	/usr/include/boost/proto/args.hpp	/^                typedef T const (&const_reference)[N];$/;"	t	struct:boost::proto::detail::term_traits	access:public
const_reference	/usr/include/boost/proto/literal.hpp	/^            typedef typename detail::term_traits<T>::const_reference  const_reference;$/;"	t	struct:boost::proto::utility::literal	access:public
context	/usr/include/boost/proto/context/callable.hpp	/^        namespace context$/;"	n	namespace:boost::proto
context	/usr/include/boost/proto/context/default.hpp	/^        namespace context$/;"	n	namespace:boost::proto
context	/usr/include/boost/proto/context/null.hpp	/^    namespace boost { namespace proto { namespace context$/;"	n	namespace:boost::proto
context	/usr/include/boost/proto/proto_fwd.hpp	/^    namespace context$/;"	n	namespace:boost::proto
control	/usr/include/boost/proto/matches.hpp	/^        namespace control$/;"	n	namespace:boost::proto
control	/usr/include/boost/proto/proto_fwd.hpp	/^    namespace control$/;"	n	namespace:boost::proto
converter	/usr/include/boost/proto/detail/reverse.hpp	/^        typedef as_fusion_iterator<First> converter;$/;"	t	struct:boost::fusion::reverse_view_iterator	access:public
convertible_to	/usr/include/boost/proto/matches.hpp	/^            struct convertible_to$/;"	s	namespace:boost::proto::control
ctx_	/usr/include/boost/proto/fusion.hpp	/^        Context &ctx_;$/;"	m	struct:boost::proto::eval_fun	access:private
data	/usr/include/boost/proto/transform/impl.hpp	/^        typedef Data const data;$/;"	t	struct:boost::proto::transform_impl	access:public
data	/usr/include/boost/proto/transform/impl.hpp	/^        typedef Data data;$/;"	t	struct:boost::proto::transform_impl	access:public
data_param	/usr/include/boost/proto/transform/impl.hpp	/^        typedef Data &data_param;$/;"	t	struct:boost::proto::transform_impl	access:public
data_param	/usr/include/boost/proto/transform/impl.hpp	/^        typedef Data const &data_param;$/;"	t	struct:boost::proto::transform_impl	access:public
deduce_domain	/usr/include/boost/proto/domain.hpp	/^        struct deduce_domain$/;"	s	namespace:boost::proto::domainns_	inherits:domain
deduce_domain0	/usr/include/boost/proto/make_expr.hpp	/^            struct deduce_domain0$/;"	s	namespace:boost::proto::detail
deep_copy	/usr/include/boost/proto/deep_copy.hpp	/^            struct deep_copy$/;"	s	namespace:boost::proto::functional
deep_copy	/usr/include/boost/proto/deep_copy.hpp	/^            struct deep_copy$/;"	s	namespace:boost::proto::result_of
deep_copy	/usr/include/boost/proto/deep_copy.hpp	/^        deep_copy(Expr const &e)$/;"	f	namespace:boost::proto	signature:(Expr const &e)
deep_copy_impl	/usr/include/boost/proto/deep_copy.hpp	/^            struct deep_copy_impl<Expr, 0>$/;"	s	namespace:boost::proto::detail
default_context	/usr/include/boost/proto/context/default.hpp	/^            struct default_context$/;"	s	namespace:boost::proto::context
default_domain	/usr/include/boost/proto/domain.hpp	/^        struct default_domain$/;"	s	namespace:boost::proto::domainns_	inherits:domain
default_eval	/usr/include/boost/proto/context/default.hpp	/^            struct default_eval$/;"	s	namespace:boost::proto::context
default_eval	/usr/include/boost/proto/context/default.hpp	/^            struct default_eval<Expr, Context, proto::tag::comma, 2>$/;"	s	namespace:boost::proto::context
default_eval	/usr/include/boost/proto/context/default.hpp	/^            struct default_eval<Expr, Context, proto::tag::function, 1>$/;"	s	namespace:boost::proto::context
default_eval	/usr/include/boost/proto/context/default.hpp	/^            struct default_eval<Expr, Context, proto::tag::function, 2>$/;"	s	namespace:boost::proto::context
default_eval	/usr/include/boost/proto/context/default.hpp	/^            struct default_eval<Expr, Context, proto::tag::if_else_, 3>$/;"	s	namespace:boost::proto::context
default_eval	/usr/include/boost/proto/context/default.hpp	/^            struct default_eval<Expr, Context, proto::tag::post_dec, 1>$/;"	s	namespace:boost::proto::context
default_eval	/usr/include/boost/proto/context/default.hpp	/^            struct default_eval<Expr, Context, proto::tag::post_inc, 1>$/;"	s	namespace:boost::proto::context
default_eval	/usr/include/boost/proto/context/default.hpp	/^            struct default_eval<Expr, Context, proto::tag::subscript, 2>$/;"	s	namespace:boost::proto::context
default_eval	/usr/include/boost/proto/context/default.hpp	/^            struct default_eval<Expr, Context, Tag, 0>$/;"	s	namespace:boost::proto::context
default_eval	/usr/include/boost/proto/context/default.hpp	/^            struct default_eval<Expr, Context, tag::mem_ptr, 2>$/;"	s	namespace:boost::proto::context	inherits:memfun_eval
default_generator	/usr/include/boost/proto/generate.hpp	/^            struct default_generator$/;"	s	namespace:boost::proto::generatorns_
dereference	/usr/include/boost/proto/tags.hpp	/^    struct dereference {};$/;"	s	namespace:boost::proto::tag
deref_impl	/usr/include/boost/proto/detail/reverse.hpp	/^        struct deref_impl<reverse_view_iterator_tag>$/;"	s	namespace:boost::fusion::meta
deref_impl	/usr/include/boost/proto/fusion.hpp	/^        struct deref_impl<proto::tag::proto_expr_iterator>$/;"	s	namespace:boost::fusion::extension
detail	/usr/include/boost/proto/args.hpp	/^        namespace detail$/;"	n	namespace:boost::proto
detail	/usr/include/boost/proto/context/callable.hpp	/^        namespace detail$/;"	n	namespace:boost::proto
detail	/usr/include/boost/proto/deep_copy.hpp	/^        namespace detail$/;"	n	namespace:boost::proto
detail	/usr/include/boost/proto/detail/as_lvalue.hpp	/^    namespace detail$/;"	n	namespace:boost::proto
detail	/usr/include/boost/proto/detail/decltype.hpp	/^    namespace detail$/;"	n	namespace:boost::proto
detail	/usr/include/boost/proto/detail/dont_care.hpp	/^    namespace detail$/;"	n	namespace:boost::proto
detail	/usr/include/boost/proto/detail/ignore_unused.hpp	/^    namespace detail$/;"	n	namespace:boost::proto
detail	/usr/include/boost/proto/detail/poly_function.hpp	/^    namespace boost { namespace proto { namespace detail$/;"	n	namespace:boost::proto
detail	/usr/include/boost/proto/domain.hpp	/^    namespace detail$/;"	n	namespace:boost::proto
detail	/usr/include/boost/proto/expr.hpp	/^        namespace detail$/;"	n	namespace:boost::proto
detail	/usr/include/boost/proto/fusion.hpp	/^    namespace detail$/;"	n	namespace:boost::proto
detail	/usr/include/boost/proto/generate.hpp	/^        namespace detail$/;"	n	namespace:boost::proto
detail	/usr/include/boost/proto/make_expr.hpp	/^        namespace detail$/;"	n	namespace:boost::proto
detail	/usr/include/boost/proto/matches.hpp	/^        namespace detail$/;"	n	namespace:boost::proto
detail	/usr/include/boost/proto/operators.hpp	/^    namespace detail$/;"	n	namespace:boost::proto
detail	/usr/include/boost/proto/proto_fwd.hpp	/^    namespace detail$/;"	n	namespace:boost::proto
detail	/usr/include/boost/proto/traits.hpp	/^        namespace detail$/;"	n	namespace:boost::proto
detail	/usr/include/boost/proto/transform/default.hpp	/^        namespace detail$/;"	n	namespace:boost::proto
detail	/usr/include/boost/proto/transform/fold.hpp	/^        namespace detail$/;"	n	namespace:boost::proto
detail	/usr/include/boost/proto/transform/fold_tree.hpp	/^    namespace detail$/;"	n	namespace:boost::proto
detail	/usr/include/boost/proto/transform/impl.hpp	/^    namespace detail$/;"	n	namespace:boost::proto
detail	/usr/include/boost/proto/transform/make.hpp	/^        namespace detail$/;"	n	namespace:boost::proto
detail	/usr/include/boost/proto/transform/pass_through.hpp	/^        namespace detail$/;"	n	namespace:boost::proto
distance_impl	/usr/include/boost/proto/fusion.hpp	/^        struct distance_impl<proto::tag::proto_expr_iterator>$/;"	s	namespace:boost::fusion::extension
divides	/usr/include/boost/proto/tags.hpp	/^    struct divides {};$/;"	s	namespace:boost::proto::tag
divides_assign	/usr/include/boost/proto/tags.hpp	/^    struct divides_assign {};$/;"	s	namespace:boost::proto::tag
domain	/usr/include/boost/proto/domain.hpp	/^        struct domain$/;"	s	namespace:boost::proto::domainns_	inherits:Generator
domainns_	/usr/include/boost/proto/domain.hpp	/^    namespace domainns_$/;"	n	namespace:boost::proto
domainns_	/usr/include/boost/proto/proto_fwd.hpp	/^    namespace domainns_$/;"	n	namespace:boost::proto
domain_of	/usr/include/boost/proto/domain.hpp	/^        struct domain_of$/;"	s	namespace:boost::proto::result_of
domain_of	/usr/include/boost/proto/domain.hpp	/^        struct domain_of<boost::reference_wrapper<T> const, void>$/;"	s	namespace:boost::proto::result_of
domain_of	/usr/include/boost/proto/domain.hpp	/^        struct domain_of<boost::reference_wrapper<T>, void>$/;"	s	namespace:boost::proto::result_of
domain_of	/usr/include/boost/proto/domain.hpp	/^        struct domain_of<T &, void>$/;"	s	namespace:boost::proto::result_of
domain_of	/usr/include/boost/proto/domain.hpp	/^        struct domain_of<T, typename T::proto_is_expr_>$/;"	s	namespace:boost::proto::result_of
dont_care	/usr/include/boost/proto/detail/dont_care.hpp	/^            dont_care(...);$/;"	p	struct:boost::proto::detail::dont_care	access:public	signature:(....)
dont_care	/usr/include/boost/proto/detail/dont_care.hpp	/^        struct dont_care$/;"	s	namespace:boost::proto::detail
d_	/usr/include/boost/proto/transform/fold.hpp	/^                Data d_;$/;"	m	struct:boost::proto::detail::as_callable	access:private
e0	/usr/include/boost/proto/context/default.hpp	/^                typedef typename proto::result_of::child_c<Expr, 0>::type e0;$/;"	t	struct:boost::proto::context::default_eval	access:private
e0	/usr/include/boost/proto/context/default.hpp	/^                typedef typename result_of::child_c<Expr, 0>::type e0;$/;"	t	struct:boost::proto::context::memfun_eval	access:private
e0	/usr/include/boost/proto/transform/default.hpp	/^                typedef typename result_of::child_c<Expr, 0>::type e0;$/;"	t	struct:boost::proto::_default::impl2	access:private
e0	/usr/include/boost/proto/transform/default.hpp	/^                typedef typename result_of::child_c<Expr, 0>::type e0;$/;"	t	struct:boost::proto::_default::memfun_impl	access:private
e1	/usr/include/boost/proto/context/default.hpp	/^                typedef typename proto::result_of::child_c<Expr, 1>::type e1;$/;"	t	struct:boost::proto::context::default_eval	access:private
e1	/usr/include/boost/proto/context/default.hpp	/^                typedef typename result_of::child_c<Expr, 1>::type e1;$/;"	t	struct:boost::proto::context::memfun_eval	access:private
e1	/usr/include/boost/proto/transform/default.hpp	/^                typedef typename result_of::child_c<Expr, 1>::type e1;$/;"	t	struct:boost::proto::_default::impl2	access:private
e1	/usr/include/boost/proto/transform/default.hpp	/^                typedef typename result_of::child_c<Expr, 1>::type e1;$/;"	t	struct:boost::proto::_default::memfun_impl	access:private
e2	/usr/include/boost/proto/context/default.hpp	/^                typedef typename proto::result_of::child_c<Expr, 2>::type e2;$/;"	t	struct:boost::proto::context::default_eval	access:private
e2	/usr/include/boost/proto/transform/default.hpp	/^                typedef typename result_of::child_c<Expr, 2>::type e2;$/;"	t	struct:boost::proto::_default::impl2	access:private
enable_unary	/usr/include/boost/proto/operators.hpp	/^        struct enable_unary$/;"	s	namespace:boost::proto::detail	inherits:boost::enable_if_c
enable_unary	/usr/include/boost/proto/operators.hpp	/^        struct enable_unary<deduce_domain, Trait, Arg, Expr>$/;"	s	namespace:boost::proto::detail	inherits:boost::enable_if_c
enable_unary	/usr/include/boost/proto/operators.hpp	/^        struct enable_unary<default_domain, Trait, Arg, Expr>$/;"	s	namespace:boost::proto::detail	inherits:boost::enable_if_c
end_impl	/usr/include/boost/proto/detail/reverse.hpp	/^        struct end_impl<reverse_view_tag>$/;"	s	namespace:boost::fusion::meta
end_impl	/usr/include/boost/proto/fusion.hpp	/^        struct end_impl<proto::tag::proto_expr>$/;"	s	namespace:boost::fusion::extension
end_impl	/usr/include/boost/proto/fusion.hpp	/^        struct end_impl<proto::tag::proto_flat_view>$/;"	s	namespace:boost::fusion::extension
equal_to	/usr/include/boost/proto/tags.hpp	/^    struct equal_to {};$/;"	s	namespace:boost::proto::tag
eval	/usr/include/boost/proto/context/callable.hpp	/^                struct eval$/;"	s	struct:boost::proto::context::callable_context	inherits:mpl::if_c::type	access:public
eval	/usr/include/boost/proto/context/default.hpp	/^                struct eval$/;"	s	struct:boost::proto::context::default_context	inherits:default_eval	access:public
EVAL	/usr/include/boost/proto/context/default.hpp	310;"	d
EVAL	/usr/include/boost/proto/context/default.hpp	377;"	d
eval	/usr/include/boost/proto/context/null.hpp	/^            struct eval$/;"	s	struct:boost::proto::context::null_context	inherits:null_eval	access:public
eval	/usr/include/boost/proto/eval.hpp	/^        struct eval$/;"	s	namespace:boost::proto::functional
eval	/usr/include/boost/proto/eval.hpp	/^        struct eval$/;"	s	namespace:boost::proto::result_of
eval	/usr/include/boost/proto/eval.hpp	/^    eval(Expr &e, Context &ctx)$/;"	f	namespace:boost::proto	signature:(Expr &e, Context &ctx)
eval	/usr/include/boost/proto/eval.hpp	/^    eval(Expr &e, Context const &ctx)$/;"	f	namespace:boost::proto	signature:(Expr &e, Context const &ctx)
EVAL	/usr/include/boost/proto/transform/default.hpp	346;"	d
EVAL	/usr/include/boost/proto/transform/default.hpp	449;"	d
eval_fun	/usr/include/boost/proto/fusion.hpp	/^        explicit eval_fun(Context &ctx)$/;"	f	struct:boost::proto::eval_fun	access:public	signature:(Context &ctx)
eval_fun	/usr/include/boost/proto/fusion.hpp	/^    struct eval_fun$/;"	s	namespace:boost::proto
EVAL_TYPE	/usr/include/boost/proto/context/default.hpp	301;"	d
EVAL_TYPE	/usr/include/boost/proto/context/default.hpp	376;"	d
EVAL_TYPE	/usr/include/boost/proto/transform/default.hpp	337;"	d
EVAL_TYPE	/usr/include/boost/proto/transform/default.hpp	448;"	d
exact	/usr/include/boost/proto/matches.hpp	/^            struct exact$/;"	s	namespace:boost::proto::control
exops	/usr/include/boost/proto/proto_fwd.hpp	/^    namespace exops$/;"	n	namespace:boost::proto
expr	/usr/include/boost/proto/fusion.hpp	/^            Expr const &expr;$/;"	m	struct:boost::proto::detail::expr_iterator	access:public
expr	/usr/include/boost/proto/transform/impl.hpp	/^        typedef Expr const expr;$/;"	t	struct:boost::proto::transform_impl	access:public
expr	/usr/include/boost/proto/transform/impl.hpp	/^        typedef Expr expr;$/;"	t	struct:boost::proto::transform_impl	access:public
exprns_	/usr/include/boost/proto/expr.hpp	/^        namespace exprns_$/;"	n	namespace:boost::proto
exprns_	/usr/include/boost/proto/extends.hpp	/^    namespace exprns_$/;"	n	namespace:boost::proto
exprns_	/usr/include/boost/proto/proto_fwd.hpp	/^    namespace exprns_$/;"	n	namespace:boost::proto
expr_	/usr/include/boost/proto/fusion.hpp	/^            Expr &expr_;$/;"	m	struct:boost::proto::detail::flat_view	access:public
expr_	/usr/include/boost/proto/traits.hpp	/^                typedef proto::expr<proto::tag::terminal, term<arg0_>, 0> expr_;$/;"	t	struct:boost::proto::result_of::as_expr	access:public
expr_	/usr/include/boost/proto/traits.hpp	/^                typedef proto::expr<proto::tag::terminal, term<T &>, 0> expr_;$/;"	t	struct:boost::proto::result_of::as_child	access:public
expr_	/usr/include/boost/proto/traits.hpp	/^                typedef typename T::proto_derived_expr expr_; \/\/ removes the const$/;"	t	struct:boost::proto::result_of::as_expr	access:public
expr_iterator	/usr/include/boost/proto/fusion.hpp	/^            expr_iterator(Expr const &e)$/;"	f	struct:boost::proto::detail::expr_iterator	access:public	signature:(Expr const &e)
expr_iterator	/usr/include/boost/proto/fusion.hpp	/^        struct expr_iterator$/;"	s	namespace:boost::proto::detail	inherits:fusion::iterator_base
expr_param	/usr/include/boost/proto/transform/impl.hpp	/^        typedef Expr &expr_param;$/;"	t	struct:boost::proto::transform_impl	access:public
expr_param	/usr/include/boost/proto/transform/impl.hpp	/^        typedef Expr const &expr_param;$/;"	t	struct:boost::proto::transform_impl	access:public
expr_params	/usr/include/boost/proto/generate.hpp	/^            struct expr_params<proto::expr<Tag, Args, N> >$/;"	s	namespace:boost::proto::detail
expr_traits	/usr/include/boost/proto/args.hpp	/^            struct expr_traits$/;"	s	namespace:boost::proto::detail
expr_traits	/usr/include/boost/proto/args.hpp	/^            struct expr_traits<Expr &>$/;"	s	namespace:boost::proto::detail
expr_traits	/usr/include/boost/proto/args.hpp	/^            struct expr_traits<Expr const &>$/;"	s	namespace:boost::proto::detail
expr_type	/usr/include/boost/proto/deep_copy.hpp	/^                typedef typename terminal<actual_terminal_type>::type expr_type;$/;"	t	struct:boost::proto::detail::deep_copy_impl	access:public
expr_type	/usr/include/boost/proto/fusion.hpp	/^            typedef Expr expr_type;$/;"	t	struct:boost::proto::detail::expr_iterator	access:public
expr_type	/usr/include/boost/proto/fusion.hpp	/^            typedef Expr expr_type;$/;"	t	struct:boost::proto::detail::flat_view	access:public
expr_type	/usr/include/boost/proto/operators.hpp	/^            typedef proto::expr<Tag, list2<Left &, Right &>, 2> expr_type;$/;"	t	struct:boost::proto::detail::as_expr_if	access:public
expr_type	/usr/include/boost/proto/operators.hpp	/^            typedef proto::expr<Tag, list2<Left &, typename proto_domain::template result<proto_domain(term_type)>::type>, 2> expr_type;$/;"	t	struct:boost::proto::detail::as_expr_if2	access:public
expr_type	/usr/include/boost/proto/operators.hpp	/^            typedef proto::expr<Tag, list2<typename proto_domain::template result<proto_domain(term_type)>::type, Right &>, 2> expr_type;$/;"	t	struct:boost::proto::detail::as_expr_if2	access:public
extends	/usr/include/boost/proto/extends.hpp	/^            extends()$/;"	f	struct:boost::proto::exprns_::extends	access:public	signature:()
extends	/usr/include/boost/proto/extends.hpp	/^            extends(Expr const &expr_)$/;"	f	struct:boost::proto::exprns_::extends	access:public	signature:(Expr const &expr_)
extends	/usr/include/boost/proto/extends.hpp	/^            extends(extends const &that)$/;"	f	struct:boost::proto::exprns_::extends	access:public	signature:(extends const &that)
extends	/usr/include/boost/proto/extends.hpp	/^        struct extends$/;"	s	namespace:boost::proto::exprns_
extends	/usr/include/boost/proto/extends.hpp	/^        struct extends<Expr, Derived, Domain, 0>$/;"	s	namespace:boost::proto::exprns_
extension	/usr/include/boost/proto/fusion.hpp	/^    namespace extension$/;"	n	namespace:boost::fusion
first	/usr/include/boost/proto/detail/reverse.hpp	/^        first_type first;$/;"	m	struct:boost::fusion::reverse_view	access:public
first	/usr/include/boost/proto/detail/reverse.hpp	/^        first_type first;$/;"	m	struct:boost::fusion::reverse_view_iterator	access:public
first_type	/usr/include/boost/proto/detail/reverse.hpp	/^                typedef typename Iterator::first_type first_type;$/;"	t	struct:boost::fusion::meta::next_impl::apply	access:public
first_type	/usr/include/boost/proto/detail/reverse.hpp	/^                typedef typename Iterator::first_type first_type;$/;"	t	struct:boost::fusion::meta::prior_impl::apply	access:public
first_type	/usr/include/boost/proto/detail/reverse.hpp	/^        typedef typename converter::type first_type;$/;"	t	struct:boost::fusion::reverse_view_iterator	access:public
first_type	/usr/include/boost/proto/detail/reverse.hpp	/^        typedef typename meta::begin<seq>::type first_type;$/;"	t	struct:boost::fusion::reverse_view	access:public
flatten	/usr/include/boost/proto/fusion.hpp	/^        struct flatten$/;"	s	namespace:boost::proto::functional
flatten	/usr/include/boost/proto/fusion.hpp	/^        struct flatten$/;"	s	namespace:boost::proto::result_of	inherits:flatten
flatten	/usr/include/boost/proto/fusion.hpp	/^        struct flatten<Expr &>$/;"	s	namespace:boost::proto::result_of
flatten	/usr/include/boost/proto/fusion.hpp	/^    flatten(Expr &e)$/;"	f	class:boost::proto::proto::detail	signature:(Expr &e)
flatten	/usr/include/boost/proto/fusion.hpp	/^    flatten(Expr const &e)$/;"	f	class:boost::proto::proto::detail	signature:(Expr const &e)
flat_view	/usr/include/boost/proto/fusion.hpp	/^            explicit flat_view(Expr &e)$/;"	f	struct:boost::proto::detail::flat_view	access:public	signature:(Expr &e)
flat_view	/usr/include/boost/proto/fusion.hpp	/^        struct flat_view$/;"	s	namespace:boost::proto::detail
fold	/usr/include/boost/proto/transform/fold.hpp	/^        struct fold : transform<fold<Sequence, State0, Fun> >$/;"	s	namespace:boost::proto	inherits:transform
fold	/usr/include/boost/proto/transform/fold.hpp	/^        struct fold<_, State0, Fun> : transform<fold<_, State0, Fun> >$/;"	s	namespace:boost::proto	inherits:transform
fold_impl	/usr/include/boost/proto/transform/fold.hpp	/^            struct fold_impl$/;"	s	namespace:boost::proto::detail
fold_tree	/usr/include/boost/proto/transform/fold_tree.hpp	/^    struct fold_tree$/;"	s	namespace:boost::proto	inherits:transform
fold_tree_	/usr/include/boost/proto/transform/fold_tree.hpp	/^        struct fold_tree_$/;"	s	namespace:boost::proto::detail	inherits:if_
fun	/usr/include/boost/proto/transform/fold.hpp	/^                fun;$/;"	t	struct:boost::proto::fold::impl	access:public
function	/usr/include/boost/proto/tags.hpp	/^    struct function {};$/;"	s	namespace:boost::proto::tag
functional	/usr/include/boost/proto/deep_copy.hpp	/^        namespace functional$/;"	n	namespace:boost::proto
functional	/usr/include/boost/proto/eval.hpp	/^    namespace functional$/;"	n	namespace:boost::proto
functional	/usr/include/boost/proto/fusion.hpp	/^    namespace functional$/;"	n	namespace:boost::proto
functional	/usr/include/boost/proto/make_expr.hpp	/^        namespace functional$/;"	n	namespace:boost::proto
functional	/usr/include/boost/proto/proto_fwd.hpp	/^    namespace functional$/;"	n	namespace:boost::proto
functional	/usr/include/boost/proto/traits.hpp	/^        namespace functional$/;"	n	namespace:boost::proto
function_type	/usr/include/boost/proto/context/default.hpp	/^                function_type;$/;"	t	struct:boost::proto::context::default_eval	access:public
function_type	/usr/include/boost/proto/detail/poly_function.hpp	/^            typedef Fun function_type;$/;"	t	struct:boost::proto::detail::poly_function_traits	access:public
function_type	/usr/include/boost/proto/transform/default.hpp	/^                function_type;$/;"	t	struct:boost::proto::_default::impl2	access:public
funop	/usr/include/boost/proto/detail/funop.hpp	/^    struct funop<Expr(BOOST_PP_ENUM_PARAMS(BOOST_PP_ITERATION(), A)), This, Domain>$/;"	s	inherits:BOOST_PP_CAT,funop,BOOST_PP_ITERATION
fun_type	/usr/include/boost/proto/context/callable.hpp	/^                typedef private_type_ fun_type(...);$/;"	t	struct:boost::proto::detail::callable_context_wrapper	access:public
fusion	/usr/include/boost/proto/detail/pop_front.hpp	/^namespace boost { namespace fusion$/;"	n	namespace:boost
fusion	/usr/include/boost/proto/detail/reverse.hpp	/^namespace boost { namespace fusion$/;"	n	namespace:boost
fusion	/usr/include/boost/proto/fusion.hpp	/^namespace boost { namespace fusion$/;"	n	namespace:boost
fusion	/usr/include/boost/proto/make_expr.hpp	/^        namespace fusion$/;"	n	namespace:boost
fusion_tag	/usr/include/boost/proto/extends.hpp	/^            typedef boost::proto::tag::proto_expr fusion_tag;$/;"	t	struct:boost::proto::exprns_::virtual_member	access:public
fusion_tag	/usr/include/boost/proto/fusion.hpp	/^            typedef tag::proto_expr_iterator fusion_tag;$/;"	t	struct:boost::proto::detail::expr_iterator	access:public
fusion_tag	/usr/include/boost/proto/fusion.hpp	/^            typedef tag::proto_flat_view fusion_tag;$/;"	t	struct:boost::proto::detail::flat_view	access:public
generate_if	/usr/include/boost/proto/operators.hpp	/^        struct generate_if$/;"	s	namespace:boost::proto::detail	inherits:lazy_enable_if_c
generate_if	/usr/include/boost/proto/operators.hpp	/^        struct generate_if<proto::default_domain, Expr, void>$/;"	s	namespace:boost::proto::detail
generate_if_left	/usr/include/boost/proto/operators.hpp	/^        struct generate_if_left$/;"	s	namespace:boost::proto::detail	inherits:lazy_enable_if_c
generate_if_left	/usr/include/boost/proto/operators.hpp	/^        struct generate_if_left<proto::default_domain, Tag, Left, Right>$/;"	s	namespace:boost::proto::detail
generate_if_right	/usr/include/boost/proto/operators.hpp	/^        struct generate_if_right$/;"	s	namespace:boost::proto::detail	inherits:lazy_enable_if_c
generate_if_right	/usr/include/boost/proto/operators.hpp	/^        struct generate_if_right<proto::default_domain, Tag, Left, Right>$/;"	s	namespace:boost::proto::detail
generator	/usr/include/boost/proto/generate.hpp	/^            struct generator$/;"	s	namespace:boost::proto::generatorns_
generatorns_	/usr/include/boost/proto/generate.hpp	/^        namespace generatorns_$/;"	n	namespace:boost::proto
generatorns_	/usr/include/boost/proto/proto_fwd.hpp	/^    namespace generatorns_$/;"	n	namespace:boost::proto
get	/usr/include/boost/proto/literal.hpp	/^            const_reference get() const$/;"	f	struct:boost::proto::utility::literal	access:public	signature:() const
get	/usr/include/boost/proto/literal.hpp	/^            reference get()$/;"	f	struct:boost::proto::utility::literal	access:public	signature:()
get_pointer	/usr/include/boost/proto/detail/decltype.hpp	/^            get_pointer(T &t)$/;"	f	namespace:boost::proto::detail::get_pointerns	signature:(T &t)
get_pointer	/usr/include/boost/proto/detail/decltype.hpp	/^            get_pointer(T const &t)$/;"	f	namespace:boost::proto::detail::get_pointerns	signature:(T const &t)
get_pointer	/usr/include/boost/proto/detail/decltype.hpp	/^            void *(&get_pointer(...))[2];$/;"	p	namespace:boost::proto::detail::has_get_pointerns	signature:(....)
get_pointerns	/usr/include/boost/proto/detail/decltype.hpp	/^        namespace get_pointerns$/;"	n	namespace:boost::proto::detail
greater	/usr/include/boost/proto/tags.hpp	/^    struct greater {};$/;"	s	namespace:boost::proto::tag
greater_equal	/usr/include/boost/proto/tags.hpp	/^    struct greater_equal {};$/;"	s	namespace:boost::proto::tag
has_get_pointer	/usr/include/boost/proto/detail/decltype.hpp	/^            struct has_get_pointer$/;"	s	namespace:boost::proto::detail::has_get_pointerns
has_get_pointerns	/usr/include/boost/proto/detail/decltype.hpp	/^        namespace has_get_pointerns$/;"	n	namespace:boost::proto::detail
has_tag	/usr/include/boost/proto/transform/fold_tree.hpp	/^        struct has_tag : transform<has_tag<Tag> >$/;"	s	namespace:boost::proto::detail	inherits:transform
hidden_detail_	/usr/include/boost/proto/debug.hpp	/^        namespace hidden_detail_$/;"	n	namespace:boost::proto::tag
if_	/usr/include/boost/proto/matches.hpp	/^            struct if_ : transform<if_<If, Then, Else> >$/;"	s	namespace:boost::proto::control	inherits:transform
if_else_	/usr/include/boost/proto/tags.hpp	/^    struct if_else_ {};$/;"	s	namespace:boost::proto::tag
if_else_	/usr/include/boost/proto/traits.hpp	/^            struct if_else_$/;"	s	namespace:boost::proto::op	inherits:proto::transform
if_vararg	/usr/include/boost/proto/traits.hpp	/^            struct if_vararg$/;"	s	namespace:boost::proto::detail
if_vararg	/usr/include/boost/proto/traits.hpp	/^            struct if_vararg<T, typename T::proto_is_vararg_>$/;"	s	namespace:boost::proto::detail	inherits:T
ignore	/usr/include/boost/proto/proto_fwd.hpp	/^            ignore()$/;"	f	struct:boost::proto::detail::ignore	access:public	signature:()
ignore	/usr/include/boost/proto/proto_fwd.hpp	/^            ignore(T const &)$/;"	f	struct:boost::proto::detail::ignore	access:public	signature:(T const &)
ignore	/usr/include/boost/proto/proto_fwd.hpp	/^        struct ignore$/;"	s	namespace:boost::proto::detail
ignore	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef detail::ignore const ignore;$/;"	t	class:boost::proto::detail
ignore_unused	/usr/include/boost/proto/detail/ignore_unused.hpp	/^        inline void ignore_unused(T const &)$/;"	f	namespace:boost::proto::detail	signature:(T const &)
impl	/usr/include/boost/proto/deep_copy.hpp	/^            struct impl$/;"	s	struct:boost::proto::_deep_copy	inherits:detail::deep_copy_impl	access:public
impl	/usr/include/boost/proto/make_expr.hpp	/^                struct impl$/;"	s	struct:boost::proto::functional::make_expr	inherits:detail::make_expr_	access:public
impl	/usr/include/boost/proto/matches.hpp	/^                struct impl : transform_impl<Expr, State, Data>$/;"	s	struct:boost::proto::control::if_	inherits:transform_impl	access:public
impl	/usr/include/boost/proto/matches.hpp	/^                struct impl : transform_impl<Expr, State, Data>$/;"	s	struct:boost::proto::control::not_	inherits:transform_impl	access:public
impl	/usr/include/boost/proto/matches.hpp	/^                struct impl : transform_impl<Expr, State, Data>$/;"	s	struct:boost::proto::wildcardns_::_	inherits:transform_impl	access:public
impl	/usr/include/boost/proto/matches.hpp	/^                struct impl$/;"	s	struct:boost::proto::control::and_	inherits:detail::last::type::,impl	access:public
impl	/usr/include/boost/proto/matches.hpp	/^                struct impl$/;"	s	struct:boost::proto::control::or_	inherits:detail::matches_::which::,impl	access:public
impl	/usr/include/boost/proto/matches.hpp	/^                struct impl$/;"	s	struct:boost::proto::control::switch_	inherits:Cases::,case_::,impl	access:public
impl	/usr/include/boost/proto/matches.hpp	/^                struct impl<Expr &, State, Data>$/;"	s	struct:boost::proto::control::or_	inherits:detail::matches_::which::,impl	access:public
impl	/usr/include/boost/proto/matches.hpp	/^                struct impl<Expr &, State, Data>$/;"	s	struct:boost::proto::control::switch_	inherits:Cases::,case_::,impl	access:public
impl	/usr/include/boost/proto/traits.hpp	/^                struct impl : transform_impl<Expr, State, Data>$/;"	s	struct:boost::proto::op::nullary_expr	inherits:transform_impl	access:public
impl	/usr/include/boost/proto/traits.hpp	/^                struct impl : transform_impl<Expr, State, Data>$/;"	s	struct:boost::proto::op::terminal	inherits:transform_impl	access:public
impl	/usr/include/boost/proto/traits.hpp	/^                struct impl$/;"	s	struct:boost::proto::op::binary_expr	inherits:detail::pass_through_impl	access:public
impl	/usr/include/boost/proto/traits.hpp	/^                struct impl$/;"	s	struct:boost::proto::op::if_else_	inherits:detail::pass_through_impl	access:public
impl	/usr/include/boost/proto/traits.hpp	/^                struct impl$/;"	s	struct:boost::proto::op::unary_expr	inherits:detail::pass_through_impl	access:public
impl	/usr/include/boost/proto/transform/arg.hpp	/^        struct impl : transform_impl<Expr, State, Data>$/;"	s	struct:boost::proto::_child_c	inherits:transform_impl	access:public
impl	/usr/include/boost/proto/transform/arg.hpp	/^        struct impl : transform_impl<Expr, State, Data>$/;"	s	struct:boost::proto::_data	inherits:transform_impl	access:public
impl	/usr/include/boost/proto/transform/arg.hpp	/^        struct impl : transform_impl<Expr, State, Data>$/;"	s	struct:boost::proto::_expr	inherits:transform_impl	access:public
impl	/usr/include/boost/proto/transform/arg.hpp	/^        struct impl : transform_impl<Expr, State, Data>$/;"	s	struct:boost::proto::_state	inherits:transform_impl	access:public
impl	/usr/include/boost/proto/transform/arg.hpp	/^        struct impl : transform_impl<Expr, State, Data>$/;"	s	struct:boost::proto::_value	inherits:transform_impl	access:public
impl	/usr/include/boost/proto/transform/call.hpp	/^            struct impl$/;"	s	struct:boost::proto::call	inherits:impl2	access:public
impl	/usr/include/boost/proto/transform/default.hpp	/^            struct impl$/;"	s	struct:boost::proto::_default	inherits:impl2	access:public
impl	/usr/include/boost/proto/transform/fold.hpp	/^            struct impl : transform_impl<Expr, State, Data>$/;"	s	struct:boost::proto::fold	inherits:transform_impl	access:public
impl	/usr/include/boost/proto/transform/fold.hpp	/^            struct impl$/;"	s	struct:boost::proto::fold	inherits:detail::fold_impl	access:public
impl	/usr/include/boost/proto/transform/fold.hpp	/^            struct impl$/;"	s	struct:boost::proto::reverse_fold	inherits:detail::reverse_fold_impl	access:public
impl	/usr/include/boost/proto/transform/fold_tree.hpp	/^            struct impl$/;"	s	struct:boost::proto::detail::has_tag	inherits:transform_impl	access:public
impl	/usr/include/boost/proto/transform/fold_tree.hpp	/^            struct impl<Expr &, State, Data, typename Expr::proto_tag>$/;"	s	struct:boost::proto::detail::has_tag	inherits:transform_impl	access:public
impl	/usr/include/boost/proto/transform/fold_tree.hpp	/^            struct impl<Expr, State, Data, typename Expr::proto_tag>$/;"	s	struct:boost::proto::detail::has_tag	inherits:transform_impl	access:public
impl	/usr/include/boost/proto/transform/fold_tree.hpp	/^        struct impl$/;"	s	struct:boost::proto::fold_tree	inherits:fold::,impl	access:public
impl	/usr/include/boost/proto/transform/fold_tree.hpp	/^        struct impl$/;"	s	struct:boost::proto::reverse_fold_tree	inherits:reverse_fold::,impl	access:public
impl	/usr/include/boost/proto/transform/lazy.hpp	/^            struct impl$/;"	s	struct:boost::proto::lazy	inherits:call::,impl	access:public
impl	/usr/include/boost/proto/transform/make.hpp	/^            struct impl : transform_impl<Expr, State, Data>$/;"	s	struct:boost::proto::make	inherits:transform_impl	access:public
impl	/usr/include/boost/proto/transform/make.hpp	/^            struct impl$/;"	s	struct:boost::proto::protect	access:public
impl	/usr/include/boost/proto/transform/pass_through.hpp	/^            struct impl$/;"	s	struct:boost::proto::pass_through	inherits:detail::pass_through_impl	access:public
impl2	/usr/include/boost/proto/transform/call.hpp	/^            struct impl2$/;"	s	struct:boost::proto::call	inherits:transform_impl	access:public
impl2	/usr/include/boost/proto/transform/call.hpp	/^            struct impl2<Expr, State, Data, true>$/;"	s	struct:boost::proto::call	inherits:Fun::,impl	access:public
impl2	/usr/include/boost/proto/transform/call.hpp	/^            struct impl2<Expr, State, Data, true>$/;"	s	struct:boost::proto::call	inherits:transform_impl	access:public
impl2	/usr/include/boost/proto/transform/default.hpp	/^            struct impl2<Expr, State, Data, Tag, 0>$/;"	s	struct:boost::proto::_default	inherits:_value::impl	access:public
impl2	/usr/include/boost/proto/transform/default.hpp	/^            struct impl2<Expr, State, Data, tag::comma, 2>$/;"	s	struct:boost::proto::_default	inherits:transform_impl	access:public
impl2	/usr/include/boost/proto/transform/default.hpp	/^            struct impl2<Expr, State, Data, tag::function, 1>$/;"	s	struct:boost::proto::_default	inherits:transform_impl	access:public
impl2	/usr/include/boost/proto/transform/default.hpp	/^            struct impl2<Expr, State, Data, tag::function, 2>$/;"	s	struct:boost::proto::_default	inherits:transform_impl	access:public
impl2	/usr/include/boost/proto/transform/default.hpp	/^            struct impl2<Expr, State, Data, tag::if_else_, 3>$/;"	s	struct:boost::proto::_default	inherits:transform_impl	access:public
impl2	/usr/include/boost/proto/transform/default.hpp	/^            struct impl2<Expr, State, Data, tag::mem_ptr, 2>$/;"	s	struct:boost::proto::_default	inherits:memfun_impl	access:public
impl2	/usr/include/boost/proto/transform/default.hpp	/^            struct impl2<Expr, State, Data, tag::post_dec, 1>$/;"	s	struct:boost::proto::_default	inherits:transform_impl	access:public
impl2	/usr/include/boost/proto/transform/default.hpp	/^            struct impl2<Expr, State, Data, tag::post_inc, 1>$/;"	s	struct:boost::proto::_default	inherits:transform_impl	access:public
impl2	/usr/include/boost/proto/transform/default.hpp	/^            struct impl2<Expr, State, Data, tag::subscript, 2>$/;"	s	struct:boost::proto::_default	inherits:transform_impl	access:public
implicit_expr	/usr/include/boost/proto/make_expr.hpp	/^        implicit_expr(A0 &a0)$/;"	f	class:boost::proto::detail	signature:(A0 &a0)
implicit_expr_1	/usr/include/boost/proto/make_expr.hpp	/^            struct implicit_expr_1$/;"	s	namespace:boost::proto::detail
implicit_expr_1	/usr/include/boost/proto/make_expr.hpp	/^            struct implicit_expr_1<A0, typename A0::proto_is_expr_>$/;"	s	namespace:boost::proto::detail
implicit_expr_wrap	/usr/include/boost/proto/make_expr.hpp	/^            Expr implicit_expr_wrap(Base const &e, mpl::false_, Expr *)$/;"	f	namespace:boost::proto::detail	signature:(Base const &e, mpl::false_, Expr *)
implicit_expr_wrap	/usr/include/boost/proto/make_expr.hpp	/^            Expr implicit_expr_wrap(Base const &e, mpl::true_, Expr *)$/;"	f	namespace:boost::proto::detail	signature:(Base const &e, mpl::true_, Expr *)
invoke	/usr/include/boost/proto/context/default.hpp	/^                result_type invoke(Expr &expr, Context &context, mpl::false_, mpl::false_) const$/;"	f	struct:boost::proto::context::default_eval	access:private	signature:(Expr &expr, Context &context, mpl::false_, mpl::false_) const
invoke	/usr/include/boost/proto/context/default.hpp	/^                result_type invoke(Expr &expr, Context &context, mpl::false_, mpl::true_) const$/;"	f	struct:boost::proto::context::default_eval	access:private	signature:(Expr &expr, Context &context, mpl::false_, mpl::true_) const
invoke	/usr/include/boost/proto/context/default.hpp	/^                result_type invoke(Expr &expr, Context &context, mpl::true_, mpl::false_) const$/;"	f	struct:boost::proto::context::default_eval	access:private	signature:(Expr &expr, Context &context, mpl::true_, mpl::false_) const
invoke	/usr/include/boost/proto/transform/default.hpp	/^                result_type invoke($/;"	f	struct:boost::proto::_default::impl2	access:private	signature:( typename impl2::expr_param e , typename impl2::state_param s , typename impl2::data_param d , mpl::false_ , mpl::false_ ) const
invoke	/usr/include/boost/proto/transform/default.hpp	/^                result_type invoke($/;"	f	struct:boost::proto::_default::impl2	access:private	signature:( typename impl2::expr_param e , typename impl2::state_param s , typename impl2::data_param d , mpl::false_ , mpl::true_ ) const
invoke	/usr/include/boost/proto/transform/default.hpp	/^                result_type invoke($/;"	f	struct:boost::proto::_default::impl2	access:private	signature:( typename impl2::expr_param e , typename impl2::state_param s , typename impl2::data_param d , mpl::true_ , mpl::false_ ) const
is_aggregate	/usr/include/boost/proto/traits.hpp	/^        struct is_aggregate$/;"	s	namespace:boost::proto	inherits:is_pod
is_aggregate	/usr/include/boost/proto/traits.hpp	/^        struct is_aggregate<proto::expr<Tag, Args, N>, void>$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_aggregate	/usr/include/boost/proto/traits.hpp	/^        struct is_aggregate<T, typename T::proto_is_aggregate_>$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/fusion.hpp	/^    struct is_callable<functional::flatten>$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/fusion.hpp	/^    struct is_callable<functional::pop_front>$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/fusion.hpp	/^    struct is_callable<functional::reverse>$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/generate.hpp	/^        struct is_callable<by_value_generator>$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/generate.hpp	/^        struct is_callable<compose_generators<First, Second> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/generate.hpp	/^        struct is_callable<default_generator>$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/generate.hpp	/^        struct is_callable<generator<Extends> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/generate.hpp	/^        struct is_callable<pod_generator<Extends> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/make_expr.hpp	/^        struct is_callable<functional::make_expr<Tag, Domain> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/make_expr.hpp	/^        struct is_callable<functional::unfused_expr<Tag, Domain> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/make_expr.hpp	/^        struct is_callable<functional::unpack_expr<Tag, Domain> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/matches.hpp	/^        struct is_callable<and_<BOOST_PP_ENUM_PARAMS(BOOST_PROTO_MAX_LOGICAL_ARITY, G)> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/matches.hpp	/^        struct is_callable<if_<If, Then, Else> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/matches.hpp	/^        struct is_callable<not_<Grammar> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/matches.hpp	/^        struct is_callable<or_<BOOST_PP_ENUM_PARAMS(BOOST_PROTO_MAX_LOGICAL_ARITY, G)> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/matches.hpp	/^        struct is_callable<vararg<Grammar> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/traits.hpp	/^        struct is_callable$/;"	s	namespace:boost::proto	inherits:proto::detail::is_callable_
is_callable	/usr/include/boost/proto/traits.hpp	/^        struct is_callable<functional::as_child<Domain> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/traits.hpp	/^        struct is_callable<functional::as_expr<Domain> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/traits.hpp	/^        struct is_callable<functional::child<N> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/traits.hpp	/^        struct is_callable<functional::child_c<N> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/traits.hpp	/^        struct is_callable<proto::callable>$/;"	s	namespace:boost::proto	inherits:mpl::false_
is_callable	/usr/include/boost/proto/traits.hpp	/^        struct is_callable<proto::expr<Tag, Args, N> >$/;"	s	namespace:boost::proto	inherits:mpl::false_
is_callable	/usr/include/boost/proto/traits.hpp	/^        struct is_callable<proto::_>$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/transform/arg.hpp	/^    struct is_callable<_byref>$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/transform/arg.hpp	/^    struct is_callable<_byval>$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/transform/arg.hpp	/^    struct is_callable<_child_c<N> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/transform/arg.hpp	/^    struct is_callable<_data>$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/transform/arg.hpp	/^    struct is_callable<_expr>$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/transform/arg.hpp	/^    struct is_callable<_state>$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/transform/arg.hpp	/^    struct is_callable<_value>$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/transform/call.hpp	/^        struct is_callable<call<Fun> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/transform/default.hpp	/^        struct is_callable<_default<Grammar> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/transform/fold.hpp	/^        struct is_callable<fold<Sequence, State, Fun> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/transform/fold.hpp	/^        struct is_callable<reverse_fold<Sequence, State, Fun> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/transform/fold_tree.hpp	/^    struct is_callable<fold_tree<Sequence, State0, Fun> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/transform/fold_tree.hpp	/^    struct is_callable<reverse_fold_tree<Sequence, State0, Fun> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/transform/lazy.hpp	/^        struct is_callable<lazy<Object> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/transform/make.hpp	/^        struct is_callable<make<Object> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/transform/make.hpp	/^        struct is_callable<protect<PrimitiveTransform> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable	/usr/include/boost/proto/transform/pass_through.hpp	/^        struct is_callable<pass_through<Grammar> >$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_callable2_	/usr/include/boost/proto/traits.hpp	/^            struct is_callable2_$/;"	s	namespace:boost::proto::detail	inherits:mpl::false_
is_callable2_	/usr/include/boost/proto/traits.hpp	/^            struct is_callable2_<T, typename T::proto_is_callable_>$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
is_callable_	/usr/include/boost/proto/traits.hpp	/^            struct is_callable_$/;"	s	namespace:boost::proto::detail	inherits:is_callable2_
is_cv_ref_compatible	/usr/include/boost/proto/matches.hpp	/^            struct is_cv_ref_compatible$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
is_cv_ref_compatible	/usr/include/boost/proto/matches.hpp	/^            struct is_cv_ref_compatible<T &, U &>$/;"	s	namespace:boost::proto::detail	inherits:mpl::bool_
is_cv_ref_compatible	/usr/include/boost/proto/matches.hpp	/^            struct is_cv_ref_compatible<T, U &>$/;"	s	namespace:boost::proto::detail	inherits:mpl::false_
is_domain	/usr/include/boost/proto/domain.hpp	/^        struct is_domain$/;"	s	namespace:boost::proto::result_of	inherits:mpl::false_
is_domain	/usr/include/boost/proto/domain.hpp	/^        struct is_domain<T, typename T::proto_is_domain_>$/;"	s	namespace:boost::proto::result_of	inherits:mpl::true_
is_expr	/usr/include/boost/proto/traits.hpp	/^            struct is_expr$/;"	s	namespace:boost::proto::result_of	inherits:mpl::false_
is_expr	/usr/include/boost/proto/traits.hpp	/^            struct is_expr<T &, void>$/;"	s	namespace:boost::proto::result_of	inherits:is_expr
is_expr	/usr/include/boost/proto/traits.hpp	/^            struct is_expr<T, typename T::proto_is_expr_>$/;"	s	namespace:boost::proto::result_of	inherits:mpl::true_
is_expr_handled	/usr/include/boost/proto/context/callable.hpp	/^            struct is_expr_handled<Expr, Context, 0>$/;"	s	namespace:boost::proto::detail
is_member_function_eval	/usr/include/boost/proto/context/default.hpp	/^            struct is_member_function_eval$/;"	s	namespace:boost::proto::context	inherits:is_member_function_pointer
is_member_function_invocation	/usr/include/boost/proto/transform/default.hpp	/^            struct is_member_function_invocation$/;"	s	struct:boost::proto::_default	inherits:is_member_function_pointer	access:public
is_poly_function	/usr/include/boost/proto/detail/poly_function.hpp	/^        struct is_poly_function$/;"	s	namespace:boost::proto::detail	inherits:mpl::false_
is_poly_function	/usr/include/boost/proto/detail/poly_function.hpp	/^        struct is_poly_function<T, typename T::is_poly_function_base_>$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
is_proto_expr	/usr/include/boost/proto/extends.hpp	/^        struct is_proto_expr$/;"	s	namespace:boost::proto::exprns_
is_segmented_impl	/usr/include/boost/proto/fusion.hpp	/^        struct is_segmented_impl<proto::tag::proto_flat_view>$/;"	s	namespace:boost::fusion::extension
is_transform	/usr/include/boost/proto/traits.hpp	/^        struct is_transform$/;"	s	namespace:boost::proto	inherits:mpl::false_
is_transform	/usr/include/boost/proto/traits.hpp	/^        struct is_transform<T, typename T::proto_is_transform_>$/;"	s	namespace:boost::proto	inherits:mpl::true_
is_view_impl	/usr/include/boost/proto/fusion.hpp	/^        struct is_view_impl<proto::tag::proto_expr>$/;"	s	namespace:boost::fusion::extension
is_view_impl	/usr/include/boost/proto/fusion.hpp	/^        struct is_view_impl<proto::tag::proto_flat_view>$/;"	s	namespace:boost::fusion::extension
lambda_matches	/usr/include/boost/proto/matches.hpp	/^            struct lambda_matches$/;"	s	namespace:boost::proto::detail	inherits:mpl::false_
lambda_matches	/usr/include/boost/proto/matches.hpp	/^            struct lambda_matches<T, proto::_ BOOST_MPL_AUX_LAMBDA_ARITY_PARAM(-1)>$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
lambda_matches	/usr/include/boost/proto/matches.hpp	/^            struct lambda_matches<T, T BOOST_MPL_AUX_LAMBDA_ARITY_PARAM(-1)>$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
lambda_matches	/usr/include/boost/proto/matches.hpp	/^            struct lambda_matches<T<Expr0>, T<Grammar0> BOOST_MPL_AUX_LAMBDA_ARITY_PARAM(1) >$/;"	s	namespace:boost::proto::detail	inherits:lambda_matches
lambda_matches	/usr/include/boost/proto/matches.hpp	/^            struct lambda_matches<T[M], T[M] BOOST_MPL_AUX_LAMBDA_ARITY_PARAM(-1)>$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
lambda_matches	/usr/include/boost/proto/matches.hpp	/^            struct lambda_matches<T[M], U BOOST_MPL_AUX_LAMBDA_ARITY_PARAM(-1)>$/;"	s	namespace:boost::proto::detail	inherits:array_matches
last	/usr/include/boost/proto/detail/reverse.hpp	/^        last_type last;$/;"	m	struct:boost::fusion::reverse_view	access:public
last	/usr/include/boost/proto/matches.hpp	/^            struct last<proto::and_<> >$/;"	s	namespace:boost::proto::detail
last	/usr/include/boost/proto/matches.hpp	/^            struct last<proto::and_<G0> >$/;"	s	namespace:boost::proto::detail
last_type	/usr/include/boost/proto/detail/reverse.hpp	/^        typedef typename meta::end<seq>::type last_type;$/;"	t	struct:boost::fusion::reverse_view	access:public
lazy	/usr/include/boost/proto/transform/lazy.hpp	/^        struct lazy : transform<lazy<Object> >$/;"	s	namespace:boost::proto	inherits:transform
left	/usr/include/boost/proto/traits.hpp	/^            struct left$/;"	s	namespace:boost::proto::functional
left	/usr/include/boost/proto/traits.hpp	/^            struct left$/;"	s	namespace:boost::proto::result_of	inherits:child_c
left	/usr/include/boost/proto/traits.hpp	/^        left(Expr const &e)$/;"	f	namespace:boost::proto	signature:(Expr const &e)
less	/usr/include/boost/proto/tags.hpp	/^    struct less {};$/;"	s	namespace:boost::proto::tag
less_equal	/usr/include/boost/proto/tags.hpp	/^    struct less_equal {};$/;"	s	namespace:boost::proto::tag
lit	/usr/include/boost/proto/literal.hpp	/^    inline literal<T &> const lit(T &t)$/;"	f	namespace:boost::proto	signature:(T &t)
lit	/usr/include/boost/proto/literal.hpp	/^    inline literal<T const &> const lit(T const &t)$/;"	f	namespace:boost::proto	signature:(T const &t)
literal	/usr/include/boost/proto/literal.hpp	/^            literal(literal<U, Domain> const &u)$/;"	f	struct:boost::proto::utility::literal	access:public	signature:(literal<U, Domain> const &u)
literal	/usr/include/boost/proto/literal.hpp	/^            literal(U &u)$/;"	f	struct:boost::proto::utility::literal	access:public	signature:(U &u)
literal	/usr/include/boost/proto/literal.hpp	/^            literal(U const &u)$/;"	f	struct:boost::proto::utility::literal	access:public	signature:(U const &u)
literal	/usr/include/boost/proto/literal.hpp	/^        struct literal$/;"	s	namespace:boost::proto::utility	inherits:extends
logical_and	/usr/include/boost/proto/tags.hpp	/^    struct logical_and {};$/;"	s	namespace:boost::proto::tag
logical_not	/usr/include/boost/proto/tags.hpp	/^    struct logical_not {};$/;"	s	namespace:boost::proto::tag
logical_or	/usr/include/boost/proto/tags.hpp	/^    struct logical_or {};$/;"	s	namespace:boost::proto::tag
lvalue	/usr/include/boost/proto/detail/decltype.hpp	/^        T &lvalue(T &t)$/;"	f	namespace:boost::proto::detail	signature:(T &t)
lvalue	/usr/include/boost/proto/detail/decltype.hpp	/^        T const &lvalue(T const &t)$/;"	f	namespace:boost::proto::detail	signature:(T const &t)
M0	/usr/include/boost/proto/detail/decltype.hpp	68;"	d
M0	/usr/include/boost/proto/detail/decltype.hpp	70;"	d
M0	/usr/include/boost/proto/detail/funop.hpp	13;"	d
M0	/usr/include/boost/proto/detail/funop.hpp	63;"	d
M0	/usr/include/boost/proto/proto_fwd.hpp	150;"	d
M0	/usr/include/boost/proto/proto_fwd.hpp	154;"	d
M0	/usr/include/boost/proto/proto_fwd.hpp	159;"	d
M0	/usr/include/boost/proto/proto_fwd.hpp	161;"	d
M0	/usr/include/boost/proto/proto_fwd.hpp	730;"	d
M0	/usr/include/boost/proto/proto_fwd.hpp	737;"	d
M1	/usr/include/boost/proto/detail/funop.hpp	17;"	d
M1	/usr/include/boost/proto/detail/funop.hpp	64;"	d
make	/usr/include/boost/proto/detail/decltype.hpp	/^                    BOOST_PROTO_GET_POINTER(V, proto::detail::make_mutable<T>()) ->* proto::detail::make<U>()$/;"	p	class:boost::proto::detail::get_pointerns::mem_ptr_fun::proto::detail	access:public	signature:()
make	/usr/include/boost/proto/detail/decltype.hpp	/^                    proto::detail::make_mutable<T>() ->* proto::detail::make<U>()$/;"	p	class:boost::proto::detail::get_pointerns::mem_ptr_fun::proto::detail	access:public	signature:()
make	/usr/include/boost/proto/detail/decltype.hpp	/^        T make();$/;"	p	namespace:boost::proto::detail	signature:()
make	/usr/include/boost/proto/generate.hpp	/^                static type const make(Expr const &e)$/;"	f	struct:boost::proto::detail::by_value_generator_	access:public	signature:(Expr const &e)
make	/usr/include/boost/proto/operators.hpp	/^            make(Left &left, Right &right)$/;"	f	struct:boost::proto::detail::as_expr_if	access:public	signature:(Left &left, Right &right)
make	/usr/include/boost/proto/operators.hpp	/^            make(Left &left, Right &right)$/;"	f	struct:boost::proto::detail::as_expr_if2	access:public	signature:(Left &left, Right &right)
make	/usr/include/boost/proto/transform/make.hpp	/^        struct make : transform<make<Object> >$/;"	s	namespace:boost::proto	inherits:transform
make_	/usr/include/boost/proto/transform/make.hpp	/^            struct make_$/;"	s	namespace:boost::proto::detail
make_address_of	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::address_of>          make_address_of;$/;"	t	namespace:boost::proto::functional
make_assign	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::assign>              make_assign;$/;"	t	namespace:boost::proto::functional
make_bitwise_and	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::bitwise_and>         make_bitwise_and;$/;"	t	namespace:boost::proto::functional
make_bitwise_and_assign	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::bitwise_and_assign>  make_bitwise_and_assign;$/;"	t	namespace:boost::proto::functional
make_bitwise_or	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::bitwise_or>          make_bitwise_or;$/;"	t	namespace:boost::proto::functional
make_bitwise_or_assign	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::bitwise_or_assign>   make_bitwise_or_assign;$/;"	t	namespace:boost::proto::functional
make_bitwise_xor	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::bitwise_xor>         make_bitwise_xor;$/;"	t	namespace:boost::proto::functional
make_bitwise_xor_assign	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::bitwise_xor_assign>  make_bitwise_xor_assign;$/;"	t	namespace:boost::proto::functional
make_comma	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::comma>               make_comma;$/;"	t	namespace:boost::proto::functional
make_complement	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::complement>          make_complement;$/;"	t	namespace:boost::proto::functional
make_dereference	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::dereference>         make_dereference;$/;"	t	namespace:boost::proto::functional
make_divides	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::divides>             make_divides;$/;"	t	namespace:boost::proto::functional
make_divides_assign	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::divides_assign>      make_divides_assign;$/;"	t	namespace:boost::proto::functional
make_equal_to	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::equal_to>            make_equal_to;$/;"	t	namespace:boost::proto::functional
make_expr	/usr/include/boost/proto/make_expr.hpp	/^            struct make_expr$/;"	s	namespace:boost::proto::functional
make_expr	/usr/include/boost/proto/make_expr.hpp	/^            struct make_expr$/;"	s	namespace:boost::proto::result_of
make_expr	/usr/include/boost/proto/make_expr.hpp	/^            struct make_expr<$/;"	s	namespace:boost::proto::result_of
make_expr	/usr/include/boost/proto/make_expr.hpp	/^        make_expr(A0 const &a0)$/;"	f	class:boost::proto::lazy_disable_if	signature:(A0 const &a0)
make_expr	/usr/include/boost/proto/make_expr.hpp	/^        make_expr(C0 const &c0)$/;"	f	class:boost::proto::result_of::make_expr	signature:(C0 const &c0)
make_expr_	/usr/include/boost/proto/make_expr.hpp	/^            struct make_expr_$/;"	s	namespace:boost::proto::detail
make_expr_	/usr/include/boost/proto/make_expr.hpp	/^            struct make_expr_<tag::terminal, deduce_domain, A$/;"	s	namespace:boost::proto::detail	inherits:make_expr_
make_expr_	/usr/include/boost/proto/make_expr.hpp	/^            struct make_expr_<tag::terminal, Domain, A$/;"	s	namespace:boost::proto::detail
make_function	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::function>            make_function;$/;"	t	namespace:boost::proto::functional
make_greater	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::greater>             make_greater;$/;"	t	namespace:boost::proto::functional
make_greater_equal	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::greater_equal>       make_greater_equal;$/;"	t	namespace:boost::proto::functional
make_if_	/usr/include/boost/proto/transform/make.hpp	/^            struct make_if_<proto::expr<Tag, Args, N>, Expr, State, Data, false>$/;"	s	namespace:boost::proto::detail
make_if_	/usr/include/boost/proto/transform/make.hpp	/^            struct make_if_<R, Expr, State, Data, false>$/;"	s	namespace:boost::proto::detail	inherits:make_
make_if_	/usr/include/boost/proto/transform/make.hpp	/^            struct make_if_<R, Expr, State, Data, true>$/;"	s	namespace:boost::proto::detail	inherits:remove_const
make_if_else	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::if_else_>            make_if_else;$/;"	t	namespace:boost::proto::functional
make_less	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::less>                make_less;$/;"	t	namespace:boost::proto::functional
make_less_equal	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::less_equal>          make_less_equal;$/;"	t	namespace:boost::proto::functional
make_logical_and	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::logical_and>         make_logical_and;$/;"	t	namespace:boost::proto::functional
make_logical_not	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::logical_not>         make_logical_not;$/;"	t	namespace:boost::proto::functional
make_logical_or	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::logical_or>          make_logical_or;$/;"	t	namespace:boost::proto::functional
make_mem_ptr	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::mem_ptr>             make_mem_ptr;$/;"	t	namespace:boost::proto::functional
make_minus	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::minus>               make_minus;$/;"	t	namespace:boost::proto::functional
make_minus_assign	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::minus_assign>        make_minus_assign;$/;"	t	namespace:boost::proto::functional
make_modulus	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::modulus>             make_modulus;$/;"	t	namespace:boost::proto::functional
make_modulus_assign	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::modulus_assign>      make_modulus_assign;$/;"	t	namespace:boost::proto::functional
make_multiplies	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::multiplies>          make_multiplies;$/;"	t	namespace:boost::proto::functional
make_multiplies_assign	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::multiplies_assign>   make_multiplies_assign;$/;"	t	namespace:boost::proto::functional
make_mutable	/usr/include/boost/proto/detail/decltype.hpp	/^        typename as_mutable<T>::type make_mutable();$/;"	p	namespace:boost::proto::detail	signature:()
make_negate	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::negate>              make_negate;$/;"	t	namespace:boost::proto::functional
make_not_equal_to	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::not_equal_to>        make_not_equal_to;$/;"	t	namespace:boost::proto::functional
make_plus	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::plus>                make_plus;$/;"	t	namespace:boost::proto::functional
make_plus_assign	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::plus_assign>         make_plus_assign;$/;"	t	namespace:boost::proto::functional
make_post_dec	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::post_dec>            make_post_dec;$/;"	t	namespace:boost::proto::functional
make_post_inc	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::post_inc>            make_post_inc;$/;"	t	namespace:boost::proto::functional
make_pre_dec	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::pre_dec>             make_pre_dec;$/;"	t	namespace:boost::proto::functional
make_pre_inc	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::pre_inc>             make_pre_inc;$/;"	t	namespace:boost::proto::functional
make_shift_left	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::shift_left>          make_shift_left;$/;"	t	namespace:boost::proto::functional
make_shift_left_assign	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::shift_left_assign>   make_shift_left_assign;$/;"	t	namespace:boost::proto::functional
make_shift_right	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::shift_right>         make_shift_right;$/;"	t	namespace:boost::proto::functional
make_shift_right_assign	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::shift_right_assign>  make_shift_right_assign;$/;"	t	namespace:boost::proto::functional
make_subscript	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::subscript>           make_subscript;$/;"	t	namespace:boost::proto::functional
make_subscriptable	/usr/include/boost/proto/detail/decltype.hpp	/^        typename as_subscriptable<T>::type make_subscriptable();$/;"	p	namespace:boost::proto::detail	signature:()
make_terminal	/usr/include/boost/proto/expr.hpp	/^            proto::expr<Tag, proto::term<Arg0>, 0> make_terminal(T &t, proto::expr<Tag, proto::term<Arg0>, 0> *)$/;"	f	namespace:boost::proto::detail	signature:(T &t, proto::expr<Tag, proto::term<Arg0>, 0> *)
make_terminal	/usr/include/boost/proto/expr.hpp	/^            proto::expr<Tag, proto::term<Arg0[N]>, 0> make_terminal(T const(&t)[N], proto::expr<Tag, proto::term<Arg0[N]>, 0> *)$/;"	f	namespace:boost::proto::detail	signature:(T const(&t)[N], proto::expr<Tag, proto::term<Arg0[N]>, 0> *)
make_terminal	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::terminal>            make_terminal;$/;"	t	namespace:boost::proto::functional
make_unary_plus	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef make_expr<tag::unary_plus>          make_unary_plus;$/;"	t	namespace:boost::proto::functional
matches	/usr/include/boost/proto/matches.hpp	/^            struct matches$/;"	s	namespace:boost::proto::result_of	inherits:detail::matches_
matches	/usr/include/boost/proto/matches.hpp	/^            struct matches<Expr &, Grammar>$/;"	s	namespace:boost::proto::result_of	inherits:detail::matches_
matches_	/usr/include/boost/proto/matches.hpp	/^            struct matches_$/;"	s	namespace:boost::proto::detail	inherits:mpl::false_
matches_	/usr/include/boost/proto/matches.hpp	/^            struct matches_< Expr, proto::_ >$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
matches_	/usr/include/boost/proto/matches.hpp	/^            struct matches_< proto::expr<Tag, Args1, 0>, proto::expr<proto::_, Args2, 0> >$/;"	s	namespace:boost::proto::detail	inherits:terminal_matches
matches_	/usr/include/boost/proto/matches.hpp	/^            struct matches_< proto::expr<Tag, Args1, 0>, proto::expr<proto::_, Args2, N2> >$/;"	s	namespace:boost::proto::detail	inherits:mpl::false_
matches_	/usr/include/boost/proto/matches.hpp	/^            struct matches_< proto::expr<Tag, Args1, 0>, proto::expr<Tag, Args2, 0> >$/;"	s	namespace:boost::proto::detail	inherits:terminal_matches
matches_	/usr/include/boost/proto/matches.hpp	/^            struct matches_< proto::expr<Tag, Args1, 1>, proto::expr<proto::_, Args2, 1> >$/;"	s	namespace:boost::proto::detail	inherits:matches_
matches_	/usr/include/boost/proto/matches.hpp	/^            struct matches_< proto::expr<Tag, Args1, 1>, proto::expr<Tag, Args2, 1> >$/;"	s	namespace:boost::proto::detail	inherits:matches_
matches_	/usr/include/boost/proto/matches.hpp	/^            struct matches_< proto::expr<Tag, Args1, N1>, proto::expr<proto::_, Args2, N2> >$/;"	s	namespace:boost::proto::detail	inherits:vararg_matchesN2,N2,N1
matches_	/usr/include/boost/proto/matches.hpp	/^            struct matches_< proto::expr<Tag, Args1, N1>, proto::expr<Tag, Args2, N2> >$/;"	s	namespace:boost::proto::detail	inherits:vararg_matchesN2,N2,N1
matches_	/usr/include/boost/proto/matches.hpp	/^            struct matches_<Expr, and_<> >$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
matches_	/usr/include/boost/proto/matches.hpp	/^            struct matches_<Expr, and_<G0> >$/;"	s	namespace:boost::proto::detail	inherits:matches_
matches_	/usr/include/boost/proto/matches.hpp	/^            struct matches_<Expr, not_<Grammar> >$/;"	s	namespace:boost::proto::detail	inherits:mpl::not_
matches_	/usr/include/boost/proto/matches.hpp	/^            struct matches_<Expr, or_<> >$/;"	s	namespace:boost::proto::detail	inherits:mpl::false_
matches_	/usr/include/boost/proto/matches.hpp	/^            struct matches_<Expr, or_<G0> >$/;"	s	namespace:boost::proto::detail	inherits:matches_
matches_	/usr/include/boost/proto/matches.hpp	/^            struct matches_<Expr, proto::if_<If, Then, Else> >$/;"	s	namespace:boost::proto::detail	inherits:mpl::eval_if_c::type
matches_	/usr/include/boost/proto/matches.hpp	/^            struct matches_<Expr, proto::if_<If> >$/;"	s	namespace:boost::proto::detail	inherits:detail::uncvref::type
matches_	/usr/include/boost/proto/matches.hpp	/^            struct matches_<Expr, switch_<Cases> >$/;"	s	namespace:boost::proto::detail	inherits:matches_
member	/usr/include/boost/proto/tags.hpp	/^    struct member {};$/;"	s	namespace:boost::proto::tag
memfun	/usr/include/boost/proto/detail/decltype.hpp	/^            memfun(T t, PMF p)$/;"	f	struct:boost::proto::detail::memfun	access:public	signature:(T t, PMF p)
memfun	/usr/include/boost/proto/detail/decltype.hpp	/^        struct memfun$/;"	s	namespace:boost::proto::detail
memfun_eval	/usr/include/boost/proto/context/default.hpp	/^            struct memfun_eval$/;"	s	namespace:boost::proto::context
memfun_eval	/usr/include/boost/proto/context/default.hpp	/^            struct memfun_eval<Expr, Context, true>$/;"	s	namespace:boost::proto::context
memfun_impl	/usr/include/boost/proto/transform/default.hpp	/^            struct memfun_impl$/;"	s	struct:boost::proto::_default	inherits:transform_impl	access:public
memfun_impl	/usr/include/boost/proto/transform/default.hpp	/^            struct memfun_impl<Expr, State, Data, true>$/;"	s	struct:boost::proto::_default	inherits:transform_impl	access:public
mem_ptr	/usr/include/boost/proto/tags.hpp	/^    struct mem_ptr {};$/;"	s	namespace:boost::proto::tag
mem_ptr_fun	/usr/include/boost/proto/detail/decltype.hpp	/^            struct mem_ptr_fun$/;"	s	namespace:boost::proto::detail::get_pointerns
mem_ptr_fun	/usr/include/boost/proto/detail/decltype.hpp	/^            struct mem_ptr_fun<T, U, true>$/;"	s	namespace:boost::proto::detail::get_pointerns
meta	/usr/include/boost/proto/detail/pop_front.hpp	/^    namespace meta$/;"	n	namespace:boost::fusion
meta	/usr/include/boost/proto/detail/reverse.hpp	/^    namespace meta$/;"	n	namespace:boost::fusion
minus	/usr/include/boost/proto/tags.hpp	/^    struct minus {};$/;"	s	namespace:boost::proto::tag
minus_assign	/usr/include/boost/proto/tags.hpp	/^    struct minus_assign {};$/;"	s	namespace:boost::proto::tag
modulus	/usr/include/boost/proto/tags.hpp	/^    struct modulus {};$/;"	s	namespace:boost::proto::tag
modulus_assign	/usr/include/boost/proto/tags.hpp	/^    struct modulus_assign {};$/;"	s	namespace:boost::proto::tag
mono_function_t	/usr/include/boost/proto/detail/poly_function.hpp	/^        typedef char (&mono_function_t)[2];$/;"	t	namespace:boost::proto::detail
mpl	/usr/include/boost/proto/fusion.hpp	/^namespace boost { namespace mpl$/;"	n	namespace:boost
multiplies	/usr/include/boost/proto/tags.hpp	/^    struct multiplies {};$/;"	s	namespace:boost::proto::tag
multiplies_assign	/usr/include/boost/proto/tags.hpp	/^    struct multiplies_assign {};$/;"	s	namespace:boost::proto::tag
N	/usr/include/boost/proto/proto_fwd.hpp	/^        int const N = INT_MAX;$/;"	m	namespace:boost::proto::control
negate	/usr/include/boost/proto/tags.hpp	/^    struct negate {};$/;"	s	namespace:boost::proto::tag
nested_type	/usr/include/boost/proto/transform/make.hpp	/^            struct nested_type$/;"	s	namespace:boost::proto::detail
nested_type	/usr/include/boost/proto/transform/make.hpp	/^            struct nested_type<T, false>$/;"	s	namespace:boost::proto::detail
nested_type_if	/usr/include/boost/proto/transform/make.hpp	/^            struct nested_type_if$/;"	s	namespace:boost::proto::detail	inherits:nested_type
next_impl	/usr/include/boost/proto/detail/reverse.hpp	/^        struct next_impl<reverse_view_iterator_tag>$/;"	s	namespace:boost::fusion::meta
next_impl	/usr/include/boost/proto/fusion.hpp	/^        struct next_impl<proto::tag::proto_expr_iterator>$/;"	s	namespace:boost::fusion::extension
nondeduced_domain	/usr/include/boost/proto/make_expr.hpp	/^                nondeduced_domain(default_domain);$/;"	p	struct:boost::proto::detail::nondeduced_domain	access:public	signature:(default_domain)
nondeduced_domain	/usr/include/boost/proto/make_expr.hpp	/^                nondeduced_domain(T);$/;"	p	struct:boost::proto::detail::nondeduced_domain	access:public	signature:(T)
nondeduced_domain	/usr/include/boost/proto/make_expr.hpp	/^            struct nondeduced_domain$/;"	s	namespace:boost::proto::detail
nondeduced_domain	/usr/include/boost/proto/make_expr.hpp	/^            struct nondeduced_domain<default_domain>$/;"	s	namespace:boost::proto::detail
normalize_arg	/usr/include/boost/proto/detail/poly_function.hpp	/^        struct normalize_arg$/;"	s	namespace:boost::proto::detail
normalize_arg	/usr/include/boost/proto/detail/poly_function.hpp	/^        struct normalize_arg<boost::reference_wrapper<T> &>$/;"	s	namespace:boost::proto::detail
normalize_arg	/usr/include/boost/proto/detail/poly_function.hpp	/^        struct normalize_arg<boost::reference_wrapper<T> >$/;"	s	namespace:boost::proto::detail
normalize_arg	/usr/include/boost/proto/detail/poly_function.hpp	/^        struct normalize_arg<boost::reference_wrapper<T> const &>$/;"	s	namespace:boost::proto::detail
normalize_arg	/usr/include/boost/proto/detail/poly_function.hpp	/^        struct normalize_arg<T &>$/;"	s	namespace:boost::proto::detail
normalize_arg	/usr/include/boost/proto/detail/poly_function.hpp	/^        struct normalize_arg<T const &>$/;"	s	namespace:boost::proto::detail
not_	/usr/include/boost/proto/matches.hpp	/^            struct not_ : transform<not_<Grammar> >$/;"	s	namespace:boost::proto::control	inherits:transform
not_applied_	/usr/include/boost/proto/transform/make.hpp	/^                typedef void not_applied_;$/;"	t	struct:boost::proto::detail::make_	access:public
not_applied_	/usr/include/boost/proto/transform/make.hpp	/^                typedef void not_applied_;$/;"	t	struct:boost::proto::detail::make_if_	access:public
not_a_generator	/usr/include/boost/proto/domain.hpp	/^        struct not_a_generator$/;"	s	namespace:boost::proto::detail
not_a_grammar	/usr/include/boost/proto/domain.hpp	/^        struct not_a_grammar$/;"	s	namespace:boost::proto::detail
not_a_valid_type	/usr/include/boost/proto/expr.hpp	/^                not_a_valid_type()$/;"	f	struct:boost::proto::detail::not_a_valid_type	access:private	signature:()
not_a_valid_type	/usr/include/boost/proto/expr.hpp	/^            struct not_a_valid_type$/;"	s	namespace:boost::proto::detail
not_equal_to	/usr/include/boost/proto/tags.hpp	/^    struct not_equal_to {};$/;"	s	namespace:boost::proto::tag
not_ostream	/usr/include/boost/proto/debug.hpp	/^            typedef char (&not_ostream)[sizeof(std::ostream)+1];$/;"	t	namespace:boost::proto::tag::hidden_detail_
no_type	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef char (&no_type)[2];$/;"	t	namespace:boost::proto::detail
nullary_expr	/usr/include/boost/proto/traits.hpp	/^            struct nullary_expr$/;"	s	namespace:boost::proto::op	inherits:proto::transform
null_context	/usr/include/boost/proto/context/null.hpp	/^        struct null_context$/;"	s	namespace:boost::proto::context
null_eval	/usr/include/boost/proto/context/null.hpp	/^        struct null_eval$/;"	s	namespace:boost::proto::context
null_eval	/usr/include/boost/proto/context/null.hpp	/^        struct null_eval<Expr, Context, 0>$/;"	s	namespace:boost::proto::context
obj	/usr/include/boost/proto/detail/decltype.hpp	/^            T obj;$/;"	m	struct:boost::proto::detail::memfun	access:private
op	/usr/include/boost/proto/proto_fwd.hpp	/^    namespace op$/;"	n	namespace:boost::proto
op	/usr/include/boost/proto/traits.hpp	/^        namespace op$/;"	n	namespace:boost::proto
operator !	/usr/include/boost/proto/detail/decltype.hpp	/^                any operator!();$/;"	p	struct:boost::proto::detail::anyns::any	access:public	signature:()
operator !=	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator!=(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
operator %	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator%(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
operator %=	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator%=(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
operator &	/usr/include/boost/proto/detail/decltype.hpp	/^                any operator&();$/;"	p	struct:boost::proto::detail::anyns::any	access:public	signature:()
operator &	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator&(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
operator &&	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator&&(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
operator &=	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator&=(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
operator ()	/usr/include/boost/proto/context/callable.hpp	/^                result_type operator ()(Expr &expr, Context &context) const$/;"	f	struct:boost::proto::context::callable_eval	access:public	signature:(Expr &expr, Context &context) const
operator ()	/usr/include/boost/proto/context/default.hpp	/^                result_type const operator ()(Expr &expr, Context &ctx) const$/;"	f	struct:boost::proto::context::memfun_eval	access:public	signature:(Expr &expr, Context &ctx) const
operator ()	/usr/include/boost/proto/context/default.hpp	/^                result_type operator ()(Expr &expr, Context &) const$/;"	f	struct:boost::proto::context::default_eval	access:public	signature:(Expr &expr, Context &) const
operator ()	/usr/include/boost/proto/context/default.hpp	/^                result_type operator ()(Expr &expr, Context &context) const$/;"	f	struct:boost::proto::context::default_eval	access:public	signature:(Expr &expr, Context &context) const
operator ()	/usr/include/boost/proto/context/default.hpp	/^                result_type operator ()(Expr &expr, Context &ctx) const$/;"	f	struct:boost::proto::context::default_eval	access:public	signature:(Expr &expr, Context &ctx) const
operator ()	/usr/include/boost/proto/context/default.hpp	/^                result_type operator ()(Expr &expr, Context &ctx) const$/;"	f	struct:boost::proto::context::memfun_eval	access:public	signature:(Expr &expr, Context &ctx) const
operator ()	/usr/include/boost/proto/context/null.hpp	/^            void operator()(Expr &, Context &) const$/;"	f	struct:boost::proto::context::null_eval	access:public	signature:(Expr &, Context &) const
operator ()	/usr/include/boost/proto/deep_copy.hpp	/^                operator()(Expr const &e) const$/;"	f	struct:boost::proto::functional::deep_copy	access:public	signature:(Expr const &e) const
operator ()	/usr/include/boost/proto/deep_copy.hpp	/^                result_type operator()(Expr2 const &e, S const &, D const &) const$/;"	f	struct:boost::proto::detail::deep_copy_impl	access:public	signature:(Expr2 const &e, S const &, D const &) const
operator ()	/usr/include/boost/proto/detail/decltype.hpp	/^                result_type operator()($/;"	f	struct:boost::proto::detail::get_pointerns::mem_ptr_fun	access:public	signature:( typename add_reference<typename add_const<T>::type>::type t , typename add_reference<typename add_const<U>::type>::type u ) const
operator ()	/usr/include/boost/proto/detail/decltype.hpp	/^                result_type operator()($/;"	f	struct:boost::proto::detail::get_pointerns::mem_ptr_fun	access:public	signature:( typename add_reference<typename add_const<T>::type>::type t , U u ) const
operator ()	/usr/include/boost/proto/detail/decltype.hpp	/^            result_type operator()() const$/;"	f	struct:boost::proto::detail::memfun	access:public	signature:() const
operator ()	/usr/include/boost/proto/detail/poly_function.hpp	/^            NullaryResult operator()() const$/;"	f	struct:boost::proto::detail::poly_function	access:public	signature:() const
operator ()	/usr/include/boost/proto/detail/poly_function.hpp	/^            type operator()() const$/;"	f	struct:boost::proto::detail::arg	access:public	signature:() const
operator ()	/usr/include/boost/proto/eval.hpp	/^            operator ()(Expr &e, Context &ctx) const$/;"	f	struct:boost::proto::functional::eval	access:public	signature:(Expr &e, Context &ctx) const
operator ()	/usr/include/boost/proto/eval.hpp	/^            operator ()(Expr &e, Context const &ctx) const$/;"	f	struct:boost::proto::functional::eval	access:public	signature:(Expr &e, Context const &ctx) const
operator ()	/usr/include/boost/proto/fusion.hpp	/^            operator ()(Expr &e) const$/;"	f	class:boost::proto::detail::as_element::result	access:public	signature:(Expr &e) const
operator ()	/usr/include/boost/proto/fusion.hpp	/^            operator ()(Expr &e) const$/;"	f	class:boost::proto::functional::flatten::proto::detail	access:public	signature:(Expr &e) const
operator ()	/usr/include/boost/proto/fusion.hpp	/^            operator ()(Expr &e) const$/;"	f	struct:boost::proto::functional::pop_front	access:public	signature:(Expr &e) const
operator ()	/usr/include/boost/proto/fusion.hpp	/^            operator ()(Expr &e) const$/;"	f	struct:boost::proto::functional::reverse	access:public	signature:(Expr &e) const
operator ()	/usr/include/boost/proto/fusion.hpp	/^            operator ()(Expr const &e) const$/;"	f	class:boost::proto::detail::as_element::result	access:public	signature:(Expr const &e) const
operator ()	/usr/include/boost/proto/fusion.hpp	/^            operator ()(Expr const &e) const$/;"	f	class:boost::proto::functional::flatten::proto::detail	access:public	signature:(Expr const &e) const
operator ()	/usr/include/boost/proto/fusion.hpp	/^            operator ()(Expr const &e) const$/;"	f	struct:boost::proto::functional::pop_front	access:public	signature:(Expr const &e) const
operator ()	/usr/include/boost/proto/fusion.hpp	/^            operator ()(Expr const &e) const$/;"	f	struct:boost::proto::functional::reverse	access:public	signature:(Expr const &e) const
operator ()	/usr/include/boost/proto/fusion.hpp	/^        operator ()(Expr &e) const$/;"	f	struct:boost::proto::eval_fun	access:public	signature:(Expr &e) const
operator ()	/usr/include/boost/proto/fusion.hpp	/^        operator ()(Expr const &e) const$/;"	f	struct:boost::proto::eval_fun	access:public	signature:(Expr const &e) const
operator ()	/usr/include/boost/proto/generate.hpp	/^                Extends<Expr> operator ()(Expr const &e) const$/;"	f	struct:boost::proto::generatorns_::generator	access:public	signature:(Expr const &e) const
operator ()	/usr/include/boost/proto/generate.hpp	/^                Extends<Expr> operator ()(Expr const &e) const$/;"	f	struct:boost::proto::generatorns_::pod_generator	access:public	signature:(Expr const &e) const
operator ()	/usr/include/boost/proto/generate.hpp	/^                operator ()(Expr const &e) const$/;"	f	struct:boost::proto::generatorns_::default_generator	access:public	signature:(Expr const &e) const
operator ()	/usr/include/boost/proto/generate.hpp	/^                typename result<by_value_generator(Expr)>::type operator ()(Expr const &e) const$/;"	f	struct:boost::proto::generatorns_::by_value_generator	access:public	signature:(Expr const &e) const
operator ()	/usr/include/boost/proto/generate.hpp	/^                typename result<compose_generators(Expr)>::type operator ()(Expr const &e) const$/;"	f	struct:boost::proto::generatorns_::compose_generators	access:public	signature:(Expr const &e) const
operator ()	/usr/include/boost/proto/make_expr.hpp	/^                operator ()(A0 const &a0) const$/;"	f	struct:boost::proto::functional::make_expr	access:public	signature:(A0 const &a0) const
operator ()	/usr/include/boost/proto/make_expr.hpp	/^                operator ()(Sequence const &sequence) const$/;"	f	struct:boost::proto::functional::unfused_expr_fun	access:public	signature:(Sequence const &sequence) const
operator ()	/usr/include/boost/proto/make_expr.hpp	/^                operator ()(Sequence const &sequence) const$/;"	f	struct:boost::proto::functional::unpack_expr	access:public	signature:(Sequence const &sequence) const
operator ()	/usr/include/boost/proto/make_expr.hpp	/^                result_type operator()(typename add_reference<A>::type a) const$/;"	f	struct:boost::proto::detail::make_expr_	access:public	signature:(typename add_reference<A>::type a) const
operator ()	/usr/include/boost/proto/matches.hpp	/^                    operator()($/;"	f	struct:boost::proto::control::not_::impl	access:public	signature:( typename impl::expr_param e , typename impl::state_param , typename impl::data_param ) const
operator ()	/usr/include/boost/proto/matches.hpp	/^                    operator()($/;"	f	struct:boost::proto::wildcardns_::_::impl	access:public	signature:( typename impl::expr_param e , typename impl::state_param , typename impl::data_param ) const
operator ()	/usr/include/boost/proto/matches.hpp	/^                    result_type operator ()($/;"	f	struct:boost::proto::control::if_::impl	access:public	signature:( typename impl::expr_param e , typename impl::state_param s , typename impl::data_param d ) const
operator ()	/usr/include/boost/proto/traits.hpp	/^                    operator ()($/;"	f	struct:boost::proto::op::nullary_expr::impl	access:public	signature:( typename impl::expr_param e , typename impl::state_param , typename impl::data_param ) const
operator ()	/usr/include/boost/proto/traits.hpp	/^                    operator ()($/;"	f	struct:boost::proto::op::terminal::impl	access:public	signature:( typename impl::expr_param e , typename impl::state_param , typename impl::data_param ) const
operator ()	/usr/include/boost/proto/traits.hpp	/^                operator ()(Expr &e) const$/;"	f	struct:boost::proto::functional::child	access:public	signature:(Expr &e) const
operator ()	/usr/include/boost/proto/traits.hpp	/^                operator ()(Expr &e) const$/;"	f	struct:boost::proto::functional::child_c	access:public	signature:(Expr &e) const
operator ()	/usr/include/boost/proto/traits.hpp	/^                operator ()(Expr &e) const$/;"	f	struct:boost::proto::functional::left	access:public	signature:(Expr &e) const
operator ()	/usr/include/boost/proto/traits.hpp	/^                operator ()(Expr &e) const$/;"	f	struct:boost::proto::functional::right	access:public	signature:(Expr &e) const
operator ()	/usr/include/boost/proto/traits.hpp	/^                operator ()(Expr &e) const$/;"	f	struct:boost::proto::functional::value	access:public	signature:(Expr &e) const
operator ()	/usr/include/boost/proto/traits.hpp	/^                operator ()(Expr const &e) const$/;"	f	struct:boost::proto::functional::child	access:public	signature:(Expr const &e) const
operator ()	/usr/include/boost/proto/traits.hpp	/^                operator ()(Expr const &e) const$/;"	f	struct:boost::proto::functional::child_c	access:public	signature:(Expr const &e) const
operator ()	/usr/include/boost/proto/traits.hpp	/^                operator ()(Expr const &e) const$/;"	f	struct:boost::proto::functional::left	access:public	signature:(Expr const &e) const
operator ()	/usr/include/boost/proto/traits.hpp	/^                operator ()(Expr const &e) const$/;"	f	struct:boost::proto::functional::right	access:public	signature:(Expr const &e) const
operator ()	/usr/include/boost/proto/traits.hpp	/^                operator ()(Expr const &e) const$/;"	f	struct:boost::proto::functional::value	access:public	signature:(Expr const &e) const
operator ()	/usr/include/boost/proto/traits.hpp	/^                operator ()(T &t) const$/;"	f	struct:boost::proto::functional::as_child	access:public	signature:(T &t) const
operator ()	/usr/include/boost/proto/traits.hpp	/^                operator ()(T &t) const$/;"	f	struct:boost::proto::functional::as_expr	access:public	signature:(T &t) const
operator ()	/usr/include/boost/proto/traits.hpp	/^                operator ()(T const &t) const$/;"	f	struct:boost::proto::functional::as_child	access:public	signature:(T const &t) const
operator ()	/usr/include/boost/proto/traits.hpp	/^                operator ()(T const &t) const$/;"	f	struct:boost::proto::functional::as_expr	access:public	signature:(T const &t) const
operator ()	/usr/include/boost/proto/traits.hpp	/^                operator ()(T const (&t)[N_]) const$/;"	f	struct:boost::proto::functional::as_expr	access:public	signature:(T const (&t)[N_]) const
operator ()	/usr/include/boost/proto/transform/arg.hpp	/^            operator ()($/;"	f	struct:boost::proto::_child_c::impl	access:public	signature:( typename impl::expr_param e , typename impl::state_param , typename impl::data_param ) const
operator ()	/usr/include/boost/proto/transform/arg.hpp	/^            operator ()($/;"	f	struct:boost::proto::_data::impl	access:public	signature:( typename impl::expr_param , typename impl::state_param , typename impl::data_param d ) const
operator ()	/usr/include/boost/proto/transform/arg.hpp	/^            operator ()($/;"	f	struct:boost::proto::_state::impl	access:public	signature:( typename impl::expr_param , typename impl::state_param s , typename impl::data_param ) const
operator ()	/usr/include/boost/proto/transform/arg.hpp	/^            operator ()($/;"	f	struct:boost::proto::_value::impl	access:public	signature:( typename impl::expr_param e , typename impl::state_param , typename impl::data_param ) const
operator ()	/usr/include/boost/proto/transform/arg.hpp	/^            operator()($/;"	f	struct:boost::proto::_expr::impl	access:public	signature:( typename impl::expr_param e , typename impl::state_param , typename impl::data_param ) const
operator ()	/usr/include/boost/proto/transform/arg.hpp	/^        boost::reference_wrapper<T const> const operator ()(T const &t) const$/;"	f	class:boost::proto::_byref::boost	access:public	signature:(T const &t) const
operator ()	/usr/include/boost/proto/transform/arg.hpp	/^        boost::reference_wrapper<T> const operator ()(T &t) const$/;"	f	class:boost::proto::_byref::boost	access:public	signature:(T &t) const
operator ()	/usr/include/boost/proto/transform/arg.hpp	/^        T operator ()(boost::reference_wrapper<T> const &t) const$/;"	f	struct:boost::proto::_byval	access:public	signature:(boost::reference_wrapper<T> const &t) const
operator ()	/usr/include/boost/proto/transform/arg.hpp	/^        T operator ()(T const &t) const$/;"	f	struct:boost::proto::_byval	access:public	signature:(T const &t) const
operator ()	/usr/include/boost/proto/transform/call.hpp	/^                result_type operator ()($/;"	f	struct:boost::proto::call::impl2	access:public	signature:( typename impl2::expr_param e , typename impl2::state_param s , typename impl2::data_param d ) const
operator ()	/usr/include/boost/proto/transform/call.hpp	/^                result_type operator()($/;"	f	struct:boost::proto::call::impl2	access:public	signature:( typename impl2::expr_param , typename impl2::state_param , typename impl2::data_param ) const
operator ()	/usr/include/boost/proto/transform/default.hpp	/^                result_type const operator ()($/;"	f	struct:boost::proto::_default::memfun_impl	access:public	signature:( typename memfun_impl::expr_param e , typename memfun_impl::state_param s , typename memfun_impl::data_param d ) const
operator ()	/usr/include/boost/proto/transform/default.hpp	/^                result_type operator ()($/;"	f	struct:boost::proto::_default::impl2	access:public	signature:( typename impl2::expr_param e , typename impl2::state_param s , typename impl2::data_param d ) const
operator ()	/usr/include/boost/proto/transform/default.hpp	/^                result_type operator ()($/;"	f	struct:boost::proto::_default::memfun_impl	access:public	signature:( typename memfun_impl::expr_param e , typename memfun_impl::state_param s , typename memfun_impl::data_param d ) const
operator ()	/usr/include/boost/proto/transform/fold.hpp	/^                operator ()(Expr &e, State const &s) const$/;"	f	struct:boost::proto::detail::as_callable	access:public	signature:(Expr &e, State const &s) const
operator ()	/usr/include/boost/proto/transform/fold.hpp	/^                operator ()(State const &s, Expr &e) const$/;"	f	struct:boost::proto::detail::as_callable	access:public	signature:(State const &s, Expr &e) const
operator ()	/usr/include/boost/proto/transform/fold.hpp	/^                result_type operator ()($/;"	f	struct:boost::proto::fold::impl	access:public	signature:( typename impl::expr_param e , typename impl::state_param s , typename impl::data_param d ) const
operator ()	/usr/include/boost/proto/transform/make.hpp	/^                result_type operator ()($/;"	f	struct:boost::proto::make::impl	access:public	signature:( typename impl::expr_param , typename impl::state_param , typename impl::data_param ) const
operator ()	/usr/include/boost/proto/transform/make.hpp	/^                Type operator ()() const$/;"	f	struct:boost::proto::detail::construct_	access:public	signature:() const
operator ()	/usr/include/boost/proto/transform/pass_through.hpp	/^                operator()($/;"	f	struct:boost::proto::detail::pass_through_impl	access:public	signature:( typename pass_through_impl::expr_param e , typename pass_through_impl::state_param , typename pass_through_impl::data_param ) const
operator *	/usr/include/boost/proto/detail/decltype.hpp	/^                any operator*();$/;"	p	struct:boost::proto::detail::anyns::any	access:public	signature:()
operator *	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator*(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
operator *=	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator*=(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
operator +	/usr/include/boost/proto/detail/decltype.hpp	/^                any operator+();$/;"	p	struct:boost::proto::detail::anyns::any	access:public	signature:()
operator +	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator+(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
operator ++	/usr/include/boost/proto/detail/decltype.hpp	/^                any operator++();$/;"	p	struct:boost::proto::detail::anyns::any	access:public	signature:()
operator ++	/usr/include/boost/proto/detail/decltype.hpp	/^                any operator++(int);$/;"	p	struct:boost::proto::detail::anyns::any	access:public	signature:(int)
operator +=	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator+=(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
operator ,	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator,(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
operator ,	/usr/include/boost/proto/proto_fwd.hpp	/^            private_type_ operator ,(int) const;$/;"	p	struct:boost::proto::detail::private_type_	access:public	signature:(int) const
operator -	/usr/include/boost/proto/detail/decltype.hpp	/^                any operator-();$/;"	p	struct:boost::proto::detail::anyns::any	access:public	signature:()
operator -	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator-(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
operator --	/usr/include/boost/proto/detail/decltype.hpp	/^                any operator--();$/;"	p	struct:boost::proto::detail::anyns::any	access:public	signature:()
operator --	/usr/include/boost/proto/detail/decltype.hpp	/^                any operator--(int);$/;"	p	struct:boost::proto::detail::anyns::any	access:public	signature:(int)
operator -=	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator-=(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
operator ->*	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator->*(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
operator /	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator\/(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
operator /=	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator\/=(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
operator <	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator<(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
operator <<	/usr/include/boost/proto/debug.hpp	/^            not_ostream operator<<(std::ostream &, detail::dont_care);$/;"	p	namespace:boost::proto::tag::hidden_detail_	signature:(std::ostream &, detail::dont_care)
operator <<	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator<<(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
operator <<=	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator<<=(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
operator <=	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator<=(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
operator =	/usr/include/boost/proto/context/callable.hpp	/^                callable_context_wrapper &operator =(callable_context_wrapper const &);$/;"	p	struct:boost::proto::detail::callable_context_wrapper	access:private	signature:(callable_context_wrapper const &)
operator =	/usr/include/boost/proto/detail/decltype.hpp	/^                any operator=(any);$/;"	p	struct:boost::proto::detail::anyns::any	access:public	signature:(any)
operator =	/usr/include/boost/proto/detail/poly_function.hpp	/^            arg &operator =(arg const &);$/;"	p	struct:boost::proto::detail::arg	access:private	signature:(arg const &)
operator ==	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator==(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
operator >	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator>(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
operator >=	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator>=(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
operator >>	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator>>(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
operator >>=	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator>>=(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
operator A0 &	/usr/include/boost/proto/make_expr.hpp	/^                operator A0 &() const$/;"	f	struct:boost::proto::detail::implicit_expr_1	access:public	signature:() const
operator Expr	/usr/include/boost/proto/make_expr.hpp	/^                operator Expr() const$/;"	f	struct:boost::proto::detail::implicit_expr_1	access:public	signature:() const
operator fun_type *	/usr/include/boost/proto/context/callable.hpp	/^                operator fun_type *() const;$/;"	p	struct:boost::proto::detail::callable_context_wrapper	access:public	signature:() const
operator proto::expr<Tag, Args, 1>	/usr/include/boost/proto/make_expr.hpp	/^                operator proto::expr<Tag, Args, 1>() const$/;"	f	struct:boost::proto::detail::implicit_expr_1	access:public	signature:() const
operator proto::expr<tag::terminal, Args, 0>	/usr/include/boost/proto/make_expr.hpp	/^                operator proto::expr<tag::terminal, Args, 0>() const$/;"	f	struct:boost::proto::detail::implicit_expr_1	access:public	signature:() const
operator T &	/usr/include/boost/proto/detail/decltype.hpp	/^                operator T &() const volatile;$/;"	p	struct:boost::proto::detail::anyns::any	access:public	signature:() const volatile
operator type	/usr/include/boost/proto/detail/poly_function.hpp	/^            operator type() const$/;"	f	struct:boost::proto::detail::arg	access:public	signature:() const
operator uncv_a0_type &	/usr/include/boost/proto/make_expr.hpp	/^                operator uncv_a0_type &() const$/;"	f	struct:boost::proto::detail::implicit_expr_1	access:public	signature:() const
operator []	/usr/include/boost/proto/detail/decltype.hpp	/^                any operator[](any);$/;"	p	struct:boost::proto::detail::anyns::any	access:public	signature:(any)
operator ^	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator^(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
operator ^=	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator^=(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
operator |	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator|(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
operator |=	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator|=(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
operator ||	/usr/include/boost/proto/detail/decltype.hpp	/^                friend any operator||(any, any);$/;"	p	struct:boost::proto::detail::anyns::any	access:friend	signature:(any, any)
operator ~	/usr/include/boost/proto/detail/decltype.hpp	/^                any operator~();$/;"	p	struct:boost::proto::detail::anyns::any	access:public	signature:()
or_	/usr/include/boost/proto/matches.hpp	/^            struct or_ : transform<or_<BOOST_PP_ENUM_PARAMS(BOOST_PROTO_MAX_LOGICAL_ARITY, G)> >$/;"	s	namespace:boost::proto::control	inherits:transform
otherwise	/usr/include/boost/proto/transform/when.hpp	/^        struct otherwise$/;"	s	namespace:boost::proto	inherits:when
pass_through	/usr/include/boost/proto/transform/pass_through.hpp	/^        struct pass_through$/;"	s	namespace:boost::proto	inherits:transform
pass_through_impl	/usr/include/boost/proto/transform/pass_through.hpp	/^            struct pass_through_impl$/;"	s	namespace:boost::proto::detail
pass_through_impl	/usr/include/boost/proto/transform/pass_through.hpp	/^            struct pass_through_impl<Grammar, Expr, State, Data, 0>$/;"	s	namespace:boost::proto::detail	inherits:transform_impl
plus	/usr/include/boost/proto/tags.hpp	/^    struct plus {};$/;"	s	namespace:boost::proto::tag
plus_assign	/usr/include/boost/proto/tags.hpp	/^    struct plus_assign {};$/;"	s	namespace:boost::proto::tag
pmf	/usr/include/boost/proto/detail/decltype.hpp	/^            PMF pmf;$/;"	m	struct:boost::proto::detail::memfun	access:private
pmf_type	/usr/include/boost/proto/detail/decltype.hpp	/^            typedef typename remove_const<typename remove_reference<PMF>::type>::type pmf_type;$/;"	t	struct:boost::proto::detail::memfun	access:public
pod_generator	/usr/include/boost/proto/generate.hpp	/^            struct pod_generator$/;"	s	namespace:boost::proto::generatorns_
poly_function	/usr/include/boost/proto/detail/poly_function.hpp	/^        struct poly_function$/;"	s	namespace:boost::proto::detail	inherits:poly_function_base
poly_function_base	/usr/include/boost/proto/detail/poly_function.hpp	/^        struct poly_function_base$/;"	s	namespace:boost::proto::detail
poly_function_t	/usr/include/boost/proto/detail/poly_function.hpp	/^        typedef char poly_function_t;$/;"	t	namespace:boost::proto::detail
poly_function_traits	/usr/include/boost/proto/detail/poly_function.hpp	/^        struct poly_function_traits$/;"	s	namespace:boost::proto::detail
poly_function_traits	/usr/include/boost/proto/detail/poly_function.hpp	/^        struct poly_function_traits<Fun, Sig, sizeof(mono_function_t)>$/;"	s	namespace:boost::proto::detail
pop_front	/usr/include/boost/proto/detail/pop_front.hpp	/^        struct pop_front$/;"	s	namespace:boost::fusion::meta
pop_front	/usr/include/boost/proto/detail/pop_front.hpp	/^    pop_front(Sequence const& seq)$/;"	f	namespace:boost::fusion	signature:(Sequence const& seq)
pop_front	/usr/include/boost/proto/fusion.hpp	/^        struct pop_front$/;"	s	namespace:boost::proto::functional
post_dec	/usr/include/boost/proto/tags.hpp	/^    struct post_dec {};$/;"	s	namespace:boost::proto::tag
post_inc	/usr/include/boost/proto/tags.hpp	/^    struct post_inc {};$/;"	s	namespace:boost::proto::tag
pre_dec	/usr/include/boost/proto/tags.hpp	/^    struct pre_dec {};$/;"	s	namespace:boost::proto::tag
pre_inc	/usr/include/boost/proto/tags.hpp	/^    struct pre_inc {};$/;"	s	namespace:boost::proto::tag
printable_tag_	/usr/include/boost/proto/debug.hpp	/^            struct printable_tag_$/;"	s	namespace:boost::proto::tag::hidden_detail_
printable_tag_	/usr/include/boost/proto/debug.hpp	/^            struct printable_tag_<Tag, sizeof(std::ostream)>$/;"	s	namespace:boost::proto::tag::hidden_detail_
prior_impl	/usr/include/boost/proto/detail/reverse.hpp	/^        struct prior_impl<reverse_view_iterator_tag>$/;"	s	namespace:boost::fusion::meta
prior_impl	/usr/include/boost/proto/fusion.hpp	/^        struct prior_impl<proto::tag::proto_expr_iterator>$/;"	s	namespace:boost::fusion::extension
private_type_	/usr/include/boost/proto/proto_fwd.hpp	/^        struct private_type_$/;"	s	namespace:boost::proto::detail
protect	/usr/include/boost/proto/transform/make.hpp	/^        struct protect : transform<protect<PrimitiveTransform> >$/;"	s	namespace:boost::proto	inherits:transform
proto	/usr/include/boost/proto/args.hpp	/^    namespace boost { namespace proto$/;"	n	namespace:boost
proto	/usr/include/boost/proto/context/callable.hpp	/^    namespace boost { namespace proto$/;"	n	namespace:boost
proto	/usr/include/boost/proto/context/default.hpp	/^    namespace boost { namespace proto$/;"	n	namespace:boost
proto	/usr/include/boost/proto/context/null.hpp	/^    namespace boost { namespace proto { namespace context$/;"	n	namespace:boost
proto	/usr/include/boost/proto/debug.hpp	/^namespace boost { namespace proto$/;"	n	namespace:boost
proto	/usr/include/boost/proto/deep_copy.hpp	/^    namespace boost { namespace proto$/;"	n	namespace:boost
proto	/usr/include/boost/proto/detail/as_lvalue.hpp	/^namespace boost { namespace proto$/;"	n	namespace:boost
proto	/usr/include/boost/proto/detail/decltype.hpp	/^namespace boost { namespace proto$/;"	n	namespace:boost
proto	/usr/include/boost/proto/detail/dont_care.hpp	/^namespace boost { namespace proto$/;"	n	namespace:boost
proto	/usr/include/boost/proto/detail/ignore_unused.hpp	/^namespace boost { namespace proto$/;"	n	namespace:boost
proto	/usr/include/boost/proto/detail/poly_function.hpp	/^    namespace boost { namespace proto { namespace detail$/;"	n	namespace:boost
proto	/usr/include/boost/proto/domain.hpp	/^namespace boost { namespace proto$/;"	n	namespace:boost
proto	/usr/include/boost/proto/eval.hpp	/^namespace boost { namespace proto$/;"	n	namespace:boost
proto	/usr/include/boost/proto/expr.hpp	/^    namespace boost { namespace proto$/;"	n	namespace:boost
proto	/usr/include/boost/proto/extends.hpp	/^namespace boost { namespace proto$/;"	n	namespace:boost
proto	/usr/include/boost/proto/fusion.hpp	/^namespace boost { namespace proto$/;"	n	namespace:boost
proto	/usr/include/boost/proto/generate.hpp	/^    namespace boost { namespace proto$/;"	n	namespace:boost
proto	/usr/include/boost/proto/literal.hpp	/^namespace boost { namespace proto$/;"	n	namespace:boost
proto	/usr/include/boost/proto/make_expr.hpp	/^    namespace boost { namespace proto$/;"	n	namespace:boost
proto	/usr/include/boost/proto/matches.hpp	/^    namespace boost { namespace proto$/;"	n	namespace:boost
proto	/usr/include/boost/proto/operators.hpp	/^namespace boost { namespace proto$/;"	n	namespace:boost
proto	/usr/include/boost/proto/proto_fwd.hpp	/^namespace boost { namespace proto$/;"	n	namespace:boost
proto	/usr/include/boost/proto/tags.hpp	/^namespace boost { namespace proto { namespace tag$/;"	n	namespace:boost
proto	/usr/include/boost/proto/traits.hpp	/^    namespace boost { namespace proto$/;"	n	namespace:boost
proto	/usr/include/boost/proto/transform/arg.hpp	/^namespace boost { namespace proto$/;"	n	namespace:boost
proto	/usr/include/boost/proto/transform/call.hpp	/^    namespace boost { namespace proto$/;"	n	namespace:boost
proto	/usr/include/boost/proto/transform/default.hpp	/^    namespace boost { namespace proto$/;"	n	namespace:boost
proto	/usr/include/boost/proto/transform/fold.hpp	/^    namespace boost { namespace proto$/;"	n	namespace:boost
proto	/usr/include/boost/proto/transform/fold_tree.hpp	/^namespace boost { namespace proto$/;"	n	namespace:boost
proto	/usr/include/boost/proto/transform/impl.hpp	/^namespace boost { namespace proto$/;"	n	namespace:boost
proto	/usr/include/boost/proto/transform/lazy.hpp	/^    namespace boost { namespace proto$/;"	n	namespace:boost
proto	/usr/include/boost/proto/transform/make.hpp	/^    namespace boost { namespace proto$/;"	n	namespace:boost
proto	/usr/include/boost/proto/transform/pass_through.hpp	/^    namespace boost { namespace proto$/;"	n	namespace:boost
proto	/usr/include/boost/proto/transform/when.hpp	/^    namespace boost { namespace proto$/;"	n	namespace:boost
protoify_	/usr/include/boost/proto/make_expr.hpp	/^            struct protoify_$/;"	s	namespace:boost::proto::detail
protoify_	/usr/include/boost/proto/make_expr.hpp	/^            struct protoify_<T &, Domain>$/;"	s	namespace:boost::proto::detail
proto_address_of_hack_type_	/usr/include/boost/proto/extends.hpp	/^            typedef typename proto_base_expr::address_of_hack_type_ proto_address_of_hack_type_;$/;"	t	struct:boost::proto::exprns_::virtual_member	access:public
proto_args	/usr/include/boost/proto/extends.hpp	/^            typedef typename proto_base_expr::proto_args proto_args;$/;"	t	struct:boost::proto::exprns_::virtual_member	access:public
proto_arity	/usr/include/boost/proto/extends.hpp	/^            typedef typename proto_base_expr::proto_arity proto_arity;$/;"	t	struct:boost::proto::exprns_::virtual_member	access:public
proto_base	/usr/include/boost/proto/extends.hpp	/^            proto_base_expr const proto_base() const$/;"	f	struct:boost::proto::exprns_::virtual_member	access:public	signature:() const
proto_base_expr	/usr/include/boost/proto/extends.hpp	/^            proto_base_expr;$/;"	t	struct:boost::proto::exprns_::virtual_member	access:public
proto_base_expr	/usr/include/boost/proto/matches.hpp	/^                typedef and_ proto_base_expr;$/;"	t	struct:boost::proto::control::and_	access:public
proto_base_expr	/usr/include/boost/proto/matches.hpp	/^                typedef if_ proto_base_expr;$/;"	t	struct:boost::proto::control::if_	access:public
proto_base_expr	/usr/include/boost/proto/matches.hpp	/^                typedef not_ proto_base_expr;$/;"	t	struct:boost::proto::control::not_	access:public
proto_base_expr	/usr/include/boost/proto/matches.hpp	/^                typedef or_ proto_base_expr;$/;"	t	struct:boost::proto::control::or_	access:public
proto_base_expr	/usr/include/boost/proto/matches.hpp	/^                typedef switch_ proto_base_expr;$/;"	t	struct:boost::proto::control::switch_	access:public
proto_base_expr	/usr/include/boost/proto/matches.hpp	/^                typedef _ proto_base_expr;$/;"	t	struct:boost::proto::wildcardns_::_	access:public
proto_base_expr	/usr/include/boost/proto/traits.hpp	/^                typedef type proto_base_expr;$/;"	t	struct:boost::proto::op::binary_expr	access:public
proto_base_expr	/usr/include/boost/proto/traits.hpp	/^                typedef type proto_base_expr;$/;"	t	struct:boost::proto::op::if_else_	access:public
proto_base_expr	/usr/include/boost/proto/traits.hpp	/^                typedef type proto_base_expr;$/;"	t	struct:boost::proto::op::nullary_expr	access:public
proto_base_expr	/usr/include/boost/proto/traits.hpp	/^                typedef type proto_base_expr;$/;"	t	struct:boost::proto::op::terminal	access:public
proto_base_expr	/usr/include/boost/proto/traits.hpp	/^                typedef type proto_base_expr;$/;"	t	struct:boost::proto::op::unary_expr	access:public
proto_base_expr	/usr/include/boost/proto/transform/when.hpp	/^            typedef typename Grammar::proto_base_expr proto_base_expr;$/;"	t	struct:boost::proto::when	access:public
proto_child0	/usr/include/boost/proto/traits.hpp	/^                typedef T proto_child0;$/;"	t	struct:boost::proto::op::binary_expr	access:public
proto_child0	/usr/include/boost/proto/traits.hpp	/^                typedef T proto_child0;$/;"	t	struct:boost::proto::op::if_else_	access:public
proto_child0	/usr/include/boost/proto/traits.hpp	/^                typedef T proto_child0;$/;"	t	struct:boost::proto::op::nullary_expr	access:public
proto_child0	/usr/include/boost/proto/traits.hpp	/^                typedef T proto_child0;$/;"	t	struct:boost::proto::op::terminal	access:public
proto_child0	/usr/include/boost/proto/traits.hpp	/^                typedef T proto_child0;$/;"	t	struct:boost::proto::op::unary_expr	access:public
proto_child1	/usr/include/boost/proto/traits.hpp	/^                typedef U proto_child1;$/;"	t	struct:boost::proto::op::binary_expr	access:public
proto_child1	/usr/include/boost/proto/traits.hpp	/^                typedef U proto_child1;$/;"	t	struct:boost::proto::op::if_else_	access:public
proto_child2	/usr/include/boost/proto/traits.hpp	/^                typedef V proto_child2;$/;"	t	struct:boost::proto::op::if_else_	access:public
proto_derived_expr	/usr/include/boost/proto/extends.hpp	/^            typedef virtual_member<This, Fun, Domain> proto_derived_expr;$/;"	t	struct:boost::proto::exprns_::virtual_member	access:public
proto_domain	/usr/include/boost/proto/deep_copy.hpp	/^                typedef typename Expr::proto_domain proto_domain;$/;"	t	struct:boost::proto::detail::deep_copy_impl	access:public
proto_domain	/usr/include/boost/proto/extends.hpp	/^            typedef Domain proto_domain;$/;"	t	struct:boost::proto::exprns_::virtual_member	access:public
proto_domain	/usr/include/boost/proto/operators.hpp	/^            typedef typename choose_domain2<typename Left::proto_domain, typename Right::proto_domain>::type proto_domain;$/;"	t	struct:boost::proto::detail::as_expr_if	access:public
proto_domain	/usr/include/boost/proto/operators.hpp	/^            typedef typename Left::proto_domain proto_domain;$/;"	t	struct:boost::proto::detail::as_expr_if2	access:public
proto_domain	/usr/include/boost/proto/operators.hpp	/^            typedef typename Right::proto_domain proto_domain;$/;"	t	struct:boost::proto::detail::as_expr_if2	access:public
proto_get_pointer	/usr/include/boost/proto/detail/decltype.hpp	/^        U *proto_get_pointer(T &t, V *, U *)$/;"	f	namespace:boost::proto::detail	signature:(T &t, V *, U *)
proto_get_pointer	/usr/include/boost/proto/detail/decltype.hpp	/^        U const *proto_get_pointer(T &t, V *, U const *)$/;"	f	namespace:boost::proto::detail	signature:(T &t, V *, U const *)
proto_get_pointer	/usr/include/boost/proto/detail/decltype.hpp	/^        V *proto_get_pointer(T &t, V *, ...)$/;"	f	namespace:boost::proto::detail	signature:(T &t, V *, ...)
proto_grammar	/usr/include/boost/proto/domain.hpp	/^            typedef Grammar proto_grammar;$/;"	t	struct:boost::proto::domainns_::domain	access:public
proto_is_aggregate_	/usr/include/boost/proto/extends.hpp	/^            typedef void proto_is_aggregate_; \/**< INTERNAL ONLY *\/$/;"	t	struct:boost::proto::exprns_::virtual_member	access:public
proto_is_domain_	/usr/include/boost/proto/domain.hpp	/^            typedef void proto_is_domain_;$/;"	t	struct:boost::proto::domainns_::domain	access:public
proto_is_expr_	/usr/include/boost/proto/extends.hpp	/^            typedef void proto_is_expr_; \/**< INTERNAL ONLY *\/$/;"	t	struct:boost::proto::exprns_::virtual_member	access:public
proto_is_vararg_	/usr/include/boost/proto/matches.hpp	/^                typedef void proto_is_vararg_;$/;"	t	struct:boost::proto::control::vararg	access:public
proto_tag	/usr/include/boost/proto/extends.hpp	/^            typedef typename proto_base_expr::proto_tag proto_tag;$/;"	t	struct:boost::proto::exprns_::virtual_member	access:public
proto_tag	/usr/include/boost/proto/fusion.hpp	/^                typedef typename Sequence::proto_tag proto_tag;$/;"	t	struct:boost::fusion::extension::segments_impl::apply	access:public
proto_tag	/usr/include/boost/proto/fusion.hpp	/^            typedef typename Expr::proto_tag proto_tag;$/;"	t	struct:boost::proto::detail::expr_iterator	access:public
proto_tag	/usr/include/boost/proto/fusion.hpp	/^            typedef typename Expr::proto_tag proto_tag;$/;"	t	struct:boost::proto::detail::flat_view	access:public
proto_tag	/usr/include/boost/proto/traits.hpp	/^                typedef proto::tag::if_else_ proto_tag;$/;"	t	struct:boost::proto::op::if_else_	access:public
proto_tag	/usr/include/boost/proto/traits.hpp	/^                typedef proto::tag::terminal proto_tag;$/;"	t	struct:boost::proto::op::terminal	access:public
proto_tag	/usr/include/boost/proto/traits.hpp	/^                typedef Tag proto_tag;$/;"	t	struct:boost::proto::op::binary_expr	access:public
proto_tag	/usr/include/boost/proto/traits.hpp	/^                typedef Tag proto_tag;$/;"	t	struct:boost::proto::op::nullary_expr	access:public
proto_tag	/usr/include/boost/proto/traits.hpp	/^                typedef Tag proto_tag;$/;"	t	struct:boost::proto::op::unary_expr	access:public
r0	/usr/include/boost/proto/context/default.hpp	/^                typedef typename proto::result_of::eval<UNREF(e0), Context>::type r0;$/;"	t	struct:boost::proto::context::default_eval	access:private
r0	/usr/include/boost/proto/context/default.hpp	/^                typedef typename proto::result_of::eval<UNREF(e0), Context>::type r0;$/;"	t	struct:boost::proto::context::memfun_eval	access:private
r0	/usr/include/boost/proto/transform/default.hpp	/^                typedef typename Grammar::template impl<e0, State, Data>::result_type r0;$/;"	t	struct:boost::proto::_default::impl2	access:private
r0	/usr/include/boost/proto/transform/default.hpp	/^                typedef typename Grammar::template impl<e0, State, Data>::result_type r0;$/;"	t	struct:boost::proto::_default::memfun_impl	access:private
r1	/usr/include/boost/proto/context/default.hpp	/^                typedef typename proto::result_of::eval<UNREF(e1), Context>::type r1;$/;"	t	struct:boost::proto::context::default_eval	access:private
r1	/usr/include/boost/proto/context/default.hpp	/^                typedef typename proto::result_of::eval<UNREF(e1), Context>::type r1;$/;"	t	struct:boost::proto::context::memfun_eval	access:private
r1	/usr/include/boost/proto/transform/default.hpp	/^                typedef typename Grammar::template impl<e1, State, Data>::result_type r1;$/;"	t	struct:boost::proto::_default::impl2	access:private
r1	/usr/include/boost/proto/transform/default.hpp	/^                typedef typename Grammar::template impl<e1, State, Data>::result_type r1;$/;"	t	struct:boost::proto::_default::memfun_impl	access:private
r2	/usr/include/boost/proto/context/default.hpp	/^                typedef typename proto::result_of::eval<UNREF(e2), Context>::type r2;$/;"	t	struct:boost::proto::context::default_eval	access:private
r2	/usr/include/boost/proto/transform/default.hpp	/^                typedef typename Grammar::template impl<e2, State, Data>::result_type r2;$/;"	t	struct:boost::proto::_default::impl2	access:private
raw_terminal_type	/usr/include/boost/proto/deep_copy.hpp	/^                typedef BOOST_PROTO_UNCVREF(typename Expr::proto_child0) raw_terminal_type;$/;"	t	struct:boost::proto::detail::deep_copy_impl	access:public
reference	/usr/include/boost/proto/args.hpp	/^                typedef Expr &reference;$/;"	t	struct:boost::proto::detail::expr_traits	access:public
reference	/usr/include/boost/proto/args.hpp	/^                typedef Expr const &reference;$/;"	t	struct:boost::proto::detail::expr_traits	access:public
reference	/usr/include/boost/proto/args.hpp	/^                typedef T &reference;$/;"	t	struct:boost::proto::detail::term_traits	access:public
reference	/usr/include/boost/proto/args.hpp	/^                typedef T (&reference)[N];$/;"	t	struct:boost::proto::detail::term_traits	access:public
reference	/usr/include/boost/proto/args.hpp	/^                typedef T const &reference;$/;"	t	struct:boost::proto::detail::term_traits	access:public
reference	/usr/include/boost/proto/args.hpp	/^                typedef T const (&reference)[N];$/;"	t	struct:boost::proto::detail::term_traits	access:public
reference	/usr/include/boost/proto/detail/poly_function.hpp	/^            typedef T &reference;$/;"	t	struct:boost::proto::detail::normalize_arg	access:public
reference	/usr/include/boost/proto/detail/poly_function.hpp	/^            typedef T const &reference;$/;"	t	struct:boost::proto::detail::normalize_arg	access:public
reference	/usr/include/boost/proto/literal.hpp	/^            typedef typename detail::term_traits<T>::reference        reference;$/;"	t	struct:boost::proto::utility::literal	access:public
reference	/usr/include/boost/proto/traits.hpp	/^                typedef T &reference;$/;"	t	struct:boost::proto::result_of::as_expr	access:public
reference	/usr/include/boost/proto/traits.hpp	/^                typedef type const reference;$/;"	t	struct:boost::proto::result_of::as_expr	access:public
result	/usr/include/boost/proto/deep_copy.hpp	/^                struct result<This(Expr)>$/;"	s	struct:boost::proto::functional::deep_copy	access:public
result	/usr/include/boost/proto/detail/poly_function.hpp	/^            struct result<This()>$/;"	s	struct:boost::proto::detail::poly_function	inherits:Derived::,impl	access:public
result	/usr/include/boost/proto/eval.hpp	/^            struct result<This(Expr, Context)>$/;"	s	struct:boost::proto::functional::eval	access:public
result	/usr/include/boost/proto/fusion.hpp	/^            struct result<This(Expr &)>$/;"	s	struct:boost::proto::detail::as_element	inherits:mpl::if_c	access:public
result	/usr/include/boost/proto/fusion.hpp	/^            struct result<This(Expr &)>$/;"	s	struct:boost::proto::functional::flatten	access:public
result	/usr/include/boost/proto/fusion.hpp	/^            struct result<This(Expr &)>$/;"	s	struct:boost::proto::functional::pop_front	inherits:fusion::result_of::pop_front	access:public
result	/usr/include/boost/proto/fusion.hpp	/^            struct result<This(Expr &)>$/;"	s	struct:boost::proto::functional::reverse	inherits:fusion::result_of::reverse	access:public
result	/usr/include/boost/proto/fusion.hpp	/^            struct result<This(Expr)>$/;"	s	struct:boost::proto::detail::as_element	inherits:result	access:public
result	/usr/include/boost/proto/fusion.hpp	/^            struct result<This(Expr)>$/;"	s	struct:boost::proto::functional::flatten	inherits:result	access:public
result	/usr/include/boost/proto/fusion.hpp	/^            struct result<This(Expr)>$/;"	s	struct:boost::proto::functional::pop_front	inherits:result	access:public
result	/usr/include/boost/proto/fusion.hpp	/^            struct result<This(Expr)>$/;"	s	struct:boost::proto::functional::reverse	inherits:result	access:public
result	/usr/include/boost/proto/fusion.hpp	/^        struct result<This(Expr &)>$/;"	s	struct:boost::proto::eval_fun	inherits:proto::result_of::eval	access:public
result	/usr/include/boost/proto/fusion.hpp	/^        struct result<This(Expr)>$/;"	s	struct:boost::proto::eval_fun	inherits:result	access:public
result	/usr/include/boost/proto/generate.hpp	/^                struct result<This(Expr &)>$/;"	s	struct:boost::proto::generatorns_::by_value_generator	access:public
result	/usr/include/boost/proto/generate.hpp	/^                struct result<This(Expr &)>$/;"	s	struct:boost::proto::generatorns_::compose_generators	access:public
result	/usr/include/boost/proto/generate.hpp	/^                struct result<This(Expr &)>$/;"	s	struct:boost::proto::generatorns_::generator	access:public
result	/usr/include/boost/proto/generate.hpp	/^                struct result<This(Expr &)>$/;"	s	struct:boost::proto::generatorns_::pod_generator	access:public
result	/usr/include/boost/proto/generate.hpp	/^                struct result<This(Expr const &)>$/;"	s	struct:boost::proto::generatorns_::by_value_generator	access:public
result	/usr/include/boost/proto/generate.hpp	/^                struct result<This(Expr const &)>$/;"	s	struct:boost::proto::generatorns_::compose_generators	access:public
result	/usr/include/boost/proto/generate.hpp	/^                struct result<This(Expr const &)>$/;"	s	struct:boost::proto::generatorns_::generator	access:public
result	/usr/include/boost/proto/generate.hpp	/^                struct result<This(Expr const &)>$/;"	s	struct:boost::proto::generatorns_::pod_generator	access:public
result	/usr/include/boost/proto/generate.hpp	/^                struct result<This(Expr)>$/;"	s	struct:boost::proto::generatorns_::by_value_generator	access:public
result	/usr/include/boost/proto/generate.hpp	/^                struct result<This(Expr)>$/;"	s	struct:boost::proto::generatorns_::compose_generators	access:public
result	/usr/include/boost/proto/generate.hpp	/^                struct result<This(Expr)>$/;"	s	struct:boost::proto::generatorns_::default_generator	access:public
result	/usr/include/boost/proto/generate.hpp	/^                struct result<This(Expr)>$/;"	s	struct:boost::proto::generatorns_::generator	access:public
result	/usr/include/boost/proto/generate.hpp	/^                struct result<This(Expr)>$/;"	s	struct:boost::proto::generatorns_::pod_generator	access:public
result	/usr/include/boost/proto/make_expr.hpp	/^                struct result$/;"	s	struct:boost::proto::functional::unpack_expr	access:public
result	/usr/include/boost/proto/make_expr.hpp	/^                struct result<This(A0)>$/;"	s	struct:boost::proto::functional::make_expr	access:public
result	/usr/include/boost/proto/make_expr.hpp	/^                struct result<This(Sequence)>$/;"	s	struct:boost::proto::functional::unfused_expr_fun	access:public
result	/usr/include/boost/proto/make_expr.hpp	/^                struct result<This(Sequence)>$/;"	s	struct:boost::proto::functional::unpack_expr	access:public
result	/usr/include/boost/proto/traits.hpp	/^                struct result<This(Expr)>$/;"	s	struct:boost::proto::functional::child	access:public
result	/usr/include/boost/proto/traits.hpp	/^                struct result<This(Expr)>$/;"	s	struct:boost::proto::functional::child_c	access:public
result	/usr/include/boost/proto/traits.hpp	/^                struct result<This(Expr)>$/;"	s	struct:boost::proto::functional::left	access:public
result	/usr/include/boost/proto/traits.hpp	/^                struct result<This(Expr)>$/;"	s	struct:boost::proto::functional::right	access:public
result	/usr/include/boost/proto/traits.hpp	/^                struct result<This(Expr)>$/;"	s	struct:boost::proto::functional::value	access:public
result	/usr/include/boost/proto/traits.hpp	/^                struct result<This(T)>$/;"	s	struct:boost::proto::functional::as_child	access:public
result	/usr/include/boost/proto/traits.hpp	/^                struct result<This(T)>$/;"	s	struct:boost::proto::functional::as_expr	access:public
result	/usr/include/boost/proto/transform/arg.hpp	/^        struct result<This(boost::reference_wrapper<T>)>$/;"	s	struct:boost::proto::_byval	inherits:result	access:public
result	/usr/include/boost/proto/transform/arg.hpp	/^        struct result<This(T &)>$/;"	s	struct:boost::proto::_byref	access:public
result	/usr/include/boost/proto/transform/arg.hpp	/^        struct result<This(T &)>$/;"	s	struct:boost::proto::_byval	inherits:result	access:public
result	/usr/include/boost/proto/transform/arg.hpp	/^        struct result<This(T)>$/;"	s	struct:boost::proto::_byref	access:public
result	/usr/include/boost/proto/transform/arg.hpp	/^        struct result<This(T)>$/;"	s	struct:boost::proto::_byval	access:public
result	/usr/include/boost/proto/transform/fold.hpp	/^                struct result<This(Expr, State)>$/;"	s	struct:boost::proto::detail::as_callable	access:public
result	/usr/include/boost/proto/transform/fold.hpp	/^                struct result<This(State, Expr)>$/;"	s	struct:boost::proto::detail::as_callable	access:public
result_of	/usr/include/boost/proto/deep_copy.hpp	/^        namespace result_of$/;"	n	namespace:boost::proto
result_of	/usr/include/boost/proto/domain.hpp	/^    namespace result_of$/;"	n	namespace:boost::proto
result_of	/usr/include/boost/proto/eval.hpp	/^    namespace result_of$/;"	n	namespace:boost::proto
result_of	/usr/include/boost/proto/expr.hpp	/^        namespace result_of$/;"	n	namespace:boost::proto
result_of	/usr/include/boost/proto/fusion.hpp	/^    namespace result_of$/;"	n	namespace:boost::proto
result_of	/usr/include/boost/proto/generate.hpp	/^        struct result_of<proto::default_domain(Expr)>$/;"	s	namespace:boost
result_of	/usr/include/boost/proto/make_expr.hpp	/^        namespace result_of$/;"	n	namespace:boost::proto
result_of	/usr/include/boost/proto/matches.hpp	/^        namespace result_of$/;"	n	namespace:boost::proto
result_of	/usr/include/boost/proto/proto_fwd.hpp	/^    namespace result_of$/;"	n	namespace:boost::proto
result_of	/usr/include/boost/proto/traits.hpp	/^        namespace result_of$/;"	n	namespace:boost::proto
result_of_	/usr/include/boost/proto/detail/decltype.hpp	/^            struct result_of_$/;"	s	namespace:boost::proto::detail::get_pointerns	inherits:boost::result_of
result_of_	/usr/include/boost/proto/detail/decltype.hpp	/^            struct result_of_<T U::*(V), typename enable_if_c<is_member_object_pointer<T U::*>::value>::type>$/;"	s	namespace:boost::proto::detail::get_pointerns
result_of_fixup	/usr/include/boost/proto/detail/decltype.hpp	/^        struct result_of_fixup$/;"	s	namespace:boost::proto::detail	inherits:mpl::if_c
result_of_fixup	/usr/include/boost/proto/detail/decltype.hpp	/^        struct result_of_fixup<R T::*, U>$/;"	s	namespace:boost::proto::detail
result_of_fixup	/usr/include/boost/proto/detail/decltype.hpp	/^        struct result_of_fixup<T &, U>$/;"	s	namespace:boost::proto::detail	inherits:result_of_fixup
result_of_fixup	/usr/include/boost/proto/detail/decltype.hpp	/^        struct result_of_fixup<T *, U>$/;"	s	namespace:boost::proto::detail	inherits:result_of_fixup
result_of_fixup	/usr/include/boost/proto/detail/decltype.hpp	/^        struct result_of_fixup<T const &, U>$/;"	s	namespace:boost::proto::detail	inherits:result_of_fixup
result_of_fixup	/usr/include/boost/proto/detail/decltype.hpp	/^        struct result_of_fixup<T const, U>$/;"	s	namespace:boost::proto::detail	inherits:result_of_fixup
result_type	/usr/include/boost/proto/context/callable.hpp	/^                result_type;$/;"	t	struct:boost::proto::context::callable_eval	access:public
result_type	/usr/include/boost/proto/context/default.hpp	/^                result_type;$/;"	t	struct:boost::proto::context::default_eval	access:public
result_type	/usr/include/boost/proto/context/default.hpp	/^                typedef detail::memfun<r0, r1> result_type;$/;"	t	struct:boost::proto::context::memfun_eval	access:public
result_type	/usr/include/boost/proto/context/default.hpp	/^                typedef typename detail::mem_ptr_fun<r0, r1>::result_type result_type;$/;"	t	struct:boost::proto::context::memfun_eval	access:public
result_type	/usr/include/boost/proto/context/default.hpp	/^                typedef typename proto::detail::comma_result<r0, r1>::type result_type;$/;"	t	struct:boost::proto::context::default_eval	access:public
result_type	/usr/include/boost/proto/context/null.hpp	/^            typedef void result_type;$/;"	t	struct:boost::proto::context::null_eval	access:public
result_type	/usr/include/boost/proto/deep_copy.hpp	/^                typedef typename proto_domain::template result<proto_domain(expr_type)>::type result_type;$/;"	t	struct:boost::proto::detail::deep_copy_impl	access:public
result_type	/usr/include/boost/proto/detail/decltype.hpp	/^            typedef typename boost::result_of<pmf_type(T)>::type result_type;$/;"	t	struct:boost::proto::detail::memfun	access:public
result_type	/usr/include/boost/proto/detail/poly_function.hpp	/^            typedef typename Fun::result_type result_type;$/;"	t	struct:boost::proto::detail::poly_function_traits	access:public
result_type	/usr/include/boost/proto/detail/poly_function.hpp	/^            typedef typename Fun::template result<Sig>::type result_type;$/;"	t	struct:boost::proto::detail::poly_function_traits	access:public
result_type	/usr/include/boost/proto/make_expr.hpp	/^                typedef typename proto::detail::protoify_<A, Domain>::type result_type;$/;"	t	struct:boost::proto::detail::make_expr_	access:public
result_type	/usr/include/boost/proto/matches.hpp	/^                    typedef Expr result_type;$/;"	t	struct:boost::proto::control::not_::impl	access:public
result_type	/usr/include/boost/proto/matches.hpp	/^                    typedef Expr result_type;$/;"	t	struct:boost::proto::wildcardns_::_::impl	access:public
result_type	/usr/include/boost/proto/matches.hpp	/^                    typedef typename which::template impl<Expr, State, Data>::result_type result_type;$/;"	t	struct:boost::proto::control::if_::impl	access:public
result_type	/usr/include/boost/proto/traits.hpp	/^                    typedef Expr result_type;$/;"	t	struct:boost::proto::op::nullary_expr::impl	access:public
result_type	/usr/include/boost/proto/traits.hpp	/^                    typedef Expr result_type;$/;"	t	struct:boost::proto::op::terminal::impl	access:public
result_type	/usr/include/boost/proto/transform/arg.hpp	/^            result_type;$/;"	t	struct:boost::proto::_child_c::impl	access:public
result_type	/usr/include/boost/proto/transform/arg.hpp	/^            result_type;$/;"	t	struct:boost::proto::_value::impl	access:public
result_type	/usr/include/boost/proto/transform/arg.hpp	/^            typedef Data result_type;$/;"	t	struct:boost::proto::_data::impl	access:public
result_type	/usr/include/boost/proto/transform/arg.hpp	/^            typedef Expr result_type;$/;"	t	struct:boost::proto::_expr::impl	access:public
result_type	/usr/include/boost/proto/transform/arg.hpp	/^            typedef State result_type;$/;"	t	struct:boost::proto::_state::impl	access:public
result_type	/usr/include/boost/proto/transform/call.hpp	/^                typedef typename boost::result_of<Fun()>::type result_type;$/;"	t	struct:boost::proto::call::impl2	access:public
result_type	/usr/include/boost/proto/transform/call.hpp	/^                typedef typename detail::poly_function_traits<Fun, Fun(a0)>::result_type result_type;$/;"	t	struct:boost::proto::call::impl2	access:public
result_type	/usr/include/boost/proto/transform/call.hpp	/^                typedef typename detail::poly_function_traits<Fun, Fun(a0, a1)>::result_type result_type;$/;"	t	struct:boost::proto::call::impl2	access:public
result_type	/usr/include/boost/proto/transform/call.hpp	/^                typedef typename detail::poly_function_traits<Fun, Fun(a0, a1, a2)>::result_type result_type;$/;"	t	struct:boost::proto::call::impl2	access:public
result_type	/usr/include/boost/proto/transform/call.hpp	/^                typedef typename Fun::template impl<a0, a1, a2>::result_type result_type;$/;"	t	struct:boost::proto::call::impl2	access:public
result_type	/usr/include/boost/proto/transform/call.hpp	/^                typedef typename Fun::template impl<a0, a1, Data>::result_type result_type;$/;"	t	struct:boost::proto::call::impl2	access:public
result_type	/usr/include/boost/proto/transform/call.hpp	/^                typedef typename Fun::template impl<a0, State, Data>::result_type result_type;$/;"	t	struct:boost::proto::call::impl2	access:public
result_type	/usr/include/boost/proto/transform/default.hpp	/^                result_type;$/;"	t	struct:boost::proto::_default::impl2	access:public
result_type	/usr/include/boost/proto/transform/default.hpp	/^                typedef detail::memfun<r0, r1> result_type;$/;"	t	struct:boost::proto::_default::memfun_impl	access:public
result_type	/usr/include/boost/proto/transform/default.hpp	/^                typedef typename detail::mem_ptr_fun<r0, r1>::result_type result_type;$/;"	t	struct:boost::proto::_default::memfun_impl	access:public
result_type	/usr/include/boost/proto/transform/default.hpp	/^                typedef typename proto::detail::comma_result<r0, r1>::type result_type;$/;"	t	struct:boost::proto::_default::impl2	access:public
result_type	/usr/include/boost/proto/transform/fold.hpp	/^                result_type;$/;"	t	struct:boost::proto::fold::impl	access:public
result_type	/usr/include/boost/proto/transform/fold_tree.hpp	/^                typedef mpl::false_ result_type;$/;"	t	struct:boost::proto::detail::has_tag::impl	access:public
result_type	/usr/include/boost/proto/transform/fold_tree.hpp	/^                typedef mpl::true_ result_type;$/;"	t	struct:boost::proto::detail::has_tag::impl	access:public
result_type	/usr/include/boost/proto/transform/make.hpp	/^                typedef PrimitiveTransform result_type;$/;"	t	struct:boost::proto::protect::impl	access:public
result_type	/usr/include/boost/proto/transform/make.hpp	/^                typedef Type result_type;$/;"	t	struct:boost::proto::detail::construct_	access:public
result_type	/usr/include/boost/proto/transform/make.hpp	/^                typedef typename detail::make_if_<Object, Expr, State, Data>::type result_type;$/;"	t	struct:boost::proto::make::impl	access:public
result_type	/usr/include/boost/proto/transform/pass_through.hpp	/^                typedef Expr result_type;$/;"	t	struct:boost::proto::detail::pass_through_impl	access:public
reverse	/usr/include/boost/proto/detail/reverse.hpp	/^        struct reverse$/;"	s	namespace:boost::fusion::meta
reverse	/usr/include/boost/proto/detail/reverse.hpp	/^    reverse(Sequence const& view)$/;"	f	namespace:boost::fusion	signature:(Sequence const& view)
reverse	/usr/include/boost/proto/fusion.hpp	/^        struct reverse$/;"	s	namespace:boost::proto::functional
reverse_fold	/usr/include/boost/proto/transform/fold.hpp	/^        struct reverse_fold$/;"	s	namespace:boost::proto	inherits:fold
reverse_fold	/usr/include/boost/proto/transform/fold.hpp	/^        struct reverse_fold<_, State0, Fun> : transform<reverse_fold<_, State0, Fun> >$/;"	s	namespace:boost::proto	inherits:transform
reverse_fold_impl	/usr/include/boost/proto/transform/fold.hpp	/^            struct reverse_fold_impl$/;"	s	namespace:boost::proto::detail
reverse_fold_tree	/usr/include/boost/proto/transform/fold_tree.hpp	/^    struct reverse_fold_tree$/;"	s	namespace:boost::proto	inherits:transform
reverse_fold_tree_	/usr/include/boost/proto/transform/fold_tree.hpp	/^        struct reverse_fold_tree_$/;"	s	namespace:boost::proto::detail	inherits:if_
reverse_view	/usr/include/boost/proto/detail/reverse.hpp	/^        reverse_view(Sequence& seq)$/;"	f	struct:boost::fusion::reverse_view	access:public	signature:(Sequence& seq)
reverse_view	/usr/include/boost/proto/detail/reverse.hpp	/^    struct reverse_view : sequence_base<reverse_view<Sequence> >$/;"	s	namespace:boost::fusion	inherits:sequence_base
reverse_view_iterator	/usr/include/boost/proto/detail/reverse.hpp	/^        reverse_view_iterator(First const& first)$/;"	f	struct:boost::fusion::reverse_view_iterator	access:public	signature:(First const& first)
reverse_view_iterator	/usr/include/boost/proto/detail/reverse.hpp	/^    struct reverse_view_iterator$/;"	s	namespace:boost::fusion	inherits:iterator_base
right	/usr/include/boost/proto/traits.hpp	/^            struct right$/;"	s	namespace:boost::proto::functional
right	/usr/include/boost/proto/traits.hpp	/^            struct right$/;"	s	namespace:boost::proto::result_of	inherits:child_c
right	/usr/include/boost/proto/traits.hpp	/^        right(Expr const &e)$/;"	f	namespace:boost::proto	signature:(Expr const &e)
same_cv	/usr/include/boost/proto/expr.hpp	/^            struct same_cv$/;"	s	namespace:boost::proto::detail
same_cv	/usr/include/boost/proto/expr.hpp	/^            struct same_cv<T const, U>$/;"	s	namespace:boost::proto::detail
sctx_	/usr/include/boost/proto/context/callable.hpp	/^                static callable_context_wrapper<Context> &sctx_;$/;"	m	struct:boost::proto::detail::is_expr_handled	access:public
segments_impl	/usr/include/boost/proto/fusion.hpp	/^        struct segments_impl<proto::tag::proto_flat_view>$/;"	s	namespace:boost::fusion::extension
select_nth	/usr/include/boost/proto/make_expr.hpp	/^            struct select_nth$/;"	s	namespace:boost::proto::detail
seq	/usr/include/boost/proto/detail/reverse.hpp	/^        typedef typename seq_converter::type seq;$/;"	t	struct:boost::fusion::reverse_view	access:public
sequence	/usr/include/boost/proto/transform/fold.hpp	/^                sequence;$/;"	t	struct:boost::proto::fold::impl	access:public
sequence_tag	/usr/include/boost/proto/fusion.hpp	/^    struct sequence_tag< proto::expr<Tag, Args, Arity> >$/;"	s	namespace:boost::mpl
seq_converter	/usr/include/boost/proto/detail/reverse.hpp	/^        typedef as_fusion_sequence<Sequence> seq_converter;$/;"	t	struct:boost::fusion::reverse_view	access:public
sexpr_	/usr/include/boost/proto/context/callable.hpp	/^                static Expr &sexpr_;$/;"	m	struct:boost::proto::detail::is_expr_handled	access:public
shift_left	/usr/include/boost/proto/tags.hpp	/^    struct shift_left {};$/;"	s	namespace:boost::proto::tag
shift_left_assign	/usr/include/boost/proto/tags.hpp	/^    struct shift_left_assign {};$/;"	s	namespace:boost::proto::tag
shift_right	/usr/include/boost/proto/tags.hpp	/^    struct shift_right {};$/;"	s	namespace:boost::proto::tag
shift_right_assign	/usr/include/boost/proto/tags.hpp	/^    struct shift_right_assign {};$/;"	s	namespace:boost::proto::tag
sized	/usr/include/boost/proto/make_expr.hpp	/^            struct sized$/;"	s	namespace:boost::proto::detail
size_impl	/usr/include/boost/proto/fusion.hpp	/^        struct size_impl<proto::tag::proto_expr>$/;"	s	namespace:boost::fusion::extension
size_impl	/usr/include/boost/proto/fusion.hpp	/^        struct size_impl<proto::tag::proto_flat_view>$/;"	s	namespace:boost::fusion::extension
stag_	/usr/include/boost/proto/context/callable.hpp	/^                static typename Expr::proto_tag &stag_;$/;"	m	struct:boost::proto::detail::is_expr_handled	access:public
state	/usr/include/boost/proto/transform/impl.hpp	/^        typedef State const state;$/;"	t	struct:boost::proto::transform_impl	access:public
state	/usr/include/boost/proto/transform/impl.hpp	/^        typedef State state;$/;"	t	struct:boost::proto::transform_impl	access:public
state0	/usr/include/boost/proto/transform/fold.hpp	/^                state0;$/;"	t	struct:boost::proto::fold::impl	access:public
state_param	/usr/include/boost/proto/transform/impl.hpp	/^        typedef State &state_param;$/;"	t	struct:boost::proto::transform_impl	access:public
state_param	/usr/include/boost/proto/transform/impl.hpp	/^        typedef State const &state_param;$/;"	t	struct:boost::proto::transform_impl	access:public
subscript	/usr/include/boost/proto/tags.hpp	/^    struct subscript {};$/;"	s	namespace:boost::proto::tag
subscript_wrapper	/usr/include/boost/proto/detail/decltype.hpp	/^        struct subscript_wrapper$/;"	s	namespace:boost::proto::detail	inherits:T
switch_	/usr/include/boost/proto/matches.hpp	/^            struct switch_ : transform<switch_<Cases> >$/;"	s	namespace:boost::proto::control	inherits:transform
T	/usr/include/boost/proto/expr.hpp	/^            proto::expr<Tag, proto::term<Arg0[N]>, 0> make_terminal(T (&t)[N], proto::expr<Tag, proto::term<Arg0[N]>, 0> *)$/;"	m	namespace:boost::proto::detail
tag	/usr/include/boost/proto/debug.hpp	/^    namespace tag$/;"	n	namespace:boost::proto
tag	/usr/include/boost/proto/detail/reverse.hpp	/^        typedef reverse_view_iterator_tag tag;$/;"	t	struct:boost::fusion::reverse_view_iterator	access:public
tag	/usr/include/boost/proto/detail/reverse.hpp	/^        typedef reverse_view_tag tag;$/;"	t	struct:boost::fusion::reverse_view	access:public
tag	/usr/include/boost/proto/generate.hpp	/^                typedef Tag tag;$/;"	t	struct:boost::proto::detail::expr_params	access:public
tag	/usr/include/boost/proto/proto_fwd.hpp	/^    namespace tag$/;"	n	namespace:boost::proto
tag	/usr/include/boost/proto/tags.hpp	/^namespace boost { namespace proto { namespace tag$/;"	n	namespace:boost::proto
tag_of	/usr/include/boost/proto/traits.hpp	/^            struct tag_of$/;"	s	namespace:boost::proto::result_of
tag_of	/usr/include/boost/proto/traits.hpp	/^            struct tag_of<Expr &>$/;"	s	namespace:boost::proto::result_of
term	/usr/include/boost/proto/args.hpp	/^            struct term$/;"	s	namespace:boost::proto::argsns_
terminal	/usr/include/boost/proto/tags.hpp	/^    struct terminal {};$/;"	s	namespace:boost::proto::tag
terminal	/usr/include/boost/proto/traits.hpp	/^            struct terminal$/;"	s	namespace:boost::proto::op	inherits:proto::transform
terminal_array_matches	/usr/include/boost/proto/matches.hpp	/^            struct terminal_array_matches$/;"	s	namespace:boost::proto::detail	inherits:mpl::false_
terminal_array_matches	/usr/include/boost/proto/matches.hpp	/^            struct terminal_array_matches<T, U *, true>$/;"	s	namespace:boost::proto::detail	inherits:is_convertible
terminal_array_matches	/usr/include/boost/proto/matches.hpp	/^            struct terminal_array_matches<T, U(&)[M], true>$/;"	s	namespace:boost::proto::detail	inherits:is_convertible
terminal_array_matches	/usr/include/boost/proto/matches.hpp	/^            struct terminal_array_matches<T, U(&)[proto::N], true>$/;"	s	namespace:boost::proto::detail	inherits:is_convertible
terminal_matches	/usr/include/boost/proto/matches.hpp	/^            struct terminal_matches$/;"	s	namespace:boost::proto::detail	inherits:mpl::and_
terminal_matches	/usr/include/boost/proto/matches.hpp	/^            struct terminal_matches$/;"	s	namespace:boost::proto::detail	inherits:mpl::or_
terminal_matches	/usr/include/boost/proto/matches.hpp	/^            struct terminal_matches<T &, T>$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
terminal_matches	/usr/include/boost/proto/matches.hpp	/^            struct terminal_matches<T const &, T>$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
terminal_matches	/usr/include/boost/proto/matches.hpp	/^            struct terminal_matches<T const (&)[M], T const[M]>$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
terminal_matches	/usr/include/boost/proto/matches.hpp	/^            struct terminal_matches<T(&)[M], T *>$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
terminal_matches	/usr/include/boost/proto/matches.hpp	/^            struct terminal_matches<T(&)[M], T(&)[proto::N]>$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
terminal_matches	/usr/include/boost/proto/matches.hpp	/^            struct terminal_matches<T, exact<T> >$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
terminal_matches	/usr/include/boost/proto/matches.hpp	/^            struct terminal_matches<T, proto::convertible_to<U> >$/;"	s	namespace:boost::proto::detail	inherits:is_convertible
terminal_matches	/usr/include/boost/proto/matches.hpp	/^            struct terminal_matches<T, proto::_>$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
terminal_matches	/usr/include/boost/proto/matches.hpp	/^            struct terminal_matches<T, T>$/;"	s	namespace:boost::proto::detail	inherits:mpl::true_
terminal_type	/usr/include/boost/proto/literal.hpp	/^            typedef expr<tag::terminal, term<T>, 0> terminal_type;$/;"	t	struct:boost::proto::utility::literal	access:private
terminal_type	/usr/include/boost/proto/make_expr.hpp	/^                terminal_type;$/;"	t	struct:boost::proto::detail::unpack_expr_	access:public
term_traits	/usr/include/boost/proto/args.hpp	/^            struct term_traits$/;"	s	namespace:boost::proto::detail
term_traits	/usr/include/boost/proto/args.hpp	/^            struct term_traits<T &>$/;"	s	namespace:boost::proto::detail
term_traits	/usr/include/boost/proto/args.hpp	/^            struct term_traits<T (&)[N]>$/;"	s	namespace:boost::proto::detail
term_traits	/usr/include/boost/proto/args.hpp	/^            struct term_traits<T const &>$/;"	s	namespace:boost::proto::detail
term_traits	/usr/include/boost/proto/args.hpp	/^            struct term_traits<T const (&)[N]>$/;"	s	namespace:boost::proto::detail
term_traits	/usr/include/boost/proto/args.hpp	/^            struct term_traits<T const[N]>$/;"	s	namespace:boost::proto::detail
term_traits	/usr/include/boost/proto/args.hpp	/^            struct term_traits<T[N]>$/;"	s	namespace:boost::proto::detail
term_type	/usr/include/boost/proto/operators.hpp	/^            typedef proto::expr<tag::terminal, term<Left &>, 0> term_type;$/;"	t	struct:boost::proto::detail::as_expr_if2	access:public
term_type	/usr/include/boost/proto/operators.hpp	/^            typedef proto::expr<tag::terminal, term<Right &>, 0> term_type;$/;"	t	struct:boost::proto::detail::as_expr_if2	access:public
test_poly_function	/usr/include/boost/proto/detail/poly_function.hpp	/^        template<typename T> mono_function_t test_poly_function(T *, typename T::result_type * = 0);$/;"	p	namespace:boost::proto::detail	signature:(T *, typename T::result_type * = 0)
test_poly_function	/usr/include/boost/proto/detail/poly_function.hpp	/^        template<typename T> poly_function_t test_poly_function(T *, typename T::is_poly_function_base_ * = 0);$/;"	p	namespace:boost::proto::detail	signature:(T *, typename T::is_poly_function_base_ * = 0)
test_poly_function	/usr/include/boost/proto/detail/poly_function.hpp	/^        template<typename T> unknown_function_t test_poly_function(T *, ...);$/;"	p	namespace:boost::proto::detail	signature:(T *, ...)
test_ptr_to_const	/usr/include/boost/proto/detail/decltype.hpp	/^            char (&test_ptr_to_const(void const *))[2];$/;"	p	namespace:boost::proto::detail::get_pointerns	signature:(void const *)
test_ptr_to_const	/usr/include/boost/proto/detail/decltype.hpp	/^            char test_ptr_to_const(void *);$/;"	p	namespace:boost::proto::detail::get_pointerns	signature:(void *)
test_V_is_a_U	/usr/include/boost/proto/detail/decltype.hpp	/^            template<typename U> char (&test_V_is_a_U(...))[2];$/;"	p	namespace:boost::proto::detail::get_pointerns	signature:(....)
test_V_is_a_U	/usr/include/boost/proto/detail/decltype.hpp	/^            template<typename U> char test_V_is_a_U(U *);$/;"	p	namespace:boost::proto::detail::get_pointerns	signature:(U *)
test_V_is_a_U	/usr/include/boost/proto/detail/decltype.hpp	/^            template<typename U> char test_V_is_a_U(U const *);$/;"	p	namespace:boost::proto::detail::get_pointerns	signature:(U const *)
TMP	/usr/include/boost/proto/transform/make.hpp	116;"	d
TMP	/usr/include/boost/proto/transform/make.hpp	123;"	d
TMP	/usr/include/boost/proto/transform/make.hpp	136;"	d
TMP	/usr/include/boost/proto/transform/make.hpp	144;"	d
TMP	/usr/include/boost/proto/transform/make.hpp	147;"	d
TMP	/usr/include/boost/proto/transform/make.hpp	154;"	d
transform	/usr/include/boost/proto/transform/impl.hpp	/^    struct transform$/;"	s	namespace:boost::proto
transform_impl	/usr/include/boost/proto/transform/impl.hpp	/^    struct transform_impl$/;"	s	namespace:boost::proto
transform_impl	/usr/include/boost/proto/transform/impl.hpp	/^    struct transform_impl<Expr &, State &, Data &>$/;"	s	namespace:boost::proto
transform_impl	/usr/include/boost/proto/transform/impl.hpp	/^    struct transform_impl<Expr &, State &, Data>$/;"	s	namespace:boost::proto
transform_impl	/usr/include/boost/proto/transform/impl.hpp	/^    struct transform_impl<Expr &, State, Data &>$/;"	s	namespace:boost::proto
transform_impl	/usr/include/boost/proto/transform/impl.hpp	/^    struct transform_impl<Expr &, State, Data>$/;"	s	namespace:boost::proto
transform_impl	/usr/include/boost/proto/transform/impl.hpp	/^    struct transform_impl<Expr, State &, Data &>$/;"	s	namespace:boost::proto
transform_impl	/usr/include/boost/proto/transform/impl.hpp	/^    struct transform_impl<Expr, State &, Data>$/;"	s	namespace:boost::proto
transform_impl	/usr/include/boost/proto/transform/impl.hpp	/^    struct transform_impl<Expr, State, Data &>$/;"	s	namespace:boost::proto
type	/usr/include/boost/proto/context/callable.hpp	/^                typedef mpl::bool_<value> type;$/;"	t	struct:boost::proto::detail::is_expr_handled	access:public
type	/usr/include/boost/proto/debug.hpp	/^                typedef char const *type;$/;"	t	struct:boost::proto::tag::hidden_detail_::printable_tag_	access:public
type	/usr/include/boost/proto/debug.hpp	/^                typedef Tag type;$/;"	t	struct:boost::proto::tag::hidden_detail_::printable_tag_	access:public
type	/usr/include/boost/proto/deep_copy.hpp	/^                    type;$/;"	t	struct:boost::proto::functional::deep_copy::result	access:public
type	/usr/include/boost/proto/deep_copy.hpp	/^                type;$/;"	t	struct:boost::proto::result_of::deep_copy	access:public
type	/usr/include/boost/proto/detail/decltype.hpp	/^                type;$/;"	t	struct:boost::proto::detail::get_pointerns::result_of_	access:public
type	/usr/include/boost/proto/detail/decltype.hpp	/^                typedef mpl::bool_<value> type;$/;"	t	struct:boost::proto::detail::has_get_pointerns::has_get_pointer	access:public
type	/usr/include/boost/proto/detail/decltype.hpp	/^            type;$/;"	t	struct:boost::proto::detail::as_subscriptable	access:public
type	/usr/include/boost/proto/detail/decltype.hpp	/^            typedef A1 type;$/;"	t	struct:boost::proto::detail::comma_result	access:public
type	/usr/include/boost/proto/detail/decltype.hpp	/^            typedef R T::*type;$/;"	t	class:boost::proto::detail::result_of_fixup::T	access:public
type	/usr/include/boost/proto/detail/decltype.hpp	/^            typedef T &type;$/;"	t	struct:boost::proto::detail::as_mutable	access:public
type	/usr/include/boost/proto/detail/decltype.hpp	/^            typedef U type;$/;"	t	struct:boost::proto::detail::classtypeof	access:public
type	/usr/include/boost/proto/detail/decltype.hpp	/^            typedef void type;$/;"	t	struct:boost::proto::detail::comma_result	access:public
type	/usr/include/boost/proto/detail/poly_function.hpp	/^                typedef typename result::result_type type;$/;"	t	struct:boost::proto::detail::poly_function::result	access:public
type	/usr/include/boost/proto/detail/poly_function.hpp	/^            typedef T &type;$/;"	t	struct:boost::proto::detail::arg	access:public
type	/usr/include/boost/proto/detail/poly_function.hpp	/^            typedef T &type;$/;"	t	struct:boost::proto::detail::normalize_arg	access:public
type	/usr/include/boost/proto/detail/poly_function.hpp	/^            typedef T const &type;$/;"	t	struct:boost::proto::detail::arg	access:public
type	/usr/include/boost/proto/detail/poly_function.hpp	/^            typedef T type;$/;"	t	struct:boost::proto::detail::normalize_arg	access:public
type	/usr/include/boost/proto/detail/pop_front.hpp	/^            type;$/;"	t	struct:boost::fusion::meta::pop_front	access:public
type	/usr/include/boost/proto/detail/reverse.hpp	/^                type;$/;"	t	struct:boost::fusion::meta::deref_impl::apply	access:public
type	/usr/include/boost/proto/detail/reverse.hpp	/^                type;$/;"	t	struct:boost::fusion::meta::value_impl::apply	access:public
type	/usr/include/boost/proto/detail/reverse.hpp	/^                typedef reverse_view_iterator<typename Sequence::first_type> type;$/;"	t	struct:boost::fusion::meta::end_impl::apply	access:public
type	/usr/include/boost/proto/detail/reverse.hpp	/^                typedef reverse_view_iterator<typename Sequence::last_type> type;$/;"	t	struct:boost::fusion::meta::begin_impl::apply	access:public
type	/usr/include/boost/proto/detail/reverse.hpp	/^                typedef reverse_view_iterator<typename wrapped::type> type;$/;"	t	struct:boost::fusion::meta::next_impl::apply	access:public
type	/usr/include/boost/proto/detail/reverse.hpp	/^                typedef reverse_view_iterator<typename wrapped::type> type;$/;"	t	struct:boost::fusion::meta::prior_impl::apply	access:public
type	/usr/include/boost/proto/detail/reverse.hpp	/^            typedef reverse_view<Sequence> type;$/;"	t	struct:boost::fusion::meta::reverse	access:public
type	/usr/include/boost/proto/domain.hpp	/^            typedef default_domain type;$/;"	t	struct:boost::proto::result_of::domain_of	access:public
type	/usr/include/boost/proto/domain.hpp	/^            typedef typename domain_of<T>::type type;$/;"	t	struct:boost::proto::result_of::domain_of	access:public
type	/usr/include/boost/proto/domain.hpp	/^            typedef typename T::proto_domain type;$/;"	t	struct:boost::proto::result_of::domain_of	access:public
type	/usr/include/boost/proto/eval.hpp	/^                type;$/;"	t	struct:boost::proto::functional::eval::result	access:public
type	/usr/include/boost/proto/eval.hpp	/^            typedef typename Context::template eval<Expr>::result_type type;$/;"	t	struct:boost::proto::result_of::eval	access:public
type	/usr/include/boost/proto/expr.hpp	/^                typedef Expr *type;$/;"	t	struct:boost::proto::detail::address_of_hack	access:public
type	/usr/include/boost/proto/expr.hpp	/^                typedef not_a_valid_type type;$/;"	t	struct:boost::proto::detail::address_of_hack	access:public
type	/usr/include/boost/proto/expr.hpp	/^                typedef U const type;$/;"	t	struct:boost::proto::detail::same_cv	access:public
type	/usr/include/boost/proto/expr.hpp	/^                typedef U type;$/;"	t	struct:boost::proto::detail::same_cv	access:public
type	/usr/include/boost/proto/fusion.hpp	/^                > type;$/;"	t	struct:boost::fusion::extension::segments_impl::apply	access:public
type	/usr/include/boost/proto/fusion.hpp	/^                type;$/;"	t	struct:boost::fusion::extension::advance_impl::apply	access:public
type	/usr/include/boost/proto/fusion.hpp	/^                type;$/;"	t	struct:boost::fusion::extension::at_impl::apply	access:public
type	/usr/include/boost/proto/fusion.hpp	/^                type;$/;"	t	struct:boost::fusion::extension::deref_impl::apply	access:public
type	/usr/include/boost/proto/fusion.hpp	/^                type;$/;"	t	struct:boost::fusion::extension::end_impl::apply	access:public
type	/usr/include/boost/proto/fusion.hpp	/^                type;$/;"	t	struct:boost::fusion::extension::value_at_impl::apply	access:public
type	/usr/include/boost/proto/fusion.hpp	/^                type;$/;"	t	struct:boost::fusion::extension::value_of_impl::apply	access:public
type	/usr/include/boost/proto/fusion.hpp	/^                typedef forward_traversal_tag type;$/;"	t	struct:boost::fusion::extension::category_of_impl::apply	access:public
type	/usr/include/boost/proto/fusion.hpp	/^                typedef proto::detail::expr_iterator<Sequence, 0> type;$/;"	t	struct:boost::fusion::extension::begin_impl::apply	access:public
type	/usr/include/boost/proto/fusion.hpp	/^                typedef proto::detail::flat_view<Expr> type;$/;"	t	struct:boost::proto::functional::flatten::result	access:public
type	/usr/include/boost/proto/fusion.hpp	/^                typedef random_access_traversal_tag type;$/;"	t	struct:boost::fusion::extension::category_of_impl::apply	access:public
type	/usr/include/boost/proto/fusion.hpp	/^            typedef detail::flat_view<Expr> type;$/;"	t	struct:boost::proto::result_of::flatten	access:public
type	/usr/include/boost/proto/fusion.hpp	/^        typedef fusion::fusion_sequence_tag type;$/;"	t	struct:boost::mpl::sequence_tag	access:public
type	/usr/include/boost/proto/generate.hpp	/^                    type;$/;"	t	struct:boost::proto::generatorns_::by_value_generator::result	access:public
type	/usr/include/boost/proto/generate.hpp	/^                    type;$/;"	t	struct:boost::proto::generatorns_::compose_generators::result	access:public
type	/usr/include/boost/proto/generate.hpp	/^                    typedef Expr type;$/;"	t	struct:boost::proto::generatorns_::default_generator::result	access:public
type	/usr/include/boost/proto/generate.hpp	/^                    typedef Extends<Expr> type;$/;"	t	struct:boost::proto::generatorns_::generator::result	access:public
type	/usr/include/boost/proto/generate.hpp	/^                    typedef Extends<Expr> type;$/;"	t	struct:boost::proto::generatorns_::pod_generator::result	access:public
type	/usr/include/boost/proto/generate.hpp	/^                type;$/;"	t	struct:boost::proto::detail::by_value_generator_	access:public
type	/usr/include/boost/proto/generate.hpp	/^            typedef Expr type;$/;"	t	struct:boost::result_of	access:public
type	/usr/include/boost/proto/make_expr.hpp	/^                    type;$/;"	t	struct:boost::proto::functional::make_expr::result	access:public
type	/usr/include/boost/proto/make_expr.hpp	/^                    type;$/;"	t	struct:boost::proto::functional::unfused_expr_fun::result	access:public
type	/usr/include/boost/proto/make_expr.hpp	/^                    type;$/;"	t	struct:boost::proto::functional::unpack_expr::result	access:public
type	/usr/include/boost/proto/make_expr.hpp	/^                type;$/;"	t	struct:boost::proto::detail::protoify_	access:public
type	/usr/include/boost/proto/make_expr.hpp	/^                type;$/;"	t	struct:boost::proto::detail::unpack_expr_	access:public
type	/usr/include/boost/proto/make_expr.hpp	/^                type;$/;"	t	struct:boost::proto::result_of::make_expr	access:public
type	/usr/include/boost/proto/make_expr.hpp	/^                type;$/;"	t	struct:boost::proto::result_of::unpack_expr	access:public
type	/usr/include/boost/proto/make_expr.hpp	/^                typedef default_domain type;$/;"	t	struct:boost::proto::detail::deduce_domain0	access:public
type	/usr/include/boost/proto/make_expr.hpp	/^                typedef default_domain type;$/;"	t	struct:boost::proto::detail::select_nth	access:public
type	/usr/include/boost/proto/make_expr.hpp	/^                typedef nondeduced_domain type;$/;"	t	struct:boost::proto::detail::nondeduced_domain	access:public
type	/usr/include/boost/proto/matches.hpp	/^                typedef G0 type;$/;"	t	struct:boost::proto::detail::last	access:public
type	/usr/include/boost/proto/matches.hpp	/^                typedef proto::_ type;$/;"	t	struct:boost::proto::detail::last	access:public
type	/usr/include/boost/proto/operators.hpp	/^            typedef Domain1 type;$/;"	t	struct:boost::proto::detail::choose_domain2	access:public
type	/usr/include/boost/proto/operators.hpp	/^            typedef Domain2 type;$/;"	t	struct:boost::proto::detail::choose_domain2	access:public
type	/usr/include/boost/proto/operators.hpp	/^            typedef Expr type;$/;"	t	struct:boost::proto::detail::generate_if	access:public
type	/usr/include/boost/proto/operators.hpp	/^            typedef proto::default_domain type;$/;"	t	struct:boost::proto::detail::choose_domain2	access:public
type	/usr/include/boost/proto/operators.hpp	/^            typedef proto::expr<Tag, proto::list2<Left &, Right>, 2> type;$/;"	t	struct:boost::proto::detail::generate_if_left	access:public
type	/usr/include/boost/proto/operators.hpp	/^            typedef proto::expr<Tag, proto::list2<Left, Right &>, 2> type;$/;"	t	struct:boost::proto::detail::generate_if_right	access:public
type	/usr/include/boost/proto/proto_fwd.hpp	/^            typedef T type;$/;"	t	struct:boost::proto::detail::uncvref	access:public
type	/usr/include/boost/proto/traits.hpp	/^                    typedef typename result_of::as_child<unref_type, Domain>::type type;$/;"	t	struct:boost::proto::functional::as_child::result	access:public
type	/usr/include/boost/proto/traits.hpp	/^                    typedef typename result_of::as_expr<unref_type, Domain>::type type;$/;"	t	struct:boost::proto::functional::as_expr::result	access:public
type	/usr/include/boost/proto/traits.hpp	/^                    typedef typename result_of::child<Expr, N>::type type;$/;"	t	struct:boost::proto::functional::child::result	access:public
type	/usr/include/boost/proto/traits.hpp	/^                    typedef typename result_of::child_c<Expr, N>::type type;$/;"	t	struct:boost::proto::functional::child_c::result	access:public
type	/usr/include/boost/proto/traits.hpp	/^                    typedef typename result_of::left<Expr>::type type;$/;"	t	struct:boost::proto::functional::left::result	access:public
type	/usr/include/boost/proto/traits.hpp	/^                    typedef typename result_of::right<Expr>::type type;$/;"	t	struct:boost::proto::functional::right::result	access:public
type	/usr/include/boost/proto/traits.hpp	/^                    typedef typename result_of::value<Expr>::type type;$/;"	t	struct:boost::proto::functional::value::result	access:public
type	/usr/include/boost/proto/traits.hpp	/^                typedef proto::expr<proto::tag::if_else_, list3<T, U, V>, 3> type;$/;"	t	struct:boost::proto::op::if_else_	access:public
type	/usr/include/boost/proto/traits.hpp	/^                typedef proto::expr<proto::tag::terminal, term<T>, 0> type;$/;"	t	struct:boost::proto::op::terminal	access:public
type	/usr/include/boost/proto/traits.hpp	/^                typedef proto::expr<Tag, list1<T>, 1> type;$/;"	t	struct:boost::proto::op::unary_expr	access:public
type	/usr/include/boost/proto/traits.hpp	/^                typedef proto::expr<Tag, list2<T, U>, 2> type;$/;"	t	struct:boost::proto::op::binary_expr	access:public
type	/usr/include/boost/proto/traits.hpp	/^                typedef proto::expr<Tag, term<T>, 0> type;$/;"	t	struct:boost::proto::op::nullary_expr	access:public
type	/usr/include/boost/proto/traits.hpp	/^                typedef T &type;$/;"	t	struct:boost::proto::result_of::as_child	access:public
type	/usr/include/boost/proto/traits.hpp	/^                typedef typename detail::term_traits<typename Expr::proto_child0>::const_reference type;$/;"	t	struct:boost::proto::result_of::value	access:public
type	/usr/include/boost/proto/traits.hpp	/^                typedef typename detail::term_traits<typename Expr::proto_child0>::reference type;$/;"	t	struct:boost::proto::result_of::value	access:public
type	/usr/include/boost/proto/traits.hpp	/^                typedef typename detail::term_traits<typename Expr::proto_child0>::value_type type;$/;"	t	struct:boost::proto::result_of::value	access:public
type	/usr/include/boost/proto/traits.hpp	/^                typedef typename Domain::template result<Domain(expr_)>::type type;$/;"	t	struct:boost::proto::result_of::as_child	access:public
type	/usr/include/boost/proto/traits.hpp	/^                typedef typename Domain::template result<Domain(expr_)>::type type;$/;"	t	struct:boost::proto::result_of::as_expr	access:public
type	/usr/include/boost/proto/traits.hpp	/^                typedef typename Domain::template result<Domain(typename T::proto_derived_expr)>::type type;$/;"	t	struct:boost::proto::result_of::as_child	access:public
type	/usr/include/boost/proto/traits.hpp	/^                typedef typename Expr::proto_tag type;$/;"	t	struct:boost::proto::result_of::tag_of	access:public
type	/usr/include/boost/proto/traits.hpp	/^                typedef typename T::proto_derived_expr type; \/\/ removes the const$/;"	t	struct:boost::proto::result_of::as_expr	access:public
type	/usr/include/boost/proto/transform/arg.hpp	/^            typedef boost::reference_wrapper<T const> const type;$/;"	t	class:boost::proto::_byref::result::boost	access:public
type	/usr/include/boost/proto/transform/arg.hpp	/^            typedef boost::reference_wrapper<T> const type;$/;"	t	class:boost::proto::_byref::result::boost	access:public
type	/usr/include/boost/proto/transform/arg.hpp	/^            typedef T type;$/;"	t	struct:boost::proto::_byval::result	access:public
type	/usr/include/boost/proto/transform/fold.hpp	/^                    type;$/;"	t	struct:boost::proto::detail::as_callable::result	access:public
type	/usr/include/boost/proto/transform/make.hpp	/^                typedef proto::expr<Tag, Args, N> type;$/;"	t	struct:boost::proto::detail::make_if_	access:public
type	/usr/include/boost/proto/transform/make.hpp	/^                typedef R type;$/;"	t	struct:boost::proto::detail::make_	access:public
type	/usr/include/boost/proto/transform/make.hpp	/^                typedef T type;$/;"	t	struct:boost::proto::detail::nested_type	access:public
type	/usr/include/boost/proto/transform/make.hpp	/^                typedef typename T::type type;$/;"	t	struct:boost::proto::detail::nested_type	access:public
type	/usr/include/boost/proto/transform/make.hpp	/^                typedef void type;$/;"	t	struct:boost::proto::detail::typelist	access:public
typelist	/usr/include/boost/proto/transform/make.hpp	/^            struct typelist$/;"	s	namespace:boost::proto::detail
unary_expr	/usr/include/boost/proto/traits.hpp	/^            struct unary_expr$/;"	s	namespace:boost::proto::op	inherits:proto::transform
unary_plus	/usr/include/boost/proto/tags.hpp	/^    struct unary_plus {};$/;"	s	namespace:boost::proto::tag
uncvref	/usr/include/boost/proto/proto_fwd.hpp	/^        struct uncvref$/;"	s	namespace:boost::proto::detail
uncvref	/usr/include/boost/proto/proto_fwd.hpp	/^        struct uncvref<T &>$/;"	s	namespace:boost::proto::detail
uncvref	/usr/include/boost/proto/proto_fwd.hpp	/^        struct uncvref<T const &>$/;"	s	namespace:boost::proto::detail
uncvref	/usr/include/boost/proto/proto_fwd.hpp	/^        struct uncvref<T const>$/;"	s	namespace:boost::proto::detail
uncv_a0_type	/usr/include/boost/proto/make_expr.hpp	/^                typedef typename remove_cv<A0>::type uncv_a0_type;$/;"	t	struct:boost::proto::detail::implicit_expr_1	access:public
unexpr	/usr/include/boost/proto/expr.hpp	/^            explicit unexpr(Expr const &e)$/;"	f	struct:boost::proto::unexpr	access:public	signature:(Expr const &e)
unexpr	/usr/include/boost/proto/expr.hpp	/^        struct unexpr$/;"	s	namespace:boost::proto	inherits:Expr
unfused_expr	/usr/include/boost/proto/make_expr.hpp	/^            struct unfused_expr$/;"	s	namespace:boost::proto::functional	inherits:fusion::unfused_generic
unfused_expr_fun	/usr/include/boost/proto/make_expr.hpp	/^            struct unfused_expr_fun$/;"	s	namespace:boost::proto::functional
unknown_function_t	/usr/include/boost/proto/detail/poly_function.hpp	/^        typedef char (&unknown_function_t)[3];$/;"	t	namespace:boost::proto::detail
unpack_expr	/usr/include/boost/proto/make_expr.hpp	/^            struct unpack_expr$/;"	s	namespace:boost::proto::functional
unpack_expr	/usr/include/boost/proto/make_expr.hpp	/^            struct unpack_expr$/;"	s	namespace:boost::proto::result_of
unpack_expr	/usr/include/boost/proto/make_expr.hpp	/^            struct unpack_expr<Tag, Domain, Sequence, typename Domain::proto_is_domain_>$/;"	s	namespace:boost::proto::result_of
unpack_expr	/usr/include/boost/proto/make_expr.hpp	/^        unpack_expr(Sequence const &sequence)$/;"	f	class:boost::proto::lazy_disable_if	signature:(Sequence const &sequence)
unpack_expr	/usr/include/boost/proto/make_expr.hpp	/^        unpack_expr(Sequence2 const &sequence2)$/;"	f	class:boost::proto::result_of::unpack_expr	signature:(Sequence2 const &sequence2)
unpack_expr_	/usr/include/boost/proto/make_expr.hpp	/^            struct unpack_expr_$/;"	s	namespace:boost::proto::detail
unpack_expr_	/usr/include/boost/proto/make_expr.hpp	/^            struct unpack_expr_<tag::terminal, deduce_domain, Sequence, 1u>$/;"	s	namespace:boost::proto::detail	inherits:unpack_expr_
unpack_expr_	/usr/include/boost/proto/make_expr.hpp	/^            struct unpack_expr_<tag::terminal, Domain, Sequence, 1u>$/;"	s	namespace:boost::proto::detail
UNREF	/usr/include/boost/proto/context/default.hpp	35;"	d
UNREF	/usr/include/boost/proto/context/default.hpp	395;"	d
unref_type	/usr/include/boost/proto/make_expr.hpp	/^                unref_type;$/;"	t	struct:boost::proto::detail::protoify_	access:public
unref_type	/usr/include/boost/proto/traits.hpp	/^                    typedef typename remove_reference<T>::type unref_type;$/;"	t	struct:boost::proto::functional::as_child::result	access:public
unref_type	/usr/include/boost/proto/traits.hpp	/^                    typedef typename remove_reference<T>::type unref_type;$/;"	t	struct:boost::proto::functional::as_expr::result	access:public
utility	/usr/include/boost/proto/literal.hpp	/^    namespace utility$/;"	n	namespace:boost::proto
utility	/usr/include/boost/proto/proto_fwd.hpp	/^    namespace utility$/;"	n	namespace:boost::proto
V	/usr/include/boost/proto/detail/decltype.hpp	/^                V;$/;"	t	struct:boost::proto::detail::get_pointerns::mem_ptr_fun	access:public
V	/usr/include/boost/proto/detail/decltype.hpp	/^            typedef typename classtypeof<pmf_type>::type V;$/;"	t	struct:boost::proto::detail::memfun	access:public
value	/usr/include/boost/proto/detail/poly_function.hpp	/^            type value;$/;"	m	struct:boost::proto::detail::arg	access:private
value	/usr/include/boost/proto/traits.hpp	/^            struct value$/;"	s	namespace:boost::proto::functional
value	/usr/include/boost/proto/traits.hpp	/^            struct value$/;"	s	namespace:boost::proto::result_of
value	/usr/include/boost/proto/traits.hpp	/^            struct value<Expr &>$/;"	s	namespace:boost::proto::result_of
value	/usr/include/boost/proto/traits.hpp	/^            struct value<Expr const &>$/;"	s	namespace:boost::proto::result_of
value	/usr/include/boost/proto/traits.hpp	/^        value(Expr const &e)$/;"	f	namespace:boost::proto	signature:(Expr const &e)
value_at_impl	/usr/include/boost/proto/fusion.hpp	/^        struct value_at_impl<proto::tag::proto_expr>$/;"	s	namespace:boost::fusion::extension
value_impl	/usr/include/boost/proto/detail/reverse.hpp	/^        struct value_impl<reverse_view_iterator_tag>$/;"	s	namespace:boost::fusion::meta
value_of_impl	/usr/include/boost/proto/fusion.hpp	/^        struct value_of_impl<proto::tag::proto_expr_iterator>$/;"	s	namespace:boost::fusion::extension
value_type	/usr/include/boost/proto/args.hpp	/^                typedef Expr value_type;$/;"	t	struct:boost::proto::detail::expr_traits	access:public
value_type	/usr/include/boost/proto/args.hpp	/^                typedef T value_type;$/;"	t	struct:boost::proto::detail::term_traits	access:public
value_type	/usr/include/boost/proto/args.hpp	/^                typedef T value_type[N];$/;"	t	struct:boost::proto::detail::term_traits	access:public
value_type	/usr/include/boost/proto/args.hpp	/^                typedef typename mpl::if_c<is_function<T>::value, T &, T>::type value_type;$/;"	t	struct:boost::proto::detail::term_traits	access:public
value_type	/usr/include/boost/proto/context/callable.hpp	/^                typedef typename proto::result_of::value<Expr const &>::type value_type;$/;"	t	struct:boost::proto::context::callable_eval	access:public
value_type	/usr/include/boost/proto/literal.hpp	/^            typedef typename detail::term_traits<T>::value_type       value_type;$/;"	t	struct:boost::proto::utility::literal	access:public
value_type	/usr/include/boost/proto/traits.hpp	/^                typedef typename Expr::proto_child0 value_type;$/;"	t	struct:boost::proto::result_of::value	access:public
vararg	/usr/include/boost/proto/matches.hpp	/^            struct vararg$/;"	s	namespace:boost::proto::control	inherits:Grammar
vararg_matches	/usr/include/boost/proto/matches.hpp	/^            struct vararg_matches$/;"	s	namespace:boost::proto::detail	inherits:mpl::false_
vararg_matches	/usr/include/boost/proto/matches.hpp	/^            struct vararg_matches<Args1, Args2, Back, true, false, typename Back::proto_is_vararg_>$/;"	s	namespace:boost::proto::detail	inherits:and_2
vararg_matches	/usr/include/boost/proto/matches.hpp	/^            struct vararg_matches<Args1, Args2, Back, true, true, typename Back::proto_is_vararg_>$/;"	s	namespace:boost::proto::detail	inherits:matches_
virtual_member	/usr/include/boost/proto/extends.hpp	/^        struct virtual_member$/;"	s	namespace:boost::proto::exprns_
when	/usr/include/boost/proto/transform/when.hpp	/^        struct when$/;"	s	namespace:boost::proto	inherits:PrimitiveTransform
when	/usr/include/boost/proto/transform/when.hpp	/^        struct when<Grammar, Fun *>$/;"	s	namespace:boost::proto	inherits:when
which	/usr/include/boost/proto/matches.hpp	/^                    which;$/;"	t	struct:boost::proto::control::if_::impl	access:public
which	/usr/include/boost/proto/matches.hpp	/^                typedef G0 which;$/;"	t	struct:boost::proto::detail::matches_	access:public
which	/usr/include/boost/proto/matches.hpp	/^                typedef not_<_> which;$/;"	t	struct:boost::proto::detail::matches_	access:public
wildcardns_	/usr/include/boost/proto/matches.hpp	/^        namespace wildcardns_$/;"	n	namespace:boost::proto
wildcardns_	/usr/include/boost/proto/proto_fwd.hpp	/^    namespace wildcardns_$/;"	n	namespace:boost::proto
wrapped	/usr/include/boost/proto/detail/reverse.hpp	/^                wrapped;$/;"	t	struct:boost::fusion::meta::next_impl::apply	access:public
wrapped	/usr/include/boost/proto/detail/reverse.hpp	/^                wrapped;$/;"	t	struct:boost::fusion::meta::prior_impl::apply	access:public
yes_type	/usr/include/boost/proto/proto_fwd.hpp	/^        typedef char yes_type;$/;"	t	namespace:boost::proto::detail
_	/usr/include/boost/proto/matches.hpp	/^            struct _ : transform<_>$/;"	s	namespace:boost::proto::wildcardns_	inherits:transform
_byref	/usr/include/boost/proto/transform/arg.hpp	/^    struct _byref : callable$/;"	s	namespace:boost::proto	inherits:callable
_byval	/usr/include/boost/proto/transform/arg.hpp	/^    struct _byval : callable$/;"	s	namespace:boost::proto	inherits:callable
_child	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef _child0     _child;$/;"	t	namespace:boost::proto
_child0	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef _child_c<0> _child0;$/;"	t	namespace:boost::proto
_child1	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef _child_c<1> _child1;$/;"	t	namespace:boost::proto
_child_c	/usr/include/boost/proto/transform/arg.hpp	/^    struct _child_c : transform<_child_c<N> >$/;"	s	namespace:boost::proto	inherits:transform
_data	/usr/include/boost/proto/transform/arg.hpp	/^    struct _data : transform<_data>$/;"	s	namespace:boost::proto	inherits:transform
_deep_copy	/usr/include/boost/proto/deep_copy.hpp	/^        struct _deep_copy$/;"	s	namespace:boost::proto	inherits:proto::transform
_default	/usr/include/boost/proto/transform/default.hpp	/^            struct _default$/;"	s	namespace:boost::proto::detail	inherits:proto::_default
_default	/usr/include/boost/proto/transform/default.hpp	/^        struct _default$/;"	s	namespace:boost::proto	inherits:transform
_eval	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::eval        _eval;$/;"	t	namespace:boost::proto
_expr	/usr/include/boost/proto/transform/arg.hpp	/^    struct _expr : transform<_expr>$/;"	s	namespace:boost::proto	inherits:transform
_flatten	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::flatten     _flatten;$/;"	t	namespace:boost::proto
_left	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef _child0     _left;$/;"	t	namespace:boost::proto
_make_address_of	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::address_of>         _make_address_of;$/;"	t	namespace:boost::proto
_make_assign	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::assign>             _make_assign;$/;"	t	namespace:boost::proto
_make_bitwise_and	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::bitwise_and>        _make_bitwise_and;$/;"	t	namespace:boost::proto
_make_bitwise_and_assign	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::bitwise_and_assign> _make_bitwise_and_assign;$/;"	t	namespace:boost::proto
_make_bitwise_or	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::bitwise_or>         _make_bitwise_or;$/;"	t	namespace:boost::proto
_make_bitwise_or_assign	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::bitwise_or_assign>  _make_bitwise_or_assign;$/;"	t	namespace:boost::proto
_make_bitwise_xor	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::bitwise_xor>        _make_bitwise_xor;$/;"	t	namespace:boost::proto
_make_bitwise_xor_assign	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::bitwise_xor_assign> _make_bitwise_xor_assign;$/;"	t	namespace:boost::proto
_make_comma	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::comma>              _make_comma;$/;"	t	namespace:boost::proto
_make_complement	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::complement>         _make_complement;$/;"	t	namespace:boost::proto
_make_dereference	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::dereference>        _make_dereference;$/;"	t	namespace:boost::proto
_make_divides	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::divides>            _make_divides;$/;"	t	namespace:boost::proto
_make_divides_assign	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::divides_assign>     _make_divides_assign;$/;"	t	namespace:boost::proto
_make_equal_to	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::equal_to>           _make_equal_to;$/;"	t	namespace:boost::proto
_make_function	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::function>           _make_function;$/;"	t	namespace:boost::proto
_make_greater	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::greater>            _make_greater;$/;"	t	namespace:boost::proto
_make_greater_equal	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::greater_equal>      _make_greater_equal;$/;"	t	namespace:boost::proto
_make_if_else	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::if_else_>           _make_if_else;$/;"	t	namespace:boost::proto
_make_less	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::less>               _make_less;$/;"	t	namespace:boost::proto
_make_less_equal	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::less_equal>         _make_less_equal;$/;"	t	namespace:boost::proto
_make_logical_and	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::logical_and>        _make_logical_and;$/;"	t	namespace:boost::proto
_make_logical_not	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::logical_not>        _make_logical_not;$/;"	t	namespace:boost::proto
_make_logical_or	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::logical_or>         _make_logical_or;$/;"	t	namespace:boost::proto
_make_mem_ptr	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::mem_ptr>            _make_mem_ptr;$/;"	t	namespace:boost::proto
_make_minus	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::minus>              _make_minus;$/;"	t	namespace:boost::proto
_make_minus_assign	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::minus_assign>       _make_minus_assign;$/;"	t	namespace:boost::proto
_make_modulus	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::modulus>            _make_modulus;$/;"	t	namespace:boost::proto
_make_modulus_assign	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::modulus_assign>     _make_modulus_assign;$/;"	t	namespace:boost::proto
_make_multiplies	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::multiplies>         _make_multiplies;$/;"	t	namespace:boost::proto
_make_multiplies_assign	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::multiplies_assign>  _make_multiplies_assign;$/;"	t	namespace:boost::proto
_make_negate	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::negate>             _make_negate;$/;"	t	namespace:boost::proto
_make_not_equal_to	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::not_equal_to>       _make_not_equal_to;$/;"	t	namespace:boost::proto
_make_plus	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::plus>               _make_plus;$/;"	t	namespace:boost::proto
_make_plus_assign	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::plus_assign>        _make_plus_assign;$/;"	t	namespace:boost::proto
_make_post_dec	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::post_dec>           _make_post_dec;$/;"	t	namespace:boost::proto
_make_post_inc	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::post_inc>           _make_post_inc;$/;"	t	namespace:boost::proto
_make_pre_dec	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::pre_dec>            _make_pre_dec;$/;"	t	namespace:boost::proto
_make_pre_inc	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::pre_inc>            _make_pre_inc;$/;"	t	namespace:boost::proto
_make_shift_left	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::shift_left>         _make_shift_left;$/;"	t	namespace:boost::proto
_make_shift_left_assign	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::shift_left_assign>  _make_shift_left_assign;$/;"	t	namespace:boost::proto
_make_shift_right	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::shift_right>        _make_shift_right;$/;"	t	namespace:boost::proto
_make_shift_right_assign	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::shift_right_assign> _make_shift_right_assign;$/;"	t	namespace:boost::proto
_make_subscript	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::subscript>          _make_subscript;$/;"	t	namespace:boost::proto
_make_terminal	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::terminal>           _make_terminal;$/;"	t	namespace:boost::proto
_make_unary_plus	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::make_expr<tag::unary_plus>         _make_unary_plus;$/;"	t	namespace:boost::proto
_pop_front	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::pop_front   _pop_front;$/;"	t	namespace:boost::proto
_reverse	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef functional::reverse     _reverse;$/;"	t	namespace:boost::proto
_right	/usr/include/boost/proto/proto_fwd.hpp	/^    typedef _child1     _right;$/;"	t	namespace:boost::proto
_state	/usr/include/boost/proto/transform/arg.hpp	/^    struct _state : transform<_state>$/;"	s	namespace:boost::proto	inherits:transform
_value	/usr/include/boost/proto/transform/arg.hpp	/^    struct _value : transform<_value>$/;"	s	namespace:boost::proto	inherits:transform
