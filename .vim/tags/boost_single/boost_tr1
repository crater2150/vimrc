!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	2	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
arg	/usr/include/boost/tr1/complex.hpp	/^inline BOOST_TR1_MATH_RETURN(double) arg(const T& t)$/;"	f	namespace:std	signature:(const T& t)
arg	/usr/include/boost/tr1/complex.hpp	/^inline float arg(const float& t)$/;"	f	namespace:std	signature:(const float& t)
arg	/usr/include/boost/tr1/complex.hpp	/^inline long double arg(const long double& t)$/;"	f	namespace:std	signature:(const long double& t)
base1	/usr/include/boost/tr1/random.hpp	/^   const base1_type& base1() const$/;"	f	class:std::tr1::xor_combine	access:public	signature:() const
base1_type	/usr/include/boost/tr1/random.hpp	/^   typedef UniformRandomNumberGenerator1 base1_type;$/;"	t	class:std::tr1::xor_combine	access:public
base2	/usr/include/boost/tr1/random.hpp	/^   const base2_type& base2() const$/;"	f	class:std::tr1::xor_combine	access:public	signature:() const
base2_type	/usr/include/boost/tr1/random.hpp	/^   typedef UniformRandomNumberGenerator2 base2_type;$/;"	t	class:std::tr1::xor_combine	access:public
boost	/usr/include/boost/tr1/array.hpp	/^}} namespace boost{ namespace fusion{$/;"	n
boost	/usr/include/boost/tr1/detail/functor2iterator.hpp	/^namespace boost{ namespace tr1_details{$/;"	n
boost	/usr/include/boost/tr1/detail/math_overloads.hpp	/^namespace boost{ namespace tr1_detail{$/;"	n
boost	/usr/include/boost/tr1/functional.hpp	/^namespace boost{$/;"	n
boost	/usr/include/boost/tr1/memory.hpp	/^namespace boost{$/;"	n
boost::const_pointer_cast	/usr/include/boost/tr1/memory.hpp	/^template<class T, class U> shared_ptr<T> const_pointer_cast(shared_ptr<U> const & r);$/;"	p	namespace:boost	signature:(shared_ptr<U> const & r)
boost::detail	/usr/include/boost/tr1/memory.hpp	/^namespace detail{$/;"	n	namespace:boost
boost::dynamic_pointer_cast	/usr/include/boost/tr1/memory.hpp	/^template<class T, class U> shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const & r);$/;"	p	namespace:boost	signature:(shared_ptr<U> const & r)
boost::fusion	/usr/include/boost/tr1/array.hpp	/^}} namespace boost{ namespace fusion{$/;"	n	namespace:boost
boost::fusion::get	/usr/include/boost/tr1/array.hpp	/^const T& get(const array<T, N>& a)$/;"	f	namespace:boost::fusion	signature:(const array<T, N>& a)
boost::fusion::get	/usr/include/boost/tr1/array.hpp	/^T& get( ::boost::array<T, N>& a)$/;"	f	namespace:boost::fusion	signature:( ::boost::array<T, N>& a)
boost::fusion::tuple_element	/usr/include/boost/tr1/array.hpp	/^struct tuple_element<I, ::boost::array<T, N> >$/;"	s	namespace:boost::fusion
boost::fusion::tuple_element::BOOST_STATIC_ASSERT	/usr/include/boost/tr1/array.hpp	/^   BOOST_STATIC_ASSERT(I < (int)N);$/;"	p	struct:boost::fusion::tuple_element	access:public	signature:(I < (int)N); BOOST_STATIC_ASSERT(I >= 0)
boost::fusion::tuple_element::type	/usr/include/boost/tr1/array.hpp	/^   typedef T type;$/;"	t	struct:boost::fusion::tuple_element	access:public
boost::fusion::tuple_size	/usr/include/boost/tr1/array.hpp	/^struct tuple_size< ::boost::array<T, N> >$/;"	s	namespace:boost::fusion	inherits:::boost::integral_constant
boost::get_deleter	/usr/include/boost/tr1/memory.hpp	/^template<class D, class T> D * get_deleter(shared_ptr<T> const & p);$/;"	p	namespace:boost	signature:(shared_ptr<T> const & p)
boost::static_pointer_cast	/usr/include/boost/tr1/memory.hpp	/^template<class T, class U> shared_ptr<T> static_pointer_cast(shared_ptr<U> const & r);$/;"	p	namespace:boost	signature:(shared_ptr<U> const & r)
boost::swap	/usr/include/boost/tr1/memory.hpp	/^template<class T> void swap(shared_ptr<T> & a, shared_ptr<T> & b);$/;"	p	namespace:boost	signature:(shared_ptr<T> & a, shared_ptr<T> & b)
boost::swap	/usr/include/boost/tr1/memory.hpp	/^template<class T> void swap(weak_ptr<T> & a, weak_ptr<T> & b);$/;"	p	namespace:boost	signature:(weak_ptr<T> & a, weak_ptr<T> & b)
boost::tr1_detail	/usr/include/boost/tr1/detail/math_overloads.hpp	/^namespace boost{ namespace tr1_detail{$/;"	n	namespace:boost
boost::tr1_detail::largest_real	/usr/include/boost/tr1/detail/math_overloads.hpp	/^struct largest_real$/;"	s	namespace:boost::tr1_detail
boost::tr1_detail::largest_real::type	/usr/include/boost/tr1/detail/math_overloads.hpp	/^   >::type type;$/;"	t	struct:boost::tr1_detail::largest_real	access:public
boost::tr1_detail::promote_to_real	/usr/include/boost/tr1/detail/math_overloads.hpp	/^struct promote_to_real$/;"	s	namespace:boost::tr1_detail
boost::tr1_detail::promote_to_real::type	/usr/include/boost/tr1/detail/math_overloads.hpp	/^   >::type type;$/;"	t	struct:boost::tr1_detail::promote_to_real	access:public
boost::tr1_details	/usr/include/boost/tr1/detail/functor2iterator.hpp	/^namespace boost{ namespace tr1_details{$/;"	n	namespace:boost
boost::tr1_details::functor2iterator	/usr/include/boost/tr1/detail/functor2iterator.hpp	/^struct functor2iterator : boost::iterator_facade<functor2iterator<Func,R>, const R, std::input_iterator_tag>$/;"	s	namespace:boost::tr1_details	inherits:boost::iterator_facade
boost::tr1_details::functor2iterator::dereference	/usr/include/boost/tr1/detail/functor2iterator.hpp	/^   const R& dereference()const$/;"	f	struct:boost::tr1_details::functor2iterator	access:public	signature:() const
boost::tr1_details::functor2iterator::equal	/usr/include/boost/tr1/detail/functor2iterator.hpp	/^   bool equal(const functor2iterator&)const$/;"	f	struct:boost::tr1_details::functor2iterator	access:public	signature:(const functor2iterator&) const
boost::tr1_details::functor2iterator::functor2iterator	/usr/include/boost/tr1/detail/functor2iterator.hpp	/^   functor2iterator() : m_func(0){}$/;"	f	struct:boost::tr1_details::functor2iterator	access:public	signature:()
boost::tr1_details::functor2iterator::functor2iterator	/usr/include/boost/tr1/detail/functor2iterator.hpp	/^   functor2iterator(Func& f)$/;"	f	struct:boost::tr1_details::functor2iterator	access:public	signature:(Func& f)
boost::tr1_details::functor2iterator::increment	/usr/include/boost/tr1/detail/functor2iterator.hpp	/^   void increment(){ m_val = (*m_func)(); }$/;"	f	struct:boost::tr1_details::functor2iterator	access:public	signature:()
boost::tr1_details::functor2iterator::m_func	/usr/include/boost/tr1/detail/functor2iterator.hpp	/^   Func* m_func;$/;"	m	struct:boost::tr1_details::functor2iterator	access:private
boost::tr1_details::functor2iterator::m_val	/usr/include/boost/tr1/detail/functor2iterator.hpp	/^   R m_val;$/;"	m	struct:boost::tr1_details::functor2iterator	access:private
BOOST_HAS_CPP_0X	/usr/include/boost/tr1/detail/config_all.hpp	120;"	d
BOOST_HAS_INCLUDE_NEXT	/usr/include/boost/tr1/detail/config.hpp	13;"	d
BOOST_HAS_INCLUDE_NEXT	/usr/include/boost/tr1/detail/config_all.hpp	117;"	d
BOOST_HAS_TR1	/usr/include/boost/tr1/detail/config.hpp	54;"	d
BOOST_HAS_TR1_ARRAY	/usr/include/boost/tr1/detail/config.hpp	138;"	d
BOOST_HAS_TR1_ARRAY	/usr/include/boost/tr1/detail/config.hpp	64;"	d
BOOST_HAS_TR1_ARRAY	/usr/include/boost/tr1/detail/config.hpp	98;"	d
BOOST_HAS_TR1_BIND	/usr/include/boost/tr1/detail/config.hpp	106;"	d
BOOST_HAS_TR1_BIND	/usr/include/boost/tr1/detail/config.hpp	142;"	d
BOOST_HAS_TR1_BIND	/usr/include/boost/tr1/detail/config.hpp	70;"	d
BOOST_HAS_TR1_CMATH	/usr/include/boost/tr1/detail/config.hpp	114;"	d
BOOST_HAS_TR1_CMATH	/usr/include/boost/tr1/detail/config.hpp	81;"	d
BOOST_HAS_TR1_COMPLEX_INVERSE_TRIG	/usr/include/boost/tr1/detail/config.hpp	101;"	d
BOOST_HAS_TR1_COMPLEX_INVERSE_TRIG	/usr/include/boost/tr1/detail/config.hpp	59;"	d
BOOST_HAS_TR1_COMPLEX_INVERSE_TRIG	/usr/include/boost/tr1/detail/config.hpp	66;"	d
BOOST_HAS_TR1_COMPLEX_OVERLOADS	/usr/include/boost/tr1/detail/config.hpp	58;"	d
BOOST_HAS_TR1_COMPLEX_OVERLOADS	/usr/include/boost/tr1/detail/config.hpp	65;"	d
BOOST_HAS_TR1_FUNCTION	/usr/include/boost/tr1/detail/config.hpp	107;"	d
BOOST_HAS_TR1_FUNCTION	/usr/include/boost/tr1/detail/config.hpp	143;"	d
BOOST_HAS_TR1_FUNCTION	/usr/include/boost/tr1/detail/config.hpp	71;"	d
BOOST_HAS_TR1_FUNCTION	/usr/include/boost/tr1/detail/config.hpp	91;"	d
BOOST_HAS_TR1_HASH	/usr/include/boost/tr1/detail/config.hpp	108;"	d
BOOST_HAS_TR1_HASH	/usr/include/boost/tr1/detail/config.hpp	144;"	d
BOOST_HAS_TR1_HASH	/usr/include/boost/tr1/detail/config.hpp	154;"	d
BOOST_HAS_TR1_HASH	/usr/include/boost/tr1/detail/config.hpp	72;"	d
BOOST_HAS_TR1_MEM_FN	/usr/include/boost/tr1/detail/config.hpp	105;"	d
BOOST_HAS_TR1_MEM_FN	/usr/include/boost/tr1/detail/config.hpp	141;"	d
BOOST_HAS_TR1_MEM_FN	/usr/include/boost/tr1/detail/config.hpp	69;"	d
BOOST_HAS_TR1_RANDOM	/usr/include/boost/tr1/detail/config.hpp	111;"	d
BOOST_HAS_TR1_RANDOM	/usr/include/boost/tr1/detail/config.hpp	146;"	d
BOOST_HAS_TR1_RANDOM	/usr/include/boost/tr1/detail/config.hpp	74;"	d
BOOST_HAS_TR1_REFERENCE_WRAPPER	/usr/include/boost/tr1/detail/config.hpp	103;"	d
BOOST_HAS_TR1_REFERENCE_WRAPPER	/usr/include/boost/tr1/detail/config.hpp	139;"	d
BOOST_HAS_TR1_REFERENCE_WRAPPER	/usr/include/boost/tr1/detail/config.hpp	67;"	d
BOOST_HAS_TR1_REFERENCE_WRAPPER	/usr/include/boost/tr1/detail/config.hpp	90;"	d
BOOST_HAS_TR1_REGEX	/usr/include/boost/tr1/detail/config.hpp	147;"	d
BOOST_HAS_TR1_REGEX	/usr/include/boost/tr1/detail/config.hpp	75;"	d
BOOST_HAS_TR1_RESULT_OF	/usr/include/boost/tr1/detail/config.hpp	104;"	d
BOOST_HAS_TR1_RESULT_OF	/usr/include/boost/tr1/detail/config.hpp	140;"	d
BOOST_HAS_TR1_RESULT_OF	/usr/include/boost/tr1/detail/config.hpp	68;"	d
BOOST_HAS_TR1_RESULT_OF	/usr/include/boost/tr1/detail/config.hpp	93;"	d
BOOST_HAS_TR1_SHARED_PTR	/usr/include/boost/tr1/detail/config.hpp	109;"	d
BOOST_HAS_TR1_SHARED_PTR	/usr/include/boost/tr1/detail/config.hpp	145;"	d
BOOST_HAS_TR1_SHARED_PTR	/usr/include/boost/tr1/detail/config.hpp	73;"	d
BOOST_HAS_TR1_SHARED_PTR	/usr/include/boost/tr1/detail/config.hpp	89;"	d
BOOST_HAS_TR1_TUPLE	/usr/include/boost/tr1/detail/config.hpp	117;"	d
BOOST_HAS_TR1_TUPLE	/usr/include/boost/tr1/detail/config.hpp	148;"	d
BOOST_HAS_TR1_TUPLE	/usr/include/boost/tr1/detail/config.hpp	76;"	d
BOOST_HAS_TR1_TUPLE	/usr/include/boost/tr1/detail/config.hpp	92;"	d
BOOST_HAS_TR1_TYPE_TRAITS	/usr/include/boost/tr1/detail/config.hpp	118;"	d
BOOST_HAS_TR1_TYPE_TRAITS	/usr/include/boost/tr1/detail/config.hpp	149;"	d
BOOST_HAS_TR1_TYPE_TRAITS	/usr/include/boost/tr1/detail/config.hpp	77;"	d
BOOST_HAS_TR1_UNORDERED_MAP	/usr/include/boost/tr1/detail/config.hpp	120;"	d
BOOST_HAS_TR1_UNORDERED_MAP	/usr/include/boost/tr1/detail/config.hpp	151;"	d
BOOST_HAS_TR1_UNORDERED_MAP	/usr/include/boost/tr1/detail/config.hpp	79;"	d
BOOST_HAS_TR1_UNORDERED_SET	/usr/include/boost/tr1/detail/config.hpp	121;"	d
BOOST_HAS_TR1_UNORDERED_SET	/usr/include/boost/tr1/detail/config.hpp	152;"	d
BOOST_HAS_TR1_UNORDERED_SET	/usr/include/boost/tr1/detail/config.hpp	80;"	d
BOOST_HAS_TR1_UTILITY	/usr/include/boost/tr1/detail/config.hpp	119;"	d
BOOST_HAS_TR1_UTILITY	/usr/include/boost/tr1/detail/config.hpp	150;"	d
BOOST_HAS_TR1_UTILITY	/usr/include/boost/tr1/detail/config.hpp	78;"	d
BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/tr1/random.hpp	/^   result_type max BOOST_PREVENT_MACRO_SUBSTITUTION() const$/;"	f	class:std::tr1::linear_congruential	access:public	signature:() const
BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/tr1/random.hpp	/^   result_type max BOOST_PREVENT_MACRO_SUBSTITUTION() const$/;"	f	class:std::tr1::mersenne_twister	access:public	signature:() const
BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/tr1/random.hpp	/^   result_type max BOOST_PREVENT_MACRO_SUBSTITUTION() const$/;"	f	class:std::tr1::subtract_with_carry	access:public	signature:() const
BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/tr1/random.hpp	/^   result_type max BOOST_PREVENT_MACRO_SUBSTITUTION() const$/;"	f	class:std::tr1::subtract_with_carry_01	access:public	signature:() const
BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/tr1/random.hpp	/^   result_type max BOOST_PREVENT_MACRO_SUBSTITUTION() const$/;"	f	class:std::tr1::xor_combine	access:public	signature:() const
BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/tr1/random.hpp	/^   result_type min BOOST_PREVENT_MACRO_SUBSTITUTION() const$/;"	f	class:std::tr1::linear_congruential	access:public	signature:() const
BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/tr1/random.hpp	/^   result_type min BOOST_PREVENT_MACRO_SUBSTITUTION() const$/;"	f	class:std::tr1::mersenne_twister	access:public	signature:() const
BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/tr1/random.hpp	/^   result_type min BOOST_PREVENT_MACRO_SUBSTITUTION() const$/;"	f	class:std::tr1::subtract_with_carry	access:public	signature:() const
BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/tr1/random.hpp	/^   result_type min BOOST_PREVENT_MACRO_SUBSTITUTION() const$/;"	f	class:std::tr1::subtract_with_carry_01	access:public	signature:() const
BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/tr1/random.hpp	/^   result_type min BOOST_PREVENT_MACRO_SUBSTITUTION() const$/;"	f	class:std::tr1::xor_combine	access:public	signature:() const
BOOST_STATIC_ASSERT	/usr/include/boost/tr1/array.hpp	/^   BOOST_STATIC_ASSERT(I < (int)N);$/;"	p	struct:boost::fusion::tuple_element	access:public	signature:(I < (int)N); BOOST_STATIC_ASSERT(I >= 0)
BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(int, long_lag = r);$/;"	p	class:std::tr1::subtract_with_carry	access:public	signature:(int, long_lag = r)
BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(int, long_lag = r);$/;"	p	class:std::tr1::subtract_with_carry_01	access:public	signature:(int, long_lag = r)
BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(int, mask_bits = r);$/;"	p	class:std::tr1::mersenne_twister	access:public	signature:(int, mask_bits = r)
BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(int, output_l = l);$/;"	p	class:std::tr1::mersenne_twister	access:public	signature:(int, output_l = l)
BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(int, output_s = s);$/;"	p	class:std::tr1::mersenne_twister	access:public	signature:(int, output_s = s)
BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(int, output_t = t);$/;"	p	class:std::tr1::mersenne_twister	access:public	signature:(int, output_t = t)
BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(int, output_u = u);$/;"	p	class:std::tr1::mersenne_twister	access:public	signature:(int, output_u = u)
BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(int, shift1 = s1);$/;"	p	class:std::tr1::xor_combine	access:public	signature:(int, shift1 = s1)
BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(int, shift2 = s2);$/;"	p	class:std::tr1::xor_combine	access:public	signature:(int, shift2 = s2)
BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(int, shift_size = m);$/;"	p	class:std::tr1::mersenne_twister	access:public	signature:(int, shift_size = m)
BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(int, short_lag = s);$/;"	p	class:std::tr1::subtract_with_carry	access:public	signature:(int, short_lag = s)
BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(int, short_lag = s);$/;"	p	class:std::tr1::subtract_with_carry_01	access:public	signature:(int, short_lag = s)
BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(int, state_size = n);$/;"	p	class:std::tr1::mersenne_twister	access:public	signature:(int, state_size = n)
BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(int, word_size = w);$/;"	p	class:std::tr1::mersenne_twister	access:public	signature:(int, word_size = w)
BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(int, word_size = w);$/;"	p	class:std::tr1::subtract_with_carry_01	access:public	signature:(int, word_size = w)
BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(IntType, modulus = m);$/;"	p	class:std::tr1::subtract_with_carry	access:public	signature:(IntType, modulus = m)
BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(UIntType, increment = c);$/;"	p	class:std::tr1::linear_congruential	access:public	signature:(UIntType, increment = c)
BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(UIntType, modulus = m);$/;"	p	class:std::tr1::linear_congruential	access:public	signature:(UIntType, modulus = m)
BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(UIntType, multiplier = a);$/;"	p	class:std::tr1::linear_congruential	access:public	signature:(UIntType, multiplier = a)
BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(UIntType, output_b = b);$/;"	p	class:std::tr1::mersenne_twister	access:public	signature:(UIntType, output_b = b)
BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(UIntType, output_c = c);$/;"	p	class:std::tr1::mersenne_twister	access:public	signature:(UIntType, output_c = c)
BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(UIntType, parameter_a = a);$/;"	p	class:std::tr1::mersenne_twister	access:public	signature:(UIntType, parameter_a = a)
BOOST_TR1_ARRAY_HPP_INCLUDED	/usr/include/boost/tr1/array.hpp	7;"	d
BOOST_TR1_CMATH_HPP_INCLUDED	/usr/include/boost/tr1/cmath.hpp	7;"	d
BOOST_TR1_COMPLEX_HPP_INCLUDED	/usr/include/boost/tr1/complex.hpp	7;"	d
BOOST_TR1_DETAIL_CONFIG_ALL_HPP_INCLUDED	/usr/include/boost/tr1/detail/config_all.hpp	33;"	d
BOOST_TR1_DETAIL_CONFIG_HPP_INCLUDED	/usr/include/boost/tr1/detail/config.hpp	7;"	d
BOOST_TR1_DISABLE_INCLUDE_NEXT	/usr/include/boost/tr1/detail/config_all.hpp	105;"	d
BOOST_TR1_FUNCTIONAL_HPP_INCLUDED	/usr/include/boost/tr1/functional.hpp	7;"	d
BOOST_TR1_FUNCTOR_IT_HPP_INCLUDED	/usr/include/boost/tr1/detail/functor2iterator.hpp	7;"	d
BOOST_TR1_HEADER	/usr/include/boost/tr1/detail/config.hpp	45;"	d
BOOST_TR1_MATH_OVERLOADS_HPP_INCLUDED	/usr/include/boost/tr1/detail/math_overloads.hpp	7;"	d
BOOST_TR1_MATH_RETURN	/usr/include/boost/tr1/detail/math_overloads.hpp	13;"	d
BOOST_TR1_MATH_RETURN	/usr/include/boost/tr1/detail/math_overloads.hpp	15;"	d
BOOST_TR1_MEMORY_HPP_INCLUDED	/usr/include/boost/tr1/memory.hpp	7;"	d
BOOST_TR1_NO_CONFIG_ALL_RECURSION	/usr/include/boost/tr1/detail/config_all.hpp	139;"	d
BOOST_TR1_NO_CONFIG_ALL_RECURSION	/usr/include/boost/tr1/detail/config_all.hpp	147;"	d
BOOST_TR1_NO_CONFIG_RECURSION	/usr/include/boost/tr1/detail/config.hpp	22;"	d
BOOST_TR1_NO_CONFIG_RECURSION	/usr/include/boost/tr1/detail/config.hpp	30;"	d
BOOST_TR1_NO_RECURSION	/usr/include/boost/tr1/detail/config.hpp	21;"	d
BOOST_TR1_NO_RECURSION	/usr/include/boost/tr1/detail/config.hpp	31;"	d
BOOST_TR1_NO_RECURSION	/usr/include/boost/tr1/detail/config_all.hpp	138;"	d
BOOST_TR1_NO_RECURSION	/usr/include/boost/tr1/detail/config_all.hpp	148;"	d
BOOST_TR1_PATH	/usr/include/boost/tr1/detail/config.hpp	39;"	d
BOOST_TR1_PATH	/usr/include/boost/tr1/detail/config.hpp	42;"	d
BOOST_TR1_RANDOM_HPP_INCLUDED	/usr/include/boost/tr1/random.hpp	8;"	d
BOOST_TR1_REGEX_HPP_INCLUDED	/usr/include/boost/tr1/regex.hpp	7;"	d
BOOST_TR1_STD_CHEADER	/usr/include/boost/tr1/detail/config_all.hpp	113;"	d
BOOST_TR1_STD_CHEADER	/usr/include/boost/tr1/detail/config_all.hpp	52;"	d
BOOST_TR1_STD_HEADER	/usr/include/boost/tr1/detail/config_all.hpp	109;"	d
BOOST_TR1_STD_HEADER	/usr/include/boost/tr1/detail/config_all.hpp	60;"	d
BOOST_TR1_STD_HEADER	/usr/include/boost/tr1/detail/config_all.hpp	62;"	d
BOOST_TR1_STD_HEADER	/usr/include/boost/tr1/detail/config_all.hpp	64;"	d
BOOST_TR1_STD_HEADER	/usr/include/boost/tr1/detail/config_all.hpp	69;"	d
BOOST_TR1_STD_HEADER	/usr/include/boost/tr1/detail/config_all.hpp	72;"	d
BOOST_TR1_STD_HEADER	/usr/include/boost/tr1/detail/config_all.hpp	75;"	d
BOOST_TR1_STD_HEADER	/usr/include/boost/tr1/detail/config_all.hpp	79;"	d
BOOST_TR1_STD_HEADER	/usr/include/boost/tr1/detail/config_all.hpp	81;"	d
BOOST_TR1_STD_HEADER	/usr/include/boost/tr1/detail/config_all.hpp	84;"	d
BOOST_TR1_STD_HEADER	/usr/include/boost/tr1/detail/config_all.hpp	88;"	d
BOOST_TR1_STD_HEADER	/usr/include/boost/tr1/detail/config_all.hpp	95;"	d
BOOST_TR1_STD_HEADER	/usr/include/boost/tr1/detail/config_all.hpp	97;"	d
BOOST_TR1_TUPLE_HPP_INCLUDED	/usr/include/boost/tr1/tuple.hpp	7;"	d
BOOST_TR1_TYPE_TRAITS_HPP_INCLUDED	/usr/include/boost/tr1/type_traits.hpp	7;"	d
BOOST_TR1_UNORDERED_MAP_HPP_INCLUDED	/usr/include/boost/tr1/unordered_map.hpp	7;"	d
BOOST_TR1_UNORDERED_SET_HPP_INCLUDED	/usr/include/boost/tr1/unordered_set.hpp	7;"	d
BOOST_TR1_USE_OLD_TUPLE	/usr/include/boost/tr1/detail/config.hpp	49;"	d
BOOST_TR1_UTILITY_HPP_INCLUDED	/usr/include/boost/tr1/utility.hpp	7;"	d
conj	/usr/include/boost/tr1/complex.hpp	/^inline BOOST_TR1_MATH_RETURN(std::complex<double>) conj(const T& t)$/;"	f	namespace:std	signature:(const T& t)
conj	/usr/include/boost/tr1/complex.hpp	/^inline std::complex<double> conj(const double& t)$/;"	f	namespace:std	signature:(const double& t)
conj	/usr/include/boost/tr1/complex.hpp	/^inline std::complex<float> conj(const float& t)$/;"	f	namespace:std	signature:(const float& t)
conj	/usr/include/boost/tr1/complex.hpp	/^inline std::complex<long double> conj(const long double& t)$/;"	f	namespace:std	signature:(const long double& t)
const_pointer_cast	/usr/include/boost/tr1/memory.hpp	/^template<class T, class U> shared_ptr<T> const_pointer_cast(shared_ptr<U> const & r);$/;"	p	namespace:boost	signature:(shared_ptr<U> const & r)
const_tuple_get_result	/usr/include/boost/tr1/utility.hpp	/^   struct const_tuple_get_result$/;"	s	namespace:std::tr1::tuple_detail
dereference	/usr/include/boost/tr1/detail/functor2iterator.hpp	/^   const R& dereference()const$/;"	f	struct:boost::tr1_details::functor2iterator	access:public	signature:() const
detail	/usr/include/boost/tr1/memory.hpp	/^namespace detail{$/;"	n	namespace:boost
dynamic_pointer_cast	/usr/include/boost/tr1/memory.hpp	/^template<class T, class U> shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const & r);$/;"	p	namespace:boost	signature:(shared_ptr<U> const & r)
equal	/usr/include/boost/tr1/detail/functor2iterator.hpp	/^   bool equal(const functor2iterator&)const$/;"	f	struct:boost::tr1_details::functor2iterator	access:public	signature:(const functor2iterator&) const
functor2iterator	/usr/include/boost/tr1/detail/functor2iterator.hpp	/^   functor2iterator() : m_func(0){}$/;"	f	struct:boost::tr1_details::functor2iterator	access:public	signature:()
functor2iterator	/usr/include/boost/tr1/detail/functor2iterator.hpp	/^   functor2iterator(Func& f)$/;"	f	struct:boost::tr1_details::functor2iterator	access:public	signature:(Func& f)
functor2iterator	/usr/include/boost/tr1/detail/functor2iterator.hpp	/^struct functor2iterator : boost::iterator_facade<functor2iterator<Func,R>, const R, std::input_iterator_tag>$/;"	s	namespace:boost::tr1_details	inherits:boost::iterator_facade
fusion	/usr/include/boost/tr1/array.hpp	/^}} namespace boost{ namespace fusion{$/;"	n	namespace:boost
get	/usr/include/boost/tr1/array.hpp	/^const T& get(const array<T, N>& a)$/;"	f	namespace:boost::fusion	signature:(const array<T, N>& a)
get	/usr/include/boost/tr1/array.hpp	/^T& get( ::boost::array<T, N>& a)$/;"	f	namespace:boost::fusion	signature:( ::boost::array<T, N>& a)
get	/usr/include/boost/tr1/utility.hpp	/^inline typename tuple_detail::const_tuple_get_result<I,T1,T2>::type get(const std::pair<T1, T2>& p)$/;"	f	namespace:std::tr1	signature:(const std::pair<T1, T2>& p)
get	/usr/include/boost/tr1/utility.hpp	/^inline typename tuple_detail::const_tuple_get_result<I,T1,T2>::type get(const std::pair<T1, T2>& p, const ::boost::false_type&)$/;"	f	namespace:std::tr1::tuple_detail	signature:(const std::pair<T1, T2>& p, const ::boost::false_type&)
get	/usr/include/boost/tr1/utility.hpp	/^inline typename tuple_detail::const_tuple_get_result<I,T1,T2>::type get(const std::pair<T1, T2>& p, const ::boost::true_type&)$/;"	f	namespace:std::tr1::tuple_detail	signature:(const std::pair<T1, T2>& p, const ::boost::true_type&)
get	/usr/include/boost/tr1/utility.hpp	/^inline typename tuple_detail::tuple_get_result<I,T1,T2>::type get(std::pair<T1, T2>& p)$/;"	f	namespace:std::tr1	signature:(std::pair<T1, T2>& p)
get	/usr/include/boost/tr1/utility.hpp	/^inline typename tuple_detail::tuple_get_result<I,T1,T2>::type get(std::pair<T1, T2>& p, const ::boost::false_type&)$/;"	f	namespace:std::tr1::tuple_detail	signature:(std::pair<T1, T2>& p, const ::boost::false_type&)
get	/usr/include/boost/tr1/utility.hpp	/^inline typename tuple_detail::tuple_get_result<I,T1,T2>::type get(std::pair<T1, T2>& p, const ::boost::true_type&)$/;"	f	namespace:std::tr1::tuple_detail	signature:(std::pair<T1, T2>& p, const ::boost::true_type&)
get_deleter	/usr/include/boost/tr1/memory.hpp	/^template<class D, class T> D * get_deleter(shared_ptr<T> const & p);$/;"	p	namespace:boost	signature:(shared_ptr<T> const & p)
imag	/usr/include/boost/tr1/complex.hpp	/^inline BOOST_TR1_MATH_RETURN(double) imag(const T& )$/;"	f	namespace:std	signature:(const T& )
imag	/usr/include/boost/tr1/complex.hpp	/^inline double imag(const double& )$/;"	f	namespace:std	signature:(const double& )
imag	/usr/include/boost/tr1/complex.hpp	/^inline float imag(const float& )$/;"	f	namespace:std	signature:(const float& )
imag	/usr/include/boost/tr1/complex.hpp	/^inline long double imag(const long double& )$/;"	f	namespace:std	signature:(const long double& )
impl_type	/usr/include/boost/tr1/random.hpp	/^   typedef ::boost::random::linear_congruential<UIntType, a, c, m, 0> impl_type;$/;"	t	class:std::tr1::linear_congruential	access:private
imp_type	/usr/include/boost/tr1/random.hpp	/^      <UIntType, w, n, m, r, a, u, s, b, t, c, l, 0> imp_type;$/;"	t	class:std::tr1::mersenne_twister	access:private
increment	/usr/include/boost/tr1/detail/functor2iterator.hpp	/^   void increment(){ m_val = (*m_func)(); }$/;"	f	struct:boost::tr1_details::functor2iterator	access:public	signature:()
init1	/usr/include/boost/tr1/random.hpp	/^   void init1(Gen& g, const ::boost::false_type&)$/;"	f	class:std::tr1::linear_congruential	access:private	signature:(Gen& g, const ::boost::false_type&)
init1	/usr/include/boost/tr1/random.hpp	/^   void init1(Gen& g, const ::boost::false_type&)$/;"	f	class:std::tr1::mersenne_twister	access:private	signature:(Gen& g, const ::boost::false_type&)
init1	/usr/include/boost/tr1/random.hpp	/^   void init1(Gen& g, const ::boost::false_type&)$/;"	f	class:std::tr1::subtract_with_carry	access:private	signature:(Gen& g, const ::boost::false_type&)
init1	/usr/include/boost/tr1/random.hpp	/^   void init1(Gen& g, const ::boost::false_type&)$/;"	f	class:std::tr1::subtract_with_carry_01	access:private	signature:(Gen& g, const ::boost::false_type&)
init1	/usr/include/boost/tr1/random.hpp	/^   void init1(Gen& g, const ::boost::false_type&)$/;"	f	class:std::tr1::xor_combine	access:private	signature:(Gen& g, const ::boost::false_type&)
init1	/usr/include/boost/tr1/random.hpp	/^   void init1(Gen& g, const ::boost::true_type&)$/;"	f	class:std::tr1::linear_congruential	access:private	signature:(Gen& g, const ::boost::true_type&)
init1	/usr/include/boost/tr1/random.hpp	/^   void init1(Gen& g, const ::boost::true_type&)$/;"	f	class:std::tr1::mersenne_twister	access:private	signature:(Gen& g, const ::boost::true_type&)
init1	/usr/include/boost/tr1/random.hpp	/^   void init1(Gen& g, const ::boost::true_type&)$/;"	f	class:std::tr1::subtract_with_carry	access:private	signature:(Gen& g, const ::boost::true_type&)
init1	/usr/include/boost/tr1/random.hpp	/^   void init1(Gen& g, const ::boost::true_type&)$/;"	f	class:std::tr1::subtract_with_carry_01	access:private	signature:(Gen& g, const ::boost::true_type&)
init1	/usr/include/boost/tr1/random.hpp	/^   void init1(Gen& g, const ::boost::true_type&)$/;"	f	class:std::tr1::xor_combine	access:private	signature:(Gen& g, const ::boost::true_type&)
init2	/usr/include/boost/tr1/random.hpp	/^   void init2(Gen& g, const ::boost::false_type&)$/;"	f	class:std::tr1::linear_congruential	access:private	signature:(Gen& g, const ::boost::false_type&)
init2	/usr/include/boost/tr1/random.hpp	/^   void init2(Gen& g, const ::boost::false_type&)$/;"	f	class:std::tr1::mersenne_twister	access:private	signature:(Gen& g, const ::boost::false_type&)
init2	/usr/include/boost/tr1/random.hpp	/^   void init2(Gen& g, const ::boost::false_type&)$/;"	f	class:std::tr1::subtract_with_carry	access:private	signature:(Gen& g, const ::boost::false_type&)
init2	/usr/include/boost/tr1/random.hpp	/^   void init2(Gen& g, const ::boost::false_type&)$/;"	f	class:std::tr1::subtract_with_carry_01	access:private	signature:(Gen& g, const ::boost::false_type&)
init2	/usr/include/boost/tr1/random.hpp	/^   void init2(Gen& g, const ::boost::false_type&)$/;"	f	class:std::tr1::xor_combine	access:private	signature:(Gen& g, const ::boost::false_type&)
init2	/usr/include/boost/tr1/random.hpp	/^   void init2(Gen& g, const ::boost::true_type&)$/;"	f	class:std::tr1::linear_congruential	access:private	signature:(Gen& g, const ::boost::true_type&)
init2	/usr/include/boost/tr1/random.hpp	/^   void init2(Gen& g, const ::boost::true_type&)$/;"	f	class:std::tr1::mersenne_twister	access:private	signature:(Gen& g, const ::boost::true_type&)
init2	/usr/include/boost/tr1/random.hpp	/^   void init2(Gen& g, const ::boost::true_type&)$/;"	f	class:std::tr1::subtract_with_carry	access:private	signature:(Gen& g, const ::boost::true_type&)
init2	/usr/include/boost/tr1/random.hpp	/^   void init2(Gen& g, const ::boost::true_type&)$/;"	f	class:std::tr1::subtract_with_carry_01	access:private	signature:(Gen& g, const ::boost::true_type&)
init2	/usr/include/boost/tr1/random.hpp	/^   void init2(Gen& g, const ::boost::true_type&)$/;"	f	class:std::tr1::xor_combine	access:private	signature:(Gen& g, const ::boost::true_type&)
init_minmax	/usr/include/boost/tr1/random.hpp	/^   void init_minmax();$/;"	p	class:std::tr1::xor_combine	access:private	signature:()
init_minmax	/usr/include/boost/tr1/random.hpp	/^void xor_combine<UniformRandomNumberGenerator1, s1, UniformRandomNumberGenerator2, s2>::init_minmax()$/;"	f	class:std::tr1::xor_combine	signature:()
largest_real	/usr/include/boost/tr1/detail/math_overloads.hpp	/^struct largest_real$/;"	s	namespace:boost::tr1_detail
linear_congruential	/usr/include/boost/tr1/random.hpp	/^   explicit linear_congruential(unsigned long x0 = 1)$/;"	f	class:std::tr1::linear_congruential	access:public	signature:(unsigned long x0 = 1)
linear_congruential	/usr/include/boost/tr1/random.hpp	/^   linear_congruential(const linear_congruential& that)$/;"	f	class:std::tr1::linear_congruential	access:public	signature:(const linear_congruential& that)
linear_congruential	/usr/include/boost/tr1/random.hpp	/^   template<class Gen> linear_congruential(Gen& g)$/;"	f	class:std::tr1::linear_congruential	access:public	signature:(Gen& g)
linear_congruential	/usr/include/boost/tr1/random.hpp	/^class linear_congruential$/;"	c	namespace:std::tr1
mersenne_twister	/usr/include/boost/tr1/random.hpp	/^   explicit mersenne_twister(unsigned long value)$/;"	f	class:std::tr1::mersenne_twister	access:public	signature:(unsigned long value)
mersenne_twister	/usr/include/boost/tr1/random.hpp	/^   mersenne_twister(){}$/;"	f	class:std::tr1::mersenne_twister	access:public	signature:()
mersenne_twister	/usr/include/boost/tr1/random.hpp	/^   template<class Gen> mersenne_twister(Gen& g)$/;"	f	class:std::tr1::mersenne_twister	access:public	signature:(Gen& g)
mersenne_twister	/usr/include/boost/tr1/random.hpp	/^class mersenne_twister$/;"	c	namespace:std::tr1
minstd_rand	/usr/include/boost/tr1/random.hpp	/^typedef linear_congruential< ::boost::int32_t, 48271, 0, 2147483647> minstd_rand;$/;"	t	namespace:std::tr1
minstd_rand0	/usr/include/boost/tr1/random.hpp	/^typedef linear_congruential< ::boost::int32_t, 16807, 0, 2147483647> minstd_rand0;$/;"	t	namespace:std::tr1
mt19937	/usr/include/boost/tr1/random.hpp	/^typedef mersenne_twister< ::boost::uint32_t, 32,624,397,31,0x9908b0df,11,7,0x9d2c5680,15,0xefc60000,18> mt19937;$/;"	t	namespace:std::tr1
m_b1	/usr/include/boost/tr1/random.hpp	/^   base1_type m_b1;$/;"	m	class:std::tr1::xor_combine	access:private
m_b2	/usr/include/boost/tr1/random.hpp	/^   base2_type m_b2;$/;"	m	class:std::tr1::xor_combine	access:private
m_func	/usr/include/boost/tr1/detail/functor2iterator.hpp	/^   Func* m_func;$/;"	m	struct:boost::tr1_details::functor2iterator	access:private
m_gen	/usr/include/boost/tr1/random.hpp	/^   ::boost::random::subtract_with_carry<IntType, m, s, r, 0> m_gen;$/;"	m	class:std::tr1::subtract_with_carry	access:private
m_gen	/usr/include/boost/tr1/random.hpp	/^   ::boost::random::subtract_with_carry_01<RealType, w, s, r, 0> m_gen;$/;"	m	class:std::tr1::subtract_with_carry_01	access:private
m_gen	/usr/include/boost/tr1/random.hpp	/^   impl_type m_gen;$/;"	m	class:std::tr1::linear_congruential	access:private
m_gen	/usr/include/boost/tr1/random.hpp	/^   imp_type m_gen;$/;"	m	class:std::tr1::mersenne_twister	access:private
m_max	/usr/include/boost/tr1/random.hpp	/^   result_type m_max;$/;"	m	class:std::tr1::xor_combine	access:private
m_min	/usr/include/boost/tr1/random.hpp	/^   result_type m_min;$/;"	m	class:std::tr1::xor_combine	access:private
m_val	/usr/include/boost/tr1/detail/functor2iterator.hpp	/^   R m_val;$/;"	m	struct:boost::tr1_details::functor2iterator	access:private
norm	/usr/include/boost/tr1/complex.hpp	/^inline BOOST_TR1_MATH_RETURN(double) norm(const T& t)$/;"	f	namespace:std	signature:(const T& t)
norm	/usr/include/boost/tr1/complex.hpp	/^inline double norm(const double& t)$/;"	f	namespace:std	signature:(const double& t)
norm	/usr/include/boost/tr1/complex.hpp	/^inline float norm(const float& t)$/;"	f	namespace:std	signature:(const float& t)
norm	/usr/include/boost/tr1/complex.hpp	/^inline long double norm(const long double& t)$/;"	f	namespace:std	signature:(const long double& t)
operator !=	/usr/include/boost/tr1/random.hpp	/^   bool operator != (const xor_combine& that)const$/;"	f	class:std::tr1::xor_combine	access:public	signature:(const xor_combine& that) const
operator !=	/usr/include/boost/tr1/random.hpp	/^   bool operator!=(const linear_congruential& that)const$/;"	f	class:std::tr1::linear_congruential	access:public	signature:(const linear_congruential& that) const
operator !=	/usr/include/boost/tr1/random.hpp	/^   bool operator!=(const mersenne_twister& that)const$/;"	f	class:std::tr1::mersenne_twister	access:public	signature:(const mersenne_twister& that) const
operator !=	/usr/include/boost/tr1/random.hpp	/^   bool operator!=(const subtract_with_carry& that)const$/;"	f	class:std::tr1::subtract_with_carry	access:public	signature:(const subtract_with_carry& that) const
operator !=	/usr/include/boost/tr1/random.hpp	/^   bool operator!=(const subtract_with_carry_01& that)const$/;"	f	class:std::tr1::subtract_with_carry_01	access:public	signature:(const subtract_with_carry_01& that) const
operator ()	/usr/include/boost/tr1/random.hpp	/^   result_type operator()()$/;"	f	class:std::tr1::linear_congruential	access:public	signature:()
operator ()	/usr/include/boost/tr1/random.hpp	/^   result_type operator()()$/;"	f	class:std::tr1::mersenne_twister	access:public	signature:()
operator ()	/usr/include/boost/tr1/random.hpp	/^   result_type operator()()$/;"	f	class:std::tr1::subtract_with_carry	access:public	signature:()
operator ()	/usr/include/boost/tr1/random.hpp	/^   result_type operator()()$/;"	f	class:std::tr1::subtract_with_carry_01	access:public	signature:()
operator ()	/usr/include/boost/tr1/random.hpp	/^   result_type operator()()$/;"	f	class:std::tr1::xor_combine	access:public	signature:()
operator <<	/usr/include/boost/tr1/random.hpp	/^   operator<<(std::basic_ostream<CharT,Traits>& os,$/;"	f	class:std::tr1::mersenne_twister	access:friend	signature:(std::basic_ostream<CharT,Traits>& os, const mersenne_twister& lcg)
operator <<	/usr/include/boost/tr1/random.hpp	/^   operator<<(std::basic_ostream<CharT,Traits>& os,$/;"	f	class:std::tr1::subtract_with_carry	access:friend	signature:(std::basic_ostream<CharT,Traits>& os, const subtract_with_carry& lcg)
operator <<	/usr/include/boost/tr1/random.hpp	/^   operator<<(std::basic_ostream<CharT,Traits>& os,$/;"	f	class:std::tr1::subtract_with_carry_01	access:friend	signature:(std::basic_ostream<CharT,Traits>& os, const subtract_with_carry_01& lcg)
operator <<	/usr/include/boost/tr1/random.hpp	/^   operator<<(std::basic_ostream<CharT,Traits>& os,$/;"	f	class:std::tr1::xor_combine	access:friend	signature:(std::basic_ostream<CharT,Traits>& os, const xor_combine& lcg)
operator <<	/usr/include/boost/tr1/random.hpp	/^  operator<<(std::basic_ostream<CharT,Traits>& os,$/;"	f	class:std::tr1::linear_congruential	access:friend	signature:(std::basic_ostream<CharT,Traits>& os, const linear_congruential& lcg)
operator ==	/usr/include/boost/tr1/random.hpp	/^   bool operator == (const xor_combine& that)const$/;"	f	class:std::tr1::xor_combine	access:public	signature:(const xor_combine& that) const
operator ==	/usr/include/boost/tr1/random.hpp	/^   bool operator==(const linear_congruential& that)const$/;"	f	class:std::tr1::linear_congruential	access:public	signature:(const linear_congruential& that) const
operator ==	/usr/include/boost/tr1/random.hpp	/^   bool operator==(const mersenne_twister& that)const$/;"	f	class:std::tr1::mersenne_twister	access:public	signature:(const mersenne_twister& that) const
operator ==	/usr/include/boost/tr1/random.hpp	/^   bool operator==(const subtract_with_carry& that)const$/;"	f	class:std::tr1::subtract_with_carry	access:public	signature:(const subtract_with_carry& that) const
operator ==	/usr/include/boost/tr1/random.hpp	/^   bool operator==(const subtract_with_carry_01& that)const$/;"	f	class:std::tr1::subtract_with_carry_01	access:public	signature:(const subtract_with_carry_01& that) const
operator >>	/usr/include/boost/tr1/random.hpp	/^   operator>>(std::basic_istream<CharT,Traits>& is,$/;"	f	class:std::tr1::mersenne_twister	access:friend	signature:(std::basic_istream<CharT,Traits>& is, mersenne_twister& lcg)
operator >>	/usr/include/boost/tr1/random.hpp	/^   operator>>(std::basic_istream<CharT,Traits>& is,$/;"	f	class:std::tr1::subtract_with_carry	access:friend	signature:(std::basic_istream<CharT,Traits>& is, subtract_with_carry& lcg)
operator >>	/usr/include/boost/tr1/random.hpp	/^   operator>>(std::basic_istream<CharT,Traits>& is,$/;"	f	class:std::tr1::subtract_with_carry_01	access:friend	signature:(std::basic_istream<CharT,Traits>& is, subtract_with_carry_01& lcg)
operator >>	/usr/include/boost/tr1/random.hpp	/^   operator>>(std::basic_istream<CharT,Traits>& is,$/;"	f	class:std::tr1::xor_combine	access:friend	signature:(std::basic_istream<CharT,Traits>& is, xor_combine& lcg)
operator >>	/usr/include/boost/tr1/random.hpp	/^  operator>>(std::basic_istream<CharT,Traits>& is,$/;"	f	class:std::tr1::linear_congruential	access:friend	signature:(std::basic_istream<CharT,Traits>& is, linear_congruential& lcg)
placeholders	/usr/include/boost/tr1/functional.hpp	/^   namespace placeholders {$/;"	n	namespace:std::tr1
polar	/usr/include/boost/tr1/complex.hpp	/^   polar(const T& rho, const U& theta)$/;"	f	namespace:std	signature:(const T& rho, const U& theta)
polar	/usr/include/boost/tr1/complex.hpp	/^inline complex<double> polar(const char& rho, const char& theta = 0)$/;"	f	namespace:std	signature:(const char& rho, const char& theta = 0)
polar	/usr/include/boost/tr1/complex.hpp	/^inline complex<double> polar(const int& rho, const int& theta = 0)$/;"	f	namespace:std	signature:(const int& rho, const int& theta = 0)
polar	/usr/include/boost/tr1/complex.hpp	/^inline complex<double> polar(const long long& rho, const long long& theta = 0)$/;"	f	namespace:std	signature:(const long long& rho, const long long& theta = 0)
polar	/usr/include/boost/tr1/complex.hpp	/^inline complex<double> polar(const long& rho, const long& theta = 0)$/;"	f	namespace:std	signature:(const long& rho, const long& theta = 0)
polar	/usr/include/boost/tr1/complex.hpp	/^inline complex<double> polar(const short& rho, const short& theta = 0)$/;"	f	namespace:std	signature:(const short& rho, const short& theta = 0)
polar	/usr/include/boost/tr1/complex.hpp	/^inline complex<double> polar(const signed char& rho, const signed char& theta = 0)$/;"	f	namespace:std	signature:(const signed char& rho, const signed char& theta = 0)
polar	/usr/include/boost/tr1/complex.hpp	/^inline complex<double> polar(const unsigned char& rho, const unsigned char& theta = 0)$/;"	f	namespace:std	signature:(const unsigned char& rho, const unsigned char& theta = 0)
polar	/usr/include/boost/tr1/complex.hpp	/^inline complex<double> polar(const unsigned int& rho, const unsigned int& theta = 0)$/;"	f	namespace:std	signature:(const unsigned int& rho, const unsigned int& theta = 0)
polar	/usr/include/boost/tr1/complex.hpp	/^inline complex<double> polar(const unsigned long long& rho, const unsigned long long& theta = 0)$/;"	f	namespace:std	signature:(const unsigned long long& rho, const unsigned long long& theta = 0)
polar	/usr/include/boost/tr1/complex.hpp	/^inline complex<double> polar(const unsigned long& rho, const unsigned long& theta = 0)$/;"	f	namespace:std	signature:(const unsigned long& rho, const unsigned long& theta = 0)
polar	/usr/include/boost/tr1/complex.hpp	/^inline complex<double> polar(const unsigned short& rho, const unsigned short& theta = 0)$/;"	f	namespace:std	signature:(const unsigned short& rho, const unsigned short& theta = 0)
polar	/usr/include/boost/tr1/complex.hpp	/^inline complex<double> polar(const unsigned __int64& rho, const unsigned __int64& theta = 0)$/;"	f	namespace:std	signature:(const unsigned __int64& rho, const unsigned __int64& theta = 0)
polar	/usr/include/boost/tr1/complex.hpp	/^inline complex<double> polar(const __int64& rho, const __int64& theta = 0)$/;"	f	namespace:std	signature:(const __int64& rho, const __int64& theta = 0)
pow	/usr/include/boost/tr1/complex.hpp	/^   pow (const complex<T>& x, const U& y)$/;"	f	namespace:std	signature:(const complex<T>& x, const U& y)
pow	/usr/include/boost/tr1/complex.hpp	/^   pow (const T& x, const complex<U>& y)$/;"	f	namespace:std	signature:(const T& x, const complex<U>& y)
pow	/usr/include/boost/tr1/complex.hpp	/^   pow(const complex<T>& x, const complex<U>& y)$/;"	f	namespace:std	signature:(const complex<T>& x, const complex<U>& y)
promote_to_real	/usr/include/boost/tr1/detail/math_overloads.hpp	/^struct promote_to_real$/;"	s	namespace:boost::tr1_detail
ranlux64_base_01	/usr/include/boost/tr1/random.hpp	/^typedef subtract_with_carry_01<double, 48, 10, 24> ranlux64_base_01;$/;"	t	namespace:std::tr1
ranlux_base_01	/usr/include/boost/tr1/random.hpp	/^typedef subtract_with_carry_01<float, 24, 10, 24> ranlux_base_01;$/;"	t	namespace:std::tr1
real	/usr/include/boost/tr1/complex.hpp	/^inline BOOST_TR1_MATH_RETURN(double) real(const T& t)$/;"	f	namespace:std	signature:(const T& t)
real	/usr/include/boost/tr1/complex.hpp	/^inline double real(const double& t)$/;"	f	namespace:std	signature:(const double& t)
real	/usr/include/boost/tr1/complex.hpp	/^inline float real(const float& t)$/;"	f	namespace:std	signature:(const float& t)
real	/usr/include/boost/tr1/complex.hpp	/^inline long double real(const long double& t)$/;"	f	namespace:std	signature:(const long double& t)
regex_constants	/usr/include/boost/tr1/regex.hpp	/^namespace regex_constants {$/;"	n	namespace:std::tr1
result_type	/usr/include/boost/tr1/random.hpp	/^   typedef IntType result_type;$/;"	t	class:std::tr1::subtract_with_carry	access:public
result_type	/usr/include/boost/tr1/random.hpp	/^   typedef RealType result_type;$/;"	t	class:std::tr1::subtract_with_carry_01	access:public
result_type	/usr/include/boost/tr1/random.hpp	/^   typedef UIntType result_type;$/;"	t	class:std::tr1::linear_congruential	access:public
result_type	/usr/include/boost/tr1/random.hpp	/^   typedef UIntType result_type;$/;"	t	class:std::tr1::mersenne_twister	access:public
result_type	/usr/include/boost/tr1/random.hpp	/^   typedef unsigned long result_type;$/;"	t	class:std::tr1::xor_combine	access:public
seed	/usr/include/boost/tr1/random.hpp	/^   template<class Gen> void seed(Gen& g)$/;"	f	class:std::tr1::linear_congruential	access:public	signature:(Gen& g)
seed	/usr/include/boost/tr1/random.hpp	/^   template<class Gen> void seed(Gen& g)$/;"	f	class:std::tr1::mersenne_twister	access:public	signature:(Gen& g)
seed	/usr/include/boost/tr1/random.hpp	/^   template<class Gen> void seed(Gen& g)$/;"	f	class:std::tr1::subtract_with_carry	access:public	signature:(Gen& g)
seed	/usr/include/boost/tr1/random.hpp	/^   template<class Gen> void seed(Gen& g)$/;"	f	class:std::tr1::subtract_with_carry_01	access:public	signature:(Gen& g)
seed	/usr/include/boost/tr1/random.hpp	/^   template<class Gen> void seed(Gen& g)$/;"	f	class:std::tr1::xor_combine	access:public	signature:(Gen& g)
seed	/usr/include/boost/tr1/random.hpp	/^   void seed()$/;"	f	class:std::tr1::mersenne_twister	access:public	signature:()
seed	/usr/include/boost/tr1/random.hpp	/^   void seed()$/;"	f	class:std::tr1::xor_combine	access:public	signature:()
seed	/usr/include/boost/tr1/random.hpp	/^   void seed(unsigned long s)$/;"	f	class:std::tr1::xor_combine	access:public	signature:(unsigned long s)
seed	/usr/include/boost/tr1/random.hpp	/^   void seed(unsigned long value = 19780503ul)$/;"	f	class:std::tr1::subtract_with_carry	access:public	signature:(unsigned long value = 19780503ul)
seed	/usr/include/boost/tr1/random.hpp	/^   void seed(unsigned long value = 19780503UL)$/;"	f	class:std::tr1::subtract_with_carry_01	access:public	signature:(unsigned long value = 19780503UL)
seed	/usr/include/boost/tr1/random.hpp	/^   void seed(unsigned long value)$/;"	f	class:std::tr1::mersenne_twister	access:public	signature:(unsigned long value)
seed	/usr/include/boost/tr1/random.hpp	/^   void seed(unsigned long x0 = 1)$/;"	f	class:std::tr1::linear_congruential	access:public	signature:(unsigned long x0 = 1)
static_pointer_cast	/usr/include/boost/tr1/memory.hpp	/^template<class T, class U> shared_ptr<T> static_pointer_cast(shared_ptr<U> const & r);$/;"	p	namespace:boost	signature:(shared_ptr<U> const & r)
std	/usr/include/boost/tr1/array.hpp	/^namespace std{ namespace tr1{$/;"	n
std	/usr/include/boost/tr1/array.hpp	/^}} namespace std{ namespace tr1{$/;"	n
std	/usr/include/boost/tr1/cmath.hpp	/^namespace std{ namespace tr1{$/;"	n
std	/usr/include/boost/tr1/complex.hpp	/^namespace std {$/;"	n
std	/usr/include/boost/tr1/complex.hpp	/^namespace std{ $/;"	n
std	/usr/include/boost/tr1/functional.hpp	/^namespace std{ namespace tr1{$/;"	n
std	/usr/include/boost/tr1/memory.hpp	/^namespace std{ namespace tr1{$/;"	n
std	/usr/include/boost/tr1/random.hpp	/^namespace std { namespace tr1{$/;"	n
std	/usr/include/boost/tr1/regex.hpp	/^namespace std{ namespace tr1{$/;"	n
std	/usr/include/boost/tr1/tuple.hpp	/^namespace std{ namespace tr1{$/;"	n
std	/usr/include/boost/tr1/type_traits.hpp	/^namespace std { namespace tr1{$/;"	n
std	/usr/include/boost/tr1/unordered_map.hpp	/^namespace std{ namespace tr1{$/;"	n
std	/usr/include/boost/tr1/unordered_set.hpp	/^namespace std{ namespace tr1{$/;"	n
std	/usr/include/boost/tr1/utility.hpp	/^namespace std{ namespace tr1{$/;"	n
std::arg	/usr/include/boost/tr1/complex.hpp	/^inline BOOST_TR1_MATH_RETURN(double) arg(const T& t)$/;"	f	namespace:std	signature:(const T& t)
std::arg	/usr/include/boost/tr1/complex.hpp	/^inline float arg(const float& t)$/;"	f	namespace:std	signature:(const float& t)
std::arg	/usr/include/boost/tr1/complex.hpp	/^inline long double arg(const long double& t)$/;"	f	namespace:std	signature:(const long double& t)
std::conj	/usr/include/boost/tr1/complex.hpp	/^inline BOOST_TR1_MATH_RETURN(std::complex<double>) conj(const T& t)$/;"	f	namespace:std	signature:(const T& t)
std::conj	/usr/include/boost/tr1/complex.hpp	/^inline std::complex<double> conj(const double& t)$/;"	f	namespace:std	signature:(const double& t)
std::conj	/usr/include/boost/tr1/complex.hpp	/^inline std::complex<float> conj(const float& t)$/;"	f	namespace:std	signature:(const float& t)
std::conj	/usr/include/boost/tr1/complex.hpp	/^inline std::complex<long double> conj(const long double& t)$/;"	f	namespace:std	signature:(const long double& t)
std::imag	/usr/include/boost/tr1/complex.hpp	/^inline BOOST_TR1_MATH_RETURN(double) imag(const T& )$/;"	f	namespace:std	signature:(const T& )
std::imag	/usr/include/boost/tr1/complex.hpp	/^inline double imag(const double& )$/;"	f	namespace:std	signature:(const double& )
std::imag	/usr/include/boost/tr1/complex.hpp	/^inline float imag(const float& )$/;"	f	namespace:std	signature:(const float& )
std::imag	/usr/include/boost/tr1/complex.hpp	/^inline long double imag(const long double& )$/;"	f	namespace:std	signature:(const long double& )
std::norm	/usr/include/boost/tr1/complex.hpp	/^inline BOOST_TR1_MATH_RETURN(double) norm(const T& t)$/;"	f	namespace:std	signature:(const T& t)
std::norm	/usr/include/boost/tr1/complex.hpp	/^inline double norm(const double& t)$/;"	f	namespace:std	signature:(const double& t)
std::norm	/usr/include/boost/tr1/complex.hpp	/^inline float norm(const float& t)$/;"	f	namespace:std	signature:(const float& t)
std::norm	/usr/include/boost/tr1/complex.hpp	/^inline long double norm(const long double& t)$/;"	f	namespace:std	signature:(const long double& t)
std::polar	/usr/include/boost/tr1/complex.hpp	/^   polar(const T& rho, const U& theta)$/;"	f	namespace:std	signature:(const T& rho, const U& theta)
std::polar	/usr/include/boost/tr1/complex.hpp	/^inline complex<double> polar(const char& rho, const char& theta = 0)$/;"	f	namespace:std	signature:(const char& rho, const char& theta = 0)
std::polar	/usr/include/boost/tr1/complex.hpp	/^inline complex<double> polar(const int& rho, const int& theta = 0)$/;"	f	namespace:std	signature:(const int& rho, const int& theta = 0)
std::polar	/usr/include/boost/tr1/complex.hpp	/^inline complex<double> polar(const long long& rho, const long long& theta = 0)$/;"	f	namespace:std	signature:(const long long& rho, const long long& theta = 0)
std::polar	/usr/include/boost/tr1/complex.hpp	/^inline complex<double> polar(const long& rho, const long& theta = 0)$/;"	f	namespace:std	signature:(const long& rho, const long& theta = 0)
std::polar	/usr/include/boost/tr1/complex.hpp	/^inline complex<double> polar(const short& rho, const short& theta = 0)$/;"	f	namespace:std	signature:(const short& rho, const short& theta = 0)
std::polar	/usr/include/boost/tr1/complex.hpp	/^inline complex<double> polar(const signed char& rho, const signed char& theta = 0)$/;"	f	namespace:std	signature:(const signed char& rho, const signed char& theta = 0)
std::polar	/usr/include/boost/tr1/complex.hpp	/^inline complex<double> polar(const unsigned char& rho, const unsigned char& theta = 0)$/;"	f	namespace:std	signature:(const unsigned char& rho, const unsigned char& theta = 0)
std::polar	/usr/include/boost/tr1/complex.hpp	/^inline complex<double> polar(const unsigned int& rho, const unsigned int& theta = 0)$/;"	f	namespace:std	signature:(const unsigned int& rho, const unsigned int& theta = 0)
std::polar	/usr/include/boost/tr1/complex.hpp	/^inline complex<double> polar(const unsigned long long& rho, const unsigned long long& theta = 0)$/;"	f	namespace:std	signature:(const unsigned long long& rho, const unsigned long long& theta = 0)
std::polar	/usr/include/boost/tr1/complex.hpp	/^inline complex<double> polar(const unsigned long& rho, const unsigned long& theta = 0)$/;"	f	namespace:std	signature:(const unsigned long& rho, const unsigned long& theta = 0)
std::polar	/usr/include/boost/tr1/complex.hpp	/^inline complex<double> polar(const unsigned short& rho, const unsigned short& theta = 0)$/;"	f	namespace:std	signature:(const unsigned short& rho, const unsigned short& theta = 0)
std::polar	/usr/include/boost/tr1/complex.hpp	/^inline complex<double> polar(const unsigned __int64& rho, const unsigned __int64& theta = 0)$/;"	f	namespace:std	signature:(const unsigned __int64& rho, const unsigned __int64& theta = 0)
std::polar	/usr/include/boost/tr1/complex.hpp	/^inline complex<double> polar(const __int64& rho, const __int64& theta = 0)$/;"	f	namespace:std	signature:(const __int64& rho, const __int64& theta = 0)
std::pow	/usr/include/boost/tr1/complex.hpp	/^   pow (const complex<T>& x, const U& y)$/;"	f	namespace:std	signature:(const complex<T>& x, const U& y)
std::pow	/usr/include/boost/tr1/complex.hpp	/^   pow (const T& x, const complex<U>& y)$/;"	f	namespace:std	signature:(const T& x, const complex<U>& y)
std::pow	/usr/include/boost/tr1/complex.hpp	/^   pow(const complex<T>& x, const complex<U>& y)$/;"	f	namespace:std	signature:(const complex<T>& x, const complex<U>& y)
std::real	/usr/include/boost/tr1/complex.hpp	/^inline BOOST_TR1_MATH_RETURN(double) real(const T& t)$/;"	f	namespace:std	signature:(const T& t)
std::real	/usr/include/boost/tr1/complex.hpp	/^inline double real(const double& t)$/;"	f	namespace:std	signature:(const double& t)
std::real	/usr/include/boost/tr1/complex.hpp	/^inline float real(const float& t)$/;"	f	namespace:std	signature:(const float& t)
std::real	/usr/include/boost/tr1/complex.hpp	/^inline long double real(const long double& t)$/;"	f	namespace:std	signature:(const long double& t)
std::tr1	/usr/include/boost/tr1/array.hpp	/^namespace std{ namespace tr1{$/;"	n	namespace:std
std::tr1	/usr/include/boost/tr1/array.hpp	/^}} namespace std{ namespace tr1{$/;"	n	namespace:std
std::tr1	/usr/include/boost/tr1/cmath.hpp	/^namespace std{ namespace tr1{$/;"	n	namespace:std
std::tr1	/usr/include/boost/tr1/complex.hpp	/^namespace tr1 {$/;"	n	namespace:std
std::tr1	/usr/include/boost/tr1/functional.hpp	/^namespace std{ namespace tr1{$/;"	n	namespace:std
std::tr1	/usr/include/boost/tr1/memory.hpp	/^namespace std{ namespace tr1{$/;"	n	namespace:std
std::tr1	/usr/include/boost/tr1/random.hpp	/^namespace std { namespace tr1{$/;"	n	namespace:std
std::tr1	/usr/include/boost/tr1/regex.hpp	/^namespace std{ namespace tr1{$/;"	n	namespace:std
std::tr1	/usr/include/boost/tr1/tuple.hpp	/^namespace std{ namespace tr1{$/;"	n	namespace:std
std::tr1	/usr/include/boost/tr1/type_traits.hpp	/^namespace std { namespace tr1{$/;"	n	namespace:std
std::tr1	/usr/include/boost/tr1/unordered_map.hpp	/^namespace std{ namespace tr1{$/;"	n	namespace:std
std::tr1	/usr/include/boost/tr1/unordered_set.hpp	/^namespace std{ namespace tr1{$/;"	n	namespace:std
std::tr1	/usr/include/boost/tr1/utility.hpp	/^namespace std{ namespace tr1{$/;"	n	namespace:std
std::tr1::get	/usr/include/boost/tr1/utility.hpp	/^inline typename tuple_detail::const_tuple_get_result<I,T1,T2>::type get(const std::pair<T1, T2>& p)$/;"	f	namespace:std::tr1	signature:(const std::pair<T1, T2>& p)
std::tr1::get	/usr/include/boost/tr1/utility.hpp	/^inline typename tuple_detail::tuple_get_result<I,T1,T2>::type get(std::pair<T1, T2>& p)$/;"	f	namespace:std::tr1	signature:(std::pair<T1, T2>& p)
std::tr1::linear_congruential	/usr/include/boost/tr1/random.hpp	/^class linear_congruential$/;"	c	namespace:std::tr1
std::tr1::linear_congruential::BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/tr1/random.hpp	/^   result_type max BOOST_PREVENT_MACRO_SUBSTITUTION() const$/;"	f	class:std::tr1::linear_congruential	access:public	signature:() const
std::tr1::linear_congruential::BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/tr1/random.hpp	/^   result_type min BOOST_PREVENT_MACRO_SUBSTITUTION() const$/;"	f	class:std::tr1::linear_congruential	access:public	signature:() const
std::tr1::linear_congruential::BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(UIntType, increment = c);$/;"	p	class:std::tr1::linear_congruential	access:public	signature:(UIntType, increment = c)
std::tr1::linear_congruential::BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(UIntType, modulus = m);$/;"	p	class:std::tr1::linear_congruential	access:public	signature:(UIntType, modulus = m)
std::tr1::linear_congruential::BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(UIntType, multiplier = a);$/;"	p	class:std::tr1::linear_congruential	access:public	signature:(UIntType, multiplier = a)
std::tr1::linear_congruential::impl_type	/usr/include/boost/tr1/random.hpp	/^   typedef ::boost::random::linear_congruential<UIntType, a, c, m, 0> impl_type;$/;"	t	class:std::tr1::linear_congruential	access:private
std::tr1::linear_congruential::init1	/usr/include/boost/tr1/random.hpp	/^   void init1(Gen& g, const ::boost::false_type&)$/;"	f	class:std::tr1::linear_congruential	access:private	signature:(Gen& g, const ::boost::false_type&)
std::tr1::linear_congruential::init1	/usr/include/boost/tr1/random.hpp	/^   void init1(Gen& g, const ::boost::true_type&)$/;"	f	class:std::tr1::linear_congruential	access:private	signature:(Gen& g, const ::boost::true_type&)
std::tr1::linear_congruential::init2	/usr/include/boost/tr1/random.hpp	/^   void init2(Gen& g, const ::boost::false_type&)$/;"	f	class:std::tr1::linear_congruential	access:private	signature:(Gen& g, const ::boost::false_type&)
std::tr1::linear_congruential::init2	/usr/include/boost/tr1/random.hpp	/^   void init2(Gen& g, const ::boost::true_type&)$/;"	f	class:std::tr1::linear_congruential	access:private	signature:(Gen& g, const ::boost::true_type&)
std::tr1::linear_congruential::linear_congruential	/usr/include/boost/tr1/random.hpp	/^   explicit linear_congruential(unsigned long x0 = 1)$/;"	f	class:std::tr1::linear_congruential	access:public	signature:(unsigned long x0 = 1)
std::tr1::linear_congruential::linear_congruential	/usr/include/boost/tr1/random.hpp	/^   linear_congruential(const linear_congruential& that)$/;"	f	class:std::tr1::linear_congruential	access:public	signature:(const linear_congruential& that)
std::tr1::linear_congruential::linear_congruential	/usr/include/boost/tr1/random.hpp	/^   template<class Gen> linear_congruential(Gen& g)$/;"	f	class:std::tr1::linear_congruential	access:public	signature:(Gen& g)
std::tr1::linear_congruential::m_gen	/usr/include/boost/tr1/random.hpp	/^   impl_type m_gen;$/;"	m	class:std::tr1::linear_congruential	access:private
std::tr1::linear_congruential::operator !=	/usr/include/boost/tr1/random.hpp	/^   bool operator!=(const linear_congruential& that)const$/;"	f	class:std::tr1::linear_congruential	access:public	signature:(const linear_congruential& that) const
std::tr1::linear_congruential::operator ()	/usr/include/boost/tr1/random.hpp	/^   result_type operator()()$/;"	f	class:std::tr1::linear_congruential	access:public	signature:()
std::tr1::linear_congruential::operator <<	/usr/include/boost/tr1/random.hpp	/^  operator<<(std::basic_ostream<CharT,Traits>& os,$/;"	f	class:std::tr1::linear_congruential	access:friend	signature:(std::basic_ostream<CharT,Traits>& os, const linear_congruential& lcg)
std::tr1::linear_congruential::operator ==	/usr/include/boost/tr1/random.hpp	/^   bool operator==(const linear_congruential& that)const$/;"	f	class:std::tr1::linear_congruential	access:public	signature:(const linear_congruential& that) const
std::tr1::linear_congruential::operator >>	/usr/include/boost/tr1/random.hpp	/^  operator>>(std::basic_istream<CharT,Traits>& is,$/;"	f	class:std::tr1::linear_congruential	access:friend	signature:(std::basic_istream<CharT,Traits>& is, linear_congruential& lcg)
std::tr1::linear_congruential::result_type	/usr/include/boost/tr1/random.hpp	/^   typedef UIntType result_type;$/;"	t	class:std::tr1::linear_congruential	access:public
std::tr1::linear_congruential::seed	/usr/include/boost/tr1/random.hpp	/^   template<class Gen> void seed(Gen& g)$/;"	f	class:std::tr1::linear_congruential	access:public	signature:(Gen& g)
std::tr1::linear_congruential::seed	/usr/include/boost/tr1/random.hpp	/^   void seed(unsigned long x0 = 1)$/;"	f	class:std::tr1::linear_congruential	access:public	signature:(unsigned long x0 = 1)
std::tr1::mersenne_twister	/usr/include/boost/tr1/random.hpp	/^class mersenne_twister$/;"	c	namespace:std::tr1
std::tr1::mersenne_twister::BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/tr1/random.hpp	/^   result_type max BOOST_PREVENT_MACRO_SUBSTITUTION() const$/;"	f	class:std::tr1::mersenne_twister	access:public	signature:() const
std::tr1::mersenne_twister::BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/tr1/random.hpp	/^   result_type min BOOST_PREVENT_MACRO_SUBSTITUTION() const$/;"	f	class:std::tr1::mersenne_twister	access:public	signature:() const
std::tr1::mersenne_twister::BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(int, mask_bits = r);$/;"	p	class:std::tr1::mersenne_twister	access:public	signature:(int, mask_bits = r)
std::tr1::mersenne_twister::BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(int, output_l = l);$/;"	p	class:std::tr1::mersenne_twister	access:public	signature:(int, output_l = l)
std::tr1::mersenne_twister::BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(int, output_s = s);$/;"	p	class:std::tr1::mersenne_twister	access:public	signature:(int, output_s = s)
std::tr1::mersenne_twister::BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(int, output_t = t);$/;"	p	class:std::tr1::mersenne_twister	access:public	signature:(int, output_t = t)
std::tr1::mersenne_twister::BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(int, output_u = u);$/;"	p	class:std::tr1::mersenne_twister	access:public	signature:(int, output_u = u)
std::tr1::mersenne_twister::BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(int, shift_size = m);$/;"	p	class:std::tr1::mersenne_twister	access:public	signature:(int, shift_size = m)
std::tr1::mersenne_twister::BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(int, state_size = n);$/;"	p	class:std::tr1::mersenne_twister	access:public	signature:(int, state_size = n)
std::tr1::mersenne_twister::BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(int, word_size = w);$/;"	p	class:std::tr1::mersenne_twister	access:public	signature:(int, word_size = w)
std::tr1::mersenne_twister::BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(UIntType, output_b = b);$/;"	p	class:std::tr1::mersenne_twister	access:public	signature:(UIntType, output_b = b)
std::tr1::mersenne_twister::BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(UIntType, output_c = c);$/;"	p	class:std::tr1::mersenne_twister	access:public	signature:(UIntType, output_c = c)
std::tr1::mersenne_twister::BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(UIntType, parameter_a = a);$/;"	p	class:std::tr1::mersenne_twister	access:public	signature:(UIntType, parameter_a = a)
std::tr1::mersenne_twister::imp_type	/usr/include/boost/tr1/random.hpp	/^      <UIntType, w, n, m, r, a, u, s, b, t, c, l, 0> imp_type;$/;"	t	class:std::tr1::mersenne_twister	access:private
std::tr1::mersenne_twister::init1	/usr/include/boost/tr1/random.hpp	/^   void init1(Gen& g, const ::boost::false_type&)$/;"	f	class:std::tr1::mersenne_twister	access:private	signature:(Gen& g, const ::boost::false_type&)
std::tr1::mersenne_twister::init1	/usr/include/boost/tr1/random.hpp	/^   void init1(Gen& g, const ::boost::true_type&)$/;"	f	class:std::tr1::mersenne_twister	access:private	signature:(Gen& g, const ::boost::true_type&)
std::tr1::mersenne_twister::init2	/usr/include/boost/tr1/random.hpp	/^   void init2(Gen& g, const ::boost::false_type&)$/;"	f	class:std::tr1::mersenne_twister	access:private	signature:(Gen& g, const ::boost::false_type&)
std::tr1::mersenne_twister::init2	/usr/include/boost/tr1/random.hpp	/^   void init2(Gen& g, const ::boost::true_type&)$/;"	f	class:std::tr1::mersenne_twister	access:private	signature:(Gen& g, const ::boost::true_type&)
std::tr1::mersenne_twister::mersenne_twister	/usr/include/boost/tr1/random.hpp	/^   explicit mersenne_twister(unsigned long value)$/;"	f	class:std::tr1::mersenne_twister	access:public	signature:(unsigned long value)
std::tr1::mersenne_twister::mersenne_twister	/usr/include/boost/tr1/random.hpp	/^   mersenne_twister(){}$/;"	f	class:std::tr1::mersenne_twister	access:public	signature:()
std::tr1::mersenne_twister::mersenne_twister	/usr/include/boost/tr1/random.hpp	/^   template<class Gen> mersenne_twister(Gen& g)$/;"	f	class:std::tr1::mersenne_twister	access:public	signature:(Gen& g)
std::tr1::mersenne_twister::m_gen	/usr/include/boost/tr1/random.hpp	/^   imp_type m_gen;$/;"	m	class:std::tr1::mersenne_twister	access:private
std::tr1::mersenne_twister::operator !=	/usr/include/boost/tr1/random.hpp	/^   bool operator!=(const mersenne_twister& that)const$/;"	f	class:std::tr1::mersenne_twister	access:public	signature:(const mersenne_twister& that) const
std::tr1::mersenne_twister::operator ()	/usr/include/boost/tr1/random.hpp	/^   result_type operator()()$/;"	f	class:std::tr1::mersenne_twister	access:public	signature:()
std::tr1::mersenne_twister::operator <<	/usr/include/boost/tr1/random.hpp	/^   operator<<(std::basic_ostream<CharT,Traits>& os,$/;"	f	class:std::tr1::mersenne_twister	access:friend	signature:(std::basic_ostream<CharT,Traits>& os, const mersenne_twister& lcg)
std::tr1::mersenne_twister::operator ==	/usr/include/boost/tr1/random.hpp	/^   bool operator==(const mersenne_twister& that)const$/;"	f	class:std::tr1::mersenne_twister	access:public	signature:(const mersenne_twister& that) const
std::tr1::mersenne_twister::operator >>	/usr/include/boost/tr1/random.hpp	/^   operator>>(std::basic_istream<CharT,Traits>& is,$/;"	f	class:std::tr1::mersenne_twister	access:friend	signature:(std::basic_istream<CharT,Traits>& is, mersenne_twister& lcg)
std::tr1::mersenne_twister::result_type	/usr/include/boost/tr1/random.hpp	/^   typedef UIntType result_type;$/;"	t	class:std::tr1::mersenne_twister	access:public
std::tr1::mersenne_twister::seed	/usr/include/boost/tr1/random.hpp	/^   template<class Gen> void seed(Gen& g)$/;"	f	class:std::tr1::mersenne_twister	access:public	signature:(Gen& g)
std::tr1::mersenne_twister::seed	/usr/include/boost/tr1/random.hpp	/^   void seed()$/;"	f	class:std::tr1::mersenne_twister	access:public	signature:()
std::tr1::mersenne_twister::seed	/usr/include/boost/tr1/random.hpp	/^   void seed(unsigned long value)$/;"	f	class:std::tr1::mersenne_twister	access:public	signature:(unsigned long value)
std::tr1::minstd_rand	/usr/include/boost/tr1/random.hpp	/^typedef linear_congruential< ::boost::int32_t, 48271, 0, 2147483647> minstd_rand;$/;"	t	namespace:std::tr1
std::tr1::minstd_rand0	/usr/include/boost/tr1/random.hpp	/^typedef linear_congruential< ::boost::int32_t, 16807, 0, 2147483647> minstd_rand0;$/;"	t	namespace:std::tr1
std::tr1::mt19937	/usr/include/boost/tr1/random.hpp	/^typedef mersenne_twister< ::boost::uint32_t, 32,624,397,31,0x9908b0df,11,7,0x9d2c5680,15,0xefc60000,18> mt19937;$/;"	t	namespace:std::tr1
std::tr1::placeholders	/usr/include/boost/tr1/functional.hpp	/^   namespace placeholders {$/;"	n	namespace:std::tr1
std::tr1::ranlux64_base_01	/usr/include/boost/tr1/random.hpp	/^typedef subtract_with_carry_01<double, 48, 10, 24> ranlux64_base_01;$/;"	t	namespace:std::tr1
std::tr1::ranlux_base_01	/usr/include/boost/tr1/random.hpp	/^typedef subtract_with_carry_01<float, 24, 10, 24> ranlux_base_01;$/;"	t	namespace:std::tr1
std::tr1::regex_constants	/usr/include/boost/tr1/regex.hpp	/^namespace regex_constants {$/;"	n	namespace:std::tr1
std::tr1::subtract_with_carry	/usr/include/boost/tr1/random.hpp	/^class subtract_with_carry$/;"	c	namespace:std::tr1
std::tr1::subtract_with_carry::BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/tr1/random.hpp	/^   result_type max BOOST_PREVENT_MACRO_SUBSTITUTION() const$/;"	f	class:std::tr1::subtract_with_carry	access:public	signature:() const
std::tr1::subtract_with_carry::BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/tr1/random.hpp	/^   result_type min BOOST_PREVENT_MACRO_SUBSTITUTION() const$/;"	f	class:std::tr1::subtract_with_carry	access:public	signature:() const
std::tr1::subtract_with_carry::BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(int, long_lag = r);$/;"	p	class:std::tr1::subtract_with_carry	access:public	signature:(int, long_lag = r)
std::tr1::subtract_with_carry::BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(int, short_lag = s);$/;"	p	class:std::tr1::subtract_with_carry	access:public	signature:(int, short_lag = s)
std::tr1::subtract_with_carry::BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(IntType, modulus = m);$/;"	p	class:std::tr1::subtract_with_carry	access:public	signature:(IntType, modulus = m)
std::tr1::subtract_with_carry::init1	/usr/include/boost/tr1/random.hpp	/^   void init1(Gen& g, const ::boost::false_type&)$/;"	f	class:std::tr1::subtract_with_carry	access:private	signature:(Gen& g, const ::boost::false_type&)
std::tr1::subtract_with_carry::init1	/usr/include/boost/tr1/random.hpp	/^   void init1(Gen& g, const ::boost::true_type&)$/;"	f	class:std::tr1::subtract_with_carry	access:private	signature:(Gen& g, const ::boost::true_type&)
std::tr1::subtract_with_carry::init2	/usr/include/boost/tr1/random.hpp	/^   void init2(Gen& g, const ::boost::false_type&)$/;"	f	class:std::tr1::subtract_with_carry	access:private	signature:(Gen& g, const ::boost::false_type&)
std::tr1::subtract_with_carry::init2	/usr/include/boost/tr1/random.hpp	/^   void init2(Gen& g, const ::boost::true_type&)$/;"	f	class:std::tr1::subtract_with_carry	access:private	signature:(Gen& g, const ::boost::true_type&)
std::tr1::subtract_with_carry::m_gen	/usr/include/boost/tr1/random.hpp	/^   ::boost::random::subtract_with_carry<IntType, m, s, r, 0> m_gen;$/;"	m	class:std::tr1::subtract_with_carry	access:private
std::tr1::subtract_with_carry::operator !=	/usr/include/boost/tr1/random.hpp	/^   bool operator!=(const subtract_with_carry& that)const$/;"	f	class:std::tr1::subtract_with_carry	access:public	signature:(const subtract_with_carry& that) const
std::tr1::subtract_with_carry::operator ()	/usr/include/boost/tr1/random.hpp	/^   result_type operator()()$/;"	f	class:std::tr1::subtract_with_carry	access:public	signature:()
std::tr1::subtract_with_carry::operator <<	/usr/include/boost/tr1/random.hpp	/^   operator<<(std::basic_ostream<CharT,Traits>& os,$/;"	f	class:std::tr1::subtract_with_carry	access:friend	signature:(std::basic_ostream<CharT,Traits>& os, const subtract_with_carry& lcg)
std::tr1::subtract_with_carry::operator ==	/usr/include/boost/tr1/random.hpp	/^   bool operator==(const subtract_with_carry& that)const$/;"	f	class:std::tr1::subtract_with_carry	access:public	signature:(const subtract_with_carry& that) const
std::tr1::subtract_with_carry::operator >>	/usr/include/boost/tr1/random.hpp	/^   operator>>(std::basic_istream<CharT,Traits>& is,$/;"	f	class:std::tr1::subtract_with_carry	access:friend	signature:(std::basic_istream<CharT,Traits>& is, subtract_with_carry& lcg)
std::tr1::subtract_with_carry::result_type	/usr/include/boost/tr1/random.hpp	/^   typedef IntType result_type;$/;"	t	class:std::tr1::subtract_with_carry	access:public
std::tr1::subtract_with_carry::seed	/usr/include/boost/tr1/random.hpp	/^   template<class Gen> void seed(Gen& g)$/;"	f	class:std::tr1::subtract_with_carry	access:public	signature:(Gen& g)
std::tr1::subtract_with_carry::seed	/usr/include/boost/tr1/random.hpp	/^   void seed(unsigned long value = 19780503ul)$/;"	f	class:std::tr1::subtract_with_carry	access:public	signature:(unsigned long value = 19780503ul)
std::tr1::subtract_with_carry::subtract_with_carry	/usr/include/boost/tr1/random.hpp	/^   explicit subtract_with_carry(unsigned long value)$/;"	f	class:std::tr1::subtract_with_carry	access:public	signature:(unsigned long value)
std::tr1::subtract_with_carry::subtract_with_carry	/usr/include/boost/tr1/random.hpp	/^   subtract_with_carry(){}$/;"	f	class:std::tr1::subtract_with_carry	access:public	signature:()
std::tr1::subtract_with_carry::subtract_with_carry	/usr/include/boost/tr1/random.hpp	/^   template<class Gen> subtract_with_carry(Gen& g)$/;"	f	class:std::tr1::subtract_with_carry	access:public	signature:(Gen& g)
std::tr1::subtract_with_carry_01	/usr/include/boost/tr1/random.hpp	/^class subtract_with_carry_01$/;"	c	namespace:std::tr1
std::tr1::subtract_with_carry_01::BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/tr1/random.hpp	/^   result_type max BOOST_PREVENT_MACRO_SUBSTITUTION() const$/;"	f	class:std::tr1::subtract_with_carry_01	access:public	signature:() const
std::tr1::subtract_with_carry_01::BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/tr1/random.hpp	/^   result_type min BOOST_PREVENT_MACRO_SUBSTITUTION() const$/;"	f	class:std::tr1::subtract_with_carry_01	access:public	signature:() const
std::tr1::subtract_with_carry_01::BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(int, long_lag = r);$/;"	p	class:std::tr1::subtract_with_carry_01	access:public	signature:(int, long_lag = r)
std::tr1::subtract_with_carry_01::BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(int, short_lag = s);$/;"	p	class:std::tr1::subtract_with_carry_01	access:public	signature:(int, short_lag = s)
std::tr1::subtract_with_carry_01::BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(int, word_size = w);$/;"	p	class:std::tr1::subtract_with_carry_01	access:public	signature:(int, word_size = w)
std::tr1::subtract_with_carry_01::init1	/usr/include/boost/tr1/random.hpp	/^   void init1(Gen& g, const ::boost::false_type&)$/;"	f	class:std::tr1::subtract_with_carry_01	access:private	signature:(Gen& g, const ::boost::false_type&)
std::tr1::subtract_with_carry_01::init1	/usr/include/boost/tr1/random.hpp	/^   void init1(Gen& g, const ::boost::true_type&)$/;"	f	class:std::tr1::subtract_with_carry_01	access:private	signature:(Gen& g, const ::boost::true_type&)
std::tr1::subtract_with_carry_01::init2	/usr/include/boost/tr1/random.hpp	/^   void init2(Gen& g, const ::boost::false_type&)$/;"	f	class:std::tr1::subtract_with_carry_01	access:private	signature:(Gen& g, const ::boost::false_type&)
std::tr1::subtract_with_carry_01::init2	/usr/include/boost/tr1/random.hpp	/^   void init2(Gen& g, const ::boost::true_type&)$/;"	f	class:std::tr1::subtract_with_carry_01	access:private	signature:(Gen& g, const ::boost::true_type&)
std::tr1::subtract_with_carry_01::m_gen	/usr/include/boost/tr1/random.hpp	/^   ::boost::random::subtract_with_carry_01<RealType, w, s, r, 0> m_gen;$/;"	m	class:std::tr1::subtract_with_carry_01	access:private
std::tr1::subtract_with_carry_01::operator !=	/usr/include/boost/tr1/random.hpp	/^   bool operator!=(const subtract_with_carry_01& that)const$/;"	f	class:std::tr1::subtract_with_carry_01	access:public	signature:(const subtract_with_carry_01& that) const
std::tr1::subtract_with_carry_01::operator ()	/usr/include/boost/tr1/random.hpp	/^   result_type operator()()$/;"	f	class:std::tr1::subtract_with_carry_01	access:public	signature:()
std::tr1::subtract_with_carry_01::operator <<	/usr/include/boost/tr1/random.hpp	/^   operator<<(std::basic_ostream<CharT,Traits>& os,$/;"	f	class:std::tr1::subtract_with_carry_01	access:friend	signature:(std::basic_ostream<CharT,Traits>& os, const subtract_with_carry_01& lcg)
std::tr1::subtract_with_carry_01::operator ==	/usr/include/boost/tr1/random.hpp	/^   bool operator==(const subtract_with_carry_01& that)const$/;"	f	class:std::tr1::subtract_with_carry_01	access:public	signature:(const subtract_with_carry_01& that) const
std::tr1::subtract_with_carry_01::operator >>	/usr/include/boost/tr1/random.hpp	/^   operator>>(std::basic_istream<CharT,Traits>& is,$/;"	f	class:std::tr1::subtract_with_carry_01	access:friend	signature:(std::basic_istream<CharT,Traits>& is, subtract_with_carry_01& lcg)
std::tr1::subtract_with_carry_01::result_type	/usr/include/boost/tr1/random.hpp	/^   typedef RealType result_type;$/;"	t	class:std::tr1::subtract_with_carry_01	access:public
std::tr1::subtract_with_carry_01::seed	/usr/include/boost/tr1/random.hpp	/^   template<class Gen> void seed(Gen& g)$/;"	f	class:std::tr1::subtract_with_carry_01	access:public	signature:(Gen& g)
std::tr1::subtract_with_carry_01::seed	/usr/include/boost/tr1/random.hpp	/^   void seed(unsigned long value = 19780503UL)$/;"	f	class:std::tr1::subtract_with_carry_01	access:public	signature:(unsigned long value = 19780503UL)
std::tr1::subtract_with_carry_01::subtract_with_carry_01	/usr/include/boost/tr1/random.hpp	/^   explicit subtract_with_carry_01(unsigned long value)$/;"	f	class:std::tr1::subtract_with_carry_01	access:public	signature:(unsigned long value)
std::tr1::subtract_with_carry_01::subtract_with_carry_01	/usr/include/boost/tr1/random.hpp	/^   subtract_with_carry_01(){}$/;"	f	class:std::tr1::subtract_with_carry_01	access:public	signature:()
std::tr1::subtract_with_carry_01::subtract_with_carry_01	/usr/include/boost/tr1/random.hpp	/^   template<class Gen> subtract_with_carry_01(Gen& g)$/;"	f	class:std::tr1::subtract_with_carry_01	access:public	signature:(Gen& g)
std::tr1::tuple_detail	/usr/include/boost/tr1/utility.hpp	/^namespace tuple_detail{$/;"	n	namespace:std::tr1
std::tr1::tuple_detail::const_tuple_get_result	/usr/include/boost/tr1/utility.hpp	/^   struct const_tuple_get_result$/;"	s	namespace:std::tr1::tuple_detail
std::tr1::tuple_detail::const_tuple_get_result::t1	/usr/include/boost/tr1/utility.hpp	/^      typedef typename boost::mpl::if_c<I==0, T1, T2>::type t1;$/;"	t	struct:std::tr1::tuple_detail::const_tuple_get_result	access:public
std::tr1::tuple_detail::const_tuple_get_result::t2	/usr/include/boost/tr1/utility.hpp	/^      typedef typename boost::add_const<t1>::type t2;$/;"	t	struct:std::tr1::tuple_detail::const_tuple_get_result	access:public
std::tr1::tuple_detail::const_tuple_get_result::type	/usr/include/boost/tr1/utility.hpp	/^      typedef typename boost::add_reference< const t1 >::type type;$/;"	t	struct:std::tr1::tuple_detail::const_tuple_get_result	access:public
std::tr1::tuple_detail::const_tuple_get_result::type	/usr/include/boost/tr1/utility.hpp	/^      typedef typename boost::add_reference<t2>::type type;$/;"	t	struct:std::tr1::tuple_detail::const_tuple_get_result	access:public
std::tr1::tuple_detail::get	/usr/include/boost/tr1/utility.hpp	/^inline typename tuple_detail::const_tuple_get_result<I,T1,T2>::type get(const std::pair<T1, T2>& p, const ::boost::false_type&)$/;"	f	namespace:std::tr1::tuple_detail	signature:(const std::pair<T1, T2>& p, const ::boost::false_type&)
std::tr1::tuple_detail::get	/usr/include/boost/tr1/utility.hpp	/^inline typename tuple_detail::const_tuple_get_result<I,T1,T2>::type get(const std::pair<T1, T2>& p, const ::boost::true_type&)$/;"	f	namespace:std::tr1::tuple_detail	signature:(const std::pair<T1, T2>& p, const ::boost::true_type&)
std::tr1::tuple_detail::get	/usr/include/boost/tr1/utility.hpp	/^inline typename tuple_detail::tuple_get_result<I,T1,T2>::type get(std::pair<T1, T2>& p, const ::boost::false_type&)$/;"	f	namespace:std::tr1::tuple_detail	signature:(std::pair<T1, T2>& p, const ::boost::false_type&)
std::tr1::tuple_detail::get	/usr/include/boost/tr1/utility.hpp	/^inline typename tuple_detail::tuple_get_result<I,T1,T2>::type get(std::pair<T1, T2>& p, const ::boost::true_type&)$/;"	f	namespace:std::tr1::tuple_detail	signature:(std::pair<T1, T2>& p, const ::boost::true_type&)
std::tr1::tuple_detail::tuple_get_result	/usr/include/boost/tr1/utility.hpp	/^   struct tuple_get_result$/;"	s	namespace:std::tr1::tuple_detail
std::tr1::tuple_detail::tuple_get_result::t1	/usr/include/boost/tr1/utility.hpp	/^      typedef typename boost::mpl::if_c<I==0, T1, T2>::type t1;$/;"	t	struct:std::tr1::tuple_detail::tuple_get_result	access:public
std::tr1::tuple_detail::tuple_get_result::type	/usr/include/boost/tr1/utility.hpp	/^      typedef typename boost::add_reference<t1>::type type;$/;"	t	struct:std::tr1::tuple_detail::tuple_get_result	access:public
std::tr1::tuple_element	/usr/include/boost/tr1/tuple.hpp	/^struct tuple_element$/;"	s	namespace:std::tr1
std::tr1::tuple_element	/usr/include/boost/tr1/utility.hpp	/^struct tuple_element<0, ::std::pair<T1, T2> >$/;"	s	namespace:std::tr1
std::tr1::tuple_element	/usr/include/boost/tr1/utility.hpp	/^struct tuple_element<1, std::pair<T1, T2> >$/;"	s	namespace:std::tr1
std::tr1::tuple_element::type	/usr/include/boost/tr1/tuple.hpp	/^   typedef typename boost::tuples::element<I,T>::type type;$/;"	t	struct:std::tr1::tuple_element	access:public
std::tr1::tuple_element::type	/usr/include/boost/tr1/utility.hpp	/^   typedef typename std::pair<T1, T2>::first_type type;$/;"	t	struct:std::tr1::tuple_element	access:public
std::tr1::tuple_element::type	/usr/include/boost/tr1/utility.hpp	/^   typedef typename std::pair<T1, T2>::second_type type;$/;"	t	struct:std::tr1::tuple_element	access:public
std::tr1::tuple_size	/usr/include/boost/tr1/tuple.hpp	/^struct tuple_size $/;"	s	namespace:std::tr1	inherits:::boost::integral_constant
std::tr1::tuple_size	/usr/include/boost/tr1/utility.hpp	/^struct tuple_size< ::std::pair<T1, T2> >$/;"	s	namespace:std::tr1	inherits:::boost::integral_constant
std::tr1::xor_combine	/usr/include/boost/tr1/random.hpp	/^class xor_combine$/;"	c	namespace:std::tr1
std::tr1::xor_combine::base1	/usr/include/boost/tr1/random.hpp	/^   const base1_type& base1() const$/;"	f	class:std::tr1::xor_combine	access:public	signature:() const
std::tr1::xor_combine::base1_type	/usr/include/boost/tr1/random.hpp	/^   typedef UniformRandomNumberGenerator1 base1_type;$/;"	t	class:std::tr1::xor_combine	access:public
std::tr1::xor_combine::base2	/usr/include/boost/tr1/random.hpp	/^   const base2_type& base2() const$/;"	f	class:std::tr1::xor_combine	access:public	signature:() const
std::tr1::xor_combine::base2_type	/usr/include/boost/tr1/random.hpp	/^   typedef UniformRandomNumberGenerator2 base2_type;$/;"	t	class:std::tr1::xor_combine	access:public
std::tr1::xor_combine::BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/tr1/random.hpp	/^   result_type max BOOST_PREVENT_MACRO_SUBSTITUTION() const$/;"	f	class:std::tr1::xor_combine	access:public	signature:() const
std::tr1::xor_combine::BOOST_PREVENT_MACRO_SUBSTITUTION	/usr/include/boost/tr1/random.hpp	/^   result_type min BOOST_PREVENT_MACRO_SUBSTITUTION() const$/;"	f	class:std::tr1::xor_combine	access:public	signature:() const
std::tr1::xor_combine::BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(int, shift1 = s1);$/;"	p	class:std::tr1::xor_combine	access:public	signature:(int, shift1 = s1)
std::tr1::xor_combine::BOOST_STATIC_CONSTANT	/usr/include/boost/tr1/random.hpp	/^   BOOST_STATIC_CONSTANT(int, shift2 = s2);$/;"	p	class:std::tr1::xor_combine	access:public	signature:(int, shift2 = s2)
std::tr1::xor_combine::init1	/usr/include/boost/tr1/random.hpp	/^   void init1(Gen& g, const ::boost::false_type&)$/;"	f	class:std::tr1::xor_combine	access:private	signature:(Gen& g, const ::boost::false_type&)
std::tr1::xor_combine::init1	/usr/include/boost/tr1/random.hpp	/^   void init1(Gen& g, const ::boost::true_type&)$/;"	f	class:std::tr1::xor_combine	access:private	signature:(Gen& g, const ::boost::true_type&)
std::tr1::xor_combine::init2	/usr/include/boost/tr1/random.hpp	/^   void init2(Gen& g, const ::boost::false_type&)$/;"	f	class:std::tr1::xor_combine	access:private	signature:(Gen& g, const ::boost::false_type&)
std::tr1::xor_combine::init2	/usr/include/boost/tr1/random.hpp	/^   void init2(Gen& g, const ::boost::true_type&)$/;"	f	class:std::tr1::xor_combine	access:private	signature:(Gen& g, const ::boost::true_type&)
std::tr1::xor_combine::init_minmax	/usr/include/boost/tr1/random.hpp	/^   void init_minmax();$/;"	p	class:std::tr1::xor_combine	access:private	signature:()
std::tr1::xor_combine::init_minmax	/usr/include/boost/tr1/random.hpp	/^void xor_combine<UniformRandomNumberGenerator1, s1, UniformRandomNumberGenerator2, s2>::init_minmax()$/;"	f	class:std::tr1::xor_combine	signature:()
std::tr1::xor_combine::m_b1	/usr/include/boost/tr1/random.hpp	/^   base1_type m_b1;$/;"	m	class:std::tr1::xor_combine	access:private
std::tr1::xor_combine::m_b2	/usr/include/boost/tr1/random.hpp	/^   base2_type m_b2;$/;"	m	class:std::tr1::xor_combine	access:private
std::tr1::xor_combine::m_max	/usr/include/boost/tr1/random.hpp	/^   result_type m_max;$/;"	m	class:std::tr1::xor_combine	access:private
std::tr1::xor_combine::m_min	/usr/include/boost/tr1/random.hpp	/^   result_type m_min;$/;"	m	class:std::tr1::xor_combine	access:private
std::tr1::xor_combine::operator !=	/usr/include/boost/tr1/random.hpp	/^   bool operator != (const xor_combine& that)const$/;"	f	class:std::tr1::xor_combine	access:public	signature:(const xor_combine& that) const
std::tr1::xor_combine::operator ()	/usr/include/boost/tr1/random.hpp	/^   result_type operator()()$/;"	f	class:std::tr1::xor_combine	access:public	signature:()
std::tr1::xor_combine::operator <<	/usr/include/boost/tr1/random.hpp	/^   operator<<(std::basic_ostream<CharT,Traits>& os,$/;"	f	class:std::tr1::xor_combine	access:friend	signature:(std::basic_ostream<CharT,Traits>& os, const xor_combine& lcg)
std::tr1::xor_combine::operator ==	/usr/include/boost/tr1/random.hpp	/^   bool operator == (const xor_combine& that)const$/;"	f	class:std::tr1::xor_combine	access:public	signature:(const xor_combine& that) const
std::tr1::xor_combine::operator >>	/usr/include/boost/tr1/random.hpp	/^   operator>>(std::basic_istream<CharT,Traits>& is,$/;"	f	class:std::tr1::xor_combine	access:friend	signature:(std::basic_istream<CharT,Traits>& is, xor_combine& lcg)
std::tr1::xor_combine::result_type	/usr/include/boost/tr1/random.hpp	/^   typedef unsigned long result_type;$/;"	t	class:std::tr1::xor_combine	access:public
std::tr1::xor_combine::seed	/usr/include/boost/tr1/random.hpp	/^   template<class Gen> void seed(Gen& g)$/;"	f	class:std::tr1::xor_combine	access:public	signature:(Gen& g)
std::tr1::xor_combine::seed	/usr/include/boost/tr1/random.hpp	/^   void seed()$/;"	f	class:std::tr1::xor_combine	access:public	signature:()
std::tr1::xor_combine::seed	/usr/include/boost/tr1/random.hpp	/^   void seed(unsigned long s)$/;"	f	class:std::tr1::xor_combine	access:public	signature:(unsigned long s)
std::tr1::xor_combine::xor_combine	/usr/include/boost/tr1/random.hpp	/^   template<class Gen> xor_combine(Gen& g)$/;"	f	class:std::tr1::xor_combine	access:public	signature:(Gen& g)
std::tr1::xor_combine::xor_combine	/usr/include/boost/tr1/random.hpp	/^   xor_combine(){ init_minmax(); }$/;"	f	class:std::tr1::xor_combine	access:public	signature:()
std::tr1::xor_combine::xor_combine	/usr/include/boost/tr1/random.hpp	/^   xor_combine(const base1_type & rng1, const base2_type & rng2)$/;"	f	class:std::tr1::xor_combine	access:public	signature:(const base1_type & rng1, const base2_type & rng2)
std::tr1::xor_combine::xor_combine	/usr/include/boost/tr1/random.hpp	/^   xor_combine(unsigned long s)$/;"	f	class:std::tr1::xor_combine	access:public	signature:(unsigned long s)
subtract_with_carry	/usr/include/boost/tr1/random.hpp	/^   explicit subtract_with_carry(unsigned long value)$/;"	f	class:std::tr1::subtract_with_carry	access:public	signature:(unsigned long value)
subtract_with_carry	/usr/include/boost/tr1/random.hpp	/^   subtract_with_carry(){}$/;"	f	class:std::tr1::subtract_with_carry	access:public	signature:()
subtract_with_carry	/usr/include/boost/tr1/random.hpp	/^   template<class Gen> subtract_with_carry(Gen& g)$/;"	f	class:std::tr1::subtract_with_carry	access:public	signature:(Gen& g)
subtract_with_carry	/usr/include/boost/tr1/random.hpp	/^class subtract_with_carry$/;"	c	namespace:std::tr1
subtract_with_carry_01	/usr/include/boost/tr1/random.hpp	/^   explicit subtract_with_carry_01(unsigned long value)$/;"	f	class:std::tr1::subtract_with_carry_01	access:public	signature:(unsigned long value)
subtract_with_carry_01	/usr/include/boost/tr1/random.hpp	/^   subtract_with_carry_01(){}$/;"	f	class:std::tr1::subtract_with_carry_01	access:public	signature:()
subtract_with_carry_01	/usr/include/boost/tr1/random.hpp	/^   template<class Gen> subtract_with_carry_01(Gen& g)$/;"	f	class:std::tr1::subtract_with_carry_01	access:public	signature:(Gen& g)
subtract_with_carry_01	/usr/include/boost/tr1/random.hpp	/^class subtract_with_carry_01$/;"	c	namespace:std::tr1
swap	/usr/include/boost/tr1/memory.hpp	/^template<class T> void swap(shared_ptr<T> & a, shared_ptr<T> & b);$/;"	p	namespace:boost	signature:(shared_ptr<T> & a, shared_ptr<T> & b)
swap	/usr/include/boost/tr1/memory.hpp	/^template<class T> void swap(weak_ptr<T> & a, weak_ptr<T> & b);$/;"	p	namespace:boost	signature:(weak_ptr<T> & a, weak_ptr<T> & b)
t1	/usr/include/boost/tr1/utility.hpp	/^      typedef typename boost::mpl::if_c<I==0, T1, T2>::type t1;$/;"	t	struct:std::tr1::tuple_detail::const_tuple_get_result	access:public
t1	/usr/include/boost/tr1/utility.hpp	/^      typedef typename boost::mpl::if_c<I==0, T1, T2>::type t1;$/;"	t	struct:std::tr1::tuple_detail::tuple_get_result	access:public
t2	/usr/include/boost/tr1/utility.hpp	/^      typedef typename boost::add_const<t1>::type t2;$/;"	t	struct:std::tr1::tuple_detail::const_tuple_get_result	access:public
tr1	/usr/include/boost/tr1/array.hpp	/^namespace std{ namespace tr1{$/;"	n	namespace:std
tr1	/usr/include/boost/tr1/array.hpp	/^}} namespace std{ namespace tr1{$/;"	n	namespace:std
tr1	/usr/include/boost/tr1/cmath.hpp	/^namespace std{ namespace tr1{$/;"	n	namespace:std
tr1	/usr/include/boost/tr1/complex.hpp	/^namespace tr1 {$/;"	n	namespace:std
tr1	/usr/include/boost/tr1/functional.hpp	/^namespace std{ namespace tr1{$/;"	n	namespace:std
tr1	/usr/include/boost/tr1/memory.hpp	/^namespace std{ namespace tr1{$/;"	n	namespace:std
tr1	/usr/include/boost/tr1/random.hpp	/^namespace std { namespace tr1{$/;"	n	namespace:std
tr1	/usr/include/boost/tr1/regex.hpp	/^namespace std{ namespace tr1{$/;"	n	namespace:std
tr1	/usr/include/boost/tr1/tuple.hpp	/^namespace std{ namespace tr1{$/;"	n	namespace:std
tr1	/usr/include/boost/tr1/type_traits.hpp	/^namespace std { namespace tr1{$/;"	n	namespace:std
tr1	/usr/include/boost/tr1/unordered_map.hpp	/^namespace std{ namespace tr1{$/;"	n	namespace:std
tr1	/usr/include/boost/tr1/unordered_set.hpp	/^namespace std{ namespace tr1{$/;"	n	namespace:std
tr1	/usr/include/boost/tr1/utility.hpp	/^namespace std{ namespace tr1{$/;"	n	namespace:std
tr1_detail	/usr/include/boost/tr1/detail/math_overloads.hpp	/^namespace boost{ namespace tr1_detail{$/;"	n	namespace:boost
tr1_details	/usr/include/boost/tr1/detail/functor2iterator.hpp	/^namespace boost{ namespace tr1_details{$/;"	n	namespace:boost
tuple_detail	/usr/include/boost/tr1/utility.hpp	/^namespace tuple_detail{$/;"	n	namespace:std::tr1
tuple_element	/usr/include/boost/tr1/array.hpp	/^struct tuple_element<I, ::boost::array<T, N> >$/;"	s	namespace:boost::fusion
tuple_element	/usr/include/boost/tr1/tuple.hpp	/^struct tuple_element$/;"	s	namespace:std::tr1
tuple_element	/usr/include/boost/tr1/utility.hpp	/^struct tuple_element<0, ::std::pair<T1, T2> >$/;"	s	namespace:std::tr1
tuple_element	/usr/include/boost/tr1/utility.hpp	/^struct tuple_element<1, std::pair<T1, T2> >$/;"	s	namespace:std::tr1
tuple_get_result	/usr/include/boost/tr1/utility.hpp	/^   struct tuple_get_result$/;"	s	namespace:std::tr1::tuple_detail
tuple_size	/usr/include/boost/tr1/array.hpp	/^struct tuple_size< ::boost::array<T, N> >$/;"	s	namespace:boost::fusion	inherits:::boost::integral_constant
tuple_size	/usr/include/boost/tr1/tuple.hpp	/^struct tuple_size $/;"	s	namespace:std::tr1	inherits:::boost::integral_constant
tuple_size	/usr/include/boost/tr1/utility.hpp	/^struct tuple_size< ::std::pair<T1, T2> >$/;"	s	namespace:std::tr1	inherits:::boost::integral_constant
type	/usr/include/boost/tr1/array.hpp	/^   typedef T type;$/;"	t	struct:boost::fusion::tuple_element	access:public
type	/usr/include/boost/tr1/detail/math_overloads.hpp	/^   >::type type;$/;"	t	struct:boost::tr1_detail::largest_real	access:public
type	/usr/include/boost/tr1/detail/math_overloads.hpp	/^   >::type type;$/;"	t	struct:boost::tr1_detail::promote_to_real	access:public
type	/usr/include/boost/tr1/tuple.hpp	/^   typedef typename boost::tuples::element<I,T>::type type;$/;"	t	struct:std::tr1::tuple_element	access:public
type	/usr/include/boost/tr1/utility.hpp	/^      typedef typename boost::add_reference< const t1 >::type type;$/;"	t	struct:std::tr1::tuple_detail::const_tuple_get_result	access:public
type	/usr/include/boost/tr1/utility.hpp	/^      typedef typename boost::add_reference<t1>::type type;$/;"	t	struct:std::tr1::tuple_detail::tuple_get_result	access:public
type	/usr/include/boost/tr1/utility.hpp	/^      typedef typename boost::add_reference<t2>::type type;$/;"	t	struct:std::tr1::tuple_detail::const_tuple_get_result	access:public
type	/usr/include/boost/tr1/utility.hpp	/^   typedef typename std::pair<T1, T2>::first_type type;$/;"	t	struct:std::tr1::tuple_element	access:public
type	/usr/include/boost/tr1/utility.hpp	/^   typedef typename std::pair<T1, T2>::second_type type;$/;"	t	struct:std::tr1::tuple_element	access:public
xor_combine	/usr/include/boost/tr1/random.hpp	/^   template<class Gen> xor_combine(Gen& g)$/;"	f	class:std::tr1::xor_combine	access:public	signature:(Gen& g)
xor_combine	/usr/include/boost/tr1/random.hpp	/^   xor_combine(){ init_minmax(); }$/;"	f	class:std::tr1::xor_combine	access:public	signature:()
xor_combine	/usr/include/boost/tr1/random.hpp	/^   xor_combine(const base1_type & rng1, const base2_type & rng2)$/;"	f	class:std::tr1::xor_combine	access:public	signature:(const base1_type & rng1, const base2_type & rng2)
xor_combine	/usr/include/boost/tr1/random.hpp	/^   xor_combine(unsigned long s)$/;"	f	class:std::tr1::xor_combine	access:public	signature:(unsigned long s)
xor_combine	/usr/include/boost/tr1/random.hpp	/^class xor_combine$/;"	c	namespace:std::tr1
